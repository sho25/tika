begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|ctakes
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ctakes
operator|.
name|typesystem
operator|.
name|type
operator|.
name|refsem
operator|.
name|UmlsConcept
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ctakes
operator|.
name|typesystem
operator|.
name|type
operator|.
name|textsem
operator|.
name|IdentifiedAnnotation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|UIMAFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|analysis_engine
operator|.
name|AnalysisEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|cas
operator|.
name|impl
operator|.
name|XCASSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|cas
operator|.
name|impl
operator|.
name|XmiCasSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|cas
operator|.
name|impl
operator|.
name|XmiSerializationSharedData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|jcas
operator|.
name|JCas
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|jcas
operator|.
name|cas
operator|.
name|FSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|resource
operator|.
name|ResourceInitializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|resource
operator|.
name|ResourceSpecifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|util
operator|.
name|InvalidXMLException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|util
operator|.
name|XMLInputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|uima
operator|.
name|util
operator|.
name|XmlCasSerializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  * This class provides methods to extract biomedical information from plain text  * using {@see CTAKESContentHandler} that relies on Apache cTAKES.  *   *<p>  * Apache cTAKES is built on top of<a href="https://uima.apache.org/">Apache  * UIMA</a> framework and<a href="https://opennlp.apache.org/">OpenNLP</a>  * toolkit.  *</p>  */
end_comment

begin_class
specifier|public
class|class
name|CTAKESUtils
block|{
comment|// UMLS username property
specifier|private
specifier|final
specifier|static
name|String
name|CTAKES_UMLS_USER
init|=
literal|"ctakes.umlsuser"
decl_stmt|;
comment|// UMLS password property
specifier|private
specifier|final
specifier|static
name|String
name|CTAKES_UMLS_PASS
init|=
literal|"ctakes.umlspw"
decl_stmt|;
comment|/** 	 * Returns a new UIMA Analysis Engine (AE). This method ensures that only 	 * one instance of an AE is created. 	 *  	 *<p> 	 * An Analysis Engine is a component responsible for analyzing unstructured 	 * information, discovering and representing semantic content. Unstructured 	 * information includes, but is not restricted to, text documents. 	 *</p> 	 *  	 * @param aeDescriptor 	 *            pathname for XML file including an AnalysisEngineDescription 	 *            that contains all of the information needed to instantiate and 	 *            use an AnalysisEngine. 	 * @param umlsUser 	 *            UMLS username for NLM database 	 * @param umlsPass 	 *            UMLS password for NLM database 	 * @return an Analysis Engine for analyzing unstructured information. 	 * @throws IOException 	 *             if any I/O error occurs. 	 * @throws InvalidXMLException 	 *             if the input XML is not valid or does not specify a valid 	 *             ResourceSpecifier. 	 * @throws ResourceInitializationException 	 *             if a failure occurred during production of the resource. 	 * @throws URISyntaxException 	 *             if URL of the resource is not formatted strictly according to 	 *             to RFC2396 and cannot be converted to a URI. 	 */
specifier|public
specifier|static
name|AnalysisEngine
name|getAnalysisEngine
parameter_list|(
name|String
name|aeDescriptor
parameter_list|,
name|String
name|umlsUser
parameter_list|,
name|String
name|umlsPass
parameter_list|)
throws|throws
name|IOException
throws|,
name|InvalidXMLException
throws|,
name|ResourceInitializationException
throws|,
name|URISyntaxException
block|{
comment|// UMLS user ID and password.
name|String
name|aeDescriptorPath
init|=
name|CTAKESUtils
operator|.
name|class
operator|.
name|getResource
argument_list|(
name|aeDescriptor
argument_list|)
operator|.
name|toURI
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// get Resource Specifier from XML
name|XMLInputSource
name|aeIputSource
init|=
operator|new
name|XMLInputSource
argument_list|(
name|aeDescriptorPath
argument_list|)
decl_stmt|;
name|ResourceSpecifier
name|aeSpecifier
init|=
name|UIMAFramework
operator|.
name|getXMLParser
argument_list|()
operator|.
name|parseResourceSpecifier
argument_list|(
name|aeIputSource
argument_list|)
decl_stmt|;
comment|// UMLS user ID and password
if|if
condition|(
operator|(
name|umlsUser
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|umlsUser
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|umlsPass
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|umlsPass
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|/* 			 * It is highly recommended that you change UMLS credentials in the 			 * XML configuration file instead of giving user and password using 			 * CTAKESConfig. 			 */
name|System
operator|.
name|setProperty
argument_list|(
name|CTAKES_UMLS_USER
argument_list|,
name|umlsUser
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|CTAKES_UMLS_PASS
argument_list|,
name|umlsPass
argument_list|)
expr_stmt|;
block|}
comment|// create AE
name|AnalysisEngine
name|ae
init|=
name|UIMAFramework
operator|.
name|produceAnalysisEngine
argument_list|(
name|aeSpecifier
argument_list|)
decl_stmt|;
return|return
name|ae
return|;
block|}
comment|/** 	 * Returns a new JCas () appropriate for the given Analysis Engine. This 	 * method ensures that only one instance of a JCas is created. A Jcas is a 	 * Java Cover Classes based Object-oriented CAS (Common Analysis System) 	 * API. 	 *  	 *<p> 	 * Important: It is highly recommended that you reuse CAS objects rather 	 * than creating new CAS objects prior to each analysis. This is because CAS 	 * objects may be expensive to create and may consume a significant amount 	 * of memory. 	 *</p> 	 *  	 * @param ae 	 *            AnalysisEngine used to create an appropriate JCas object. 	 * @return a JCas object appropriate for the given AnalysisEngine. 	 * @throws ResourceInitializationException 	 *             if a CAS could not be created because this AnalysisEngine's 	 *             CAS metadata (type system, type priorities, or FS indexes) 	 *             are invalid. 	 */
specifier|public
specifier|static
name|JCas
name|getJCas
parameter_list|(
name|AnalysisEngine
name|ae
parameter_list|)
throws|throws
name|ResourceInitializationException
block|{
name|JCas
name|jcas
init|=
name|ae
operator|.
name|newJCas
argument_list|()
decl_stmt|;
return|return
name|jcas
return|;
block|}
comment|/** 	 * Serializes a CAS in the given format. 	 *  	 * @param jcas 	 *            CAS (Common Analysis System) to be serialized. 	 * @param type 	 *            type of cTAKES (UIMA) serializer used to write CAS. 	 * @param prettyPrint 	 *            {@code true} to do pretty printing of output. 	 * @param stream 	 *            {@see OutputStream} object used to print out information 	 *            extracted by using cTAKES. 	 * @throws SAXException 	 *             if there was a SAX exception. 	 * @throws IOException 	 *             if any I/O error occurs. 	 */
specifier|public
specifier|static
name|void
name|serialize
parameter_list|(
name|JCas
name|jcas
parameter_list|,
name|CTAKESSerializer
name|type
parameter_list|,
name|boolean
name|prettyPrint
parameter_list|,
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|SAXException
throws|,
name|IOException
block|{
if|if
condition|(
name|type
operator|==
name|CTAKESSerializer
operator|.
name|XCAS
condition|)
block|{
name|XCASSerializer
operator|.
name|serialize
argument_list|(
name|jcas
operator|.
name|getCas
argument_list|()
argument_list|,
name|stream
argument_list|,
name|prettyPrint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CTAKESSerializer
operator|.
name|XMI
condition|)
block|{
name|XmiCasSerializer
operator|.
name|serialize
argument_list|(
name|jcas
operator|.
name|getCas
argument_list|()
argument_list|,
name|jcas
operator|.
name|getTypeSystem
argument_list|()
argument_list|,
name|stream
argument_list|,
name|prettyPrint
argument_list|,
operator|new
name|XmiSerializationSharedData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XmlCasSerializer
operator|.
name|serialize
argument_list|(
name|jcas
operator|.
name|getCas
argument_list|()
argument_list|,
name|jcas
operator|.
name|getTypeSystem
argument_list|()
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Returns the annotation value based on the given annotation type. 	 *  	 * @param annotation 	 *            {@see IdentifiedAnnotation} object. 	 * @param property 	 *            {@see CTAKESAnnotationProperty} enum used to identify the 	 *            annotation type. 	 * @return the annotation value. 	 */
specifier|public
specifier|static
name|String
name|getAnnotationProperty
parameter_list|(
name|IdentifiedAnnotation
name|annotation
parameter_list|,
name|CTAKESAnnotationProperty
name|property
parameter_list|)
block|{
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|BEGIN
condition|)
block|{
name|value
operator|=
name|Integer
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getBegin
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|END
condition|)
block|{
name|value
operator|=
name|Integer
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|CONDITIONAL
condition|)
block|{
name|value
operator|=
name|Boolean
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getConditional
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|CONFIDENCE
condition|)
block|{
name|value
operator|=
name|Float
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getConfidence
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|DISCOVERY_TECNIQUE
condition|)
block|{
name|value
operator|=
name|Integer
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getDiscoveryTechnique
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|GENERIC
condition|)
block|{
name|value
operator|=
name|Boolean
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getGeneric
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|HISTORY_OF
condition|)
block|{
name|value
operator|=
name|Integer
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getHistoryOf
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|ID
condition|)
block|{
name|value
operator|=
name|Integer
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|ONTOLOGY_CONCEPT_ARR
condition|)
block|{
name|FSArray
name|mentions
init|=
name|annotation
operator|.
name|getOntologyConceptArr
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|mentions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mentions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mentions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|UmlsConcept
condition|)
block|{
name|UmlsConcept
name|concept
init|=
operator|(
name|UmlsConcept
operator|)
name|mentions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"cui="
argument_list|)
operator|.
name|append
argument_list|(
name|concept
operator|.
name|getCui
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
operator|.
name|append
argument_list|(
name|concept
operator|.
name|getCodingScheme
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|concept
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|mentions
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|value
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|==
name|CTAKESAnnotationProperty
operator|.
name|POLARITY
condition|)
block|{
name|String
name|polarity_pref
init|=
literal|"POLARITY"
decl_stmt|;
name|value
operator|=
operator|new
name|StringBuilder
argument_list|(
name|polarity_pref
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|annotation
operator|.
name|getPolarity
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/** 	 * Resets cTAKES objects, if created. This method ensures that new cTAKES 	 * objects (a.k.a., Analysis Engine and JCas) will be created if getters of 	 * this class are called. 	 *  	 * @param ae UIMA Analysis Engine 	 * @param jcas JCas object 	 */
specifier|public
specifier|static
name|void
name|reset
parameter_list|(
name|AnalysisEngine
name|ae
parameter_list|,
name|JCas
name|jcas
parameter_list|)
block|{
comment|// Analysis Engine
name|resetAE
argument_list|(
name|ae
argument_list|)
expr_stmt|;
comment|// JCas
name|resetCAS
argument_list|(
name|jcas
argument_list|)
expr_stmt|;
name|jcas
operator|=
literal|null
expr_stmt|;
block|}
comment|/** 	 * Resets the CAS (Common Analysis System), emptying it of all content. 	 *  	 * @param jcas JCas object 	 */
specifier|public
specifier|static
name|void
name|resetCAS
parameter_list|(
name|JCas
name|jcas
parameter_list|)
block|{
if|if
condition|(
name|jcas
operator|!=
literal|null
condition|)
block|{
name|jcas
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Resets the AE (AnalysisEngine), releasing all resources held by the 	 * current AE. 	 *  	 * @param ae UIMA Analysis Engine 	 */
specifier|public
specifier|static
name|void
name|resetAE
parameter_list|(
name|AnalysisEngine
name|ae
parameter_list|)
block|{
if|if
condition|(
name|ae
operator|!=
literal|null
condition|)
block|{
name|ae
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|ae
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

