begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|pkg
package|;
end_package

begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|CompressorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|CompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|CompressorOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|CompressorStreamProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|bzip2
operator|.
name|BZip2CompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|deflate
operator|.
name|DeflateCompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|gzip
operator|.
name|GzipCompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|lzma
operator|.
name|LZMAUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|pack200
operator|.
name|Pack200CompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|snappy
operator|.
name|FramedSnappyCompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|snappy
operator|.
name|SnappyCompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|xz
operator|.
name|XZCompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|xz
operator|.
name|XZUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|z
operator|.
name|ZCompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|ServiceLoaderIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaMemoryLimitException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tukaani
operator|.
name|xz
operator|.
name|LZMAInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|tukaani
operator|.
name|xz
operator|.
name|MemoryLimitException
import|;
end_import

begin_comment
comment|/**  * This is a temporary copy/paste hack from commons-compress for Tika 1.15  * that 1) allows detection without initialization of a stream and  * 2) prevents easily preventable OOM on two file formats.  *  * Once commons-compress 1.14 is released, we will delete this class  * and go back to commons-compress's CompressorStreamFactory.  */
end_comment

begin_class
annotation|@
name|Deprecated
class|class
name|TikaCompressorStreamFactory
implements|implements
name|CompressorStreamProvider
block|{
specifier|private
specifier|static
specifier|final
name|TikaCompressorStreamFactory
name|SINGLETON
init|=
operator|new
name|TikaCompressorStreamFactory
argument_list|(
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the BZIP2 compression          * algorithm.          *          * @since 1.1          */
specifier|public
specifier|static
specifier|final
name|String
name|BZIP2
init|=
literal|"bzip2"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the GZIP compression          * algorithm.          *          * @since 1.1          */
specifier|public
specifier|static
specifier|final
name|String
name|GZIP
init|=
literal|"gz"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the PACK200 compression          * algorithm.          *          * @since 1.3          */
specifier|public
specifier|static
specifier|final
name|String
name|PACK200
init|=
literal|"pack200"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the XZ compression method.          *          * @since 1.4          */
specifier|public
specifier|static
specifier|final
name|String
name|XZ
init|=
literal|"xz"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the LZMA compression method.          *          * @since 1.6          */
specifier|public
specifier|static
specifier|final
name|String
name|LZMA
init|=
literal|"lzma"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the "framed" Snappy          * compression method.          *          * @since 1.7          */
specifier|public
specifier|static
specifier|final
name|String
name|SNAPPY_FRAMED
init|=
literal|"snappy-framed"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the "raw" Snappy compression          * method. Not supported as an output stream type.          *          * @since 1.7          */
specifier|public
specifier|static
specifier|final
name|String
name|SNAPPY_RAW
init|=
literal|"snappy-raw"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the traditional Unix compress          * method. Not supported as an output stream type.          *          * @since 1.7          */
specifier|public
specifier|static
specifier|final
name|String
name|Z
init|=
literal|"z"
decl_stmt|;
comment|/**          * Constant (value {@value}) used to identify the Deflate compress method.          *          * @since 1.9          */
specifier|public
specifier|static
specifier|final
name|String
name|DEFLATE
init|=
literal|"deflate"
decl_stmt|;
specifier|private
specifier|final
name|int
name|memoryLimitInKb
decl_stmt|;
specifier|private
name|SortedMap
argument_list|<
name|String
argument_list|,
name|CompressorStreamProvider
argument_list|>
name|compressorInputStreamProviders
decl_stmt|;
specifier|public
specifier|static
name|String
name|getBzip2
parameter_list|()
block|{
return|return
name|BZIP2
return|;
block|}
specifier|public
specifier|static
name|String
name|getDeflate
parameter_list|()
block|{
return|return
name|DEFLATE
return|;
block|}
specifier|public
specifier|static
name|String
name|getGzip
parameter_list|()
block|{
return|return
name|GZIP
return|;
block|}
specifier|public
specifier|static
name|String
name|getLzma
parameter_list|()
block|{
return|return
name|LZMA
return|;
block|}
specifier|public
specifier|static
name|String
name|getPack200
parameter_list|()
block|{
return|return
name|PACK200
return|;
block|}
specifier|public
specifier|static
name|TikaCompressorStreamFactory
name|getSingleton
parameter_list|()
block|{
return|return
name|SINGLETON
return|;
block|}
specifier|public
specifier|static
name|String
name|getSnappyFramed
parameter_list|()
block|{
return|return
name|SNAPPY_FRAMED
return|;
block|}
specifier|public
specifier|static
name|String
name|getSnappyRaw
parameter_list|()
block|{
return|return
name|SNAPPY_RAW
return|;
block|}
specifier|public
specifier|static
name|String
name|getXz
parameter_list|()
block|{
return|return
name|XZ
return|;
block|}
specifier|public
specifier|static
name|String
name|getZ
parameter_list|()
block|{
return|return
name|Z
return|;
block|}
specifier|static
name|void
name|putAll
parameter_list|(
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
specifier|final
name|CompressorStreamProvider
name|provider
parameter_list|,
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|CompressorStreamProvider
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
specifier|final
name|String
name|name
range|:
name|names
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|toKey
argument_list|(
name|name
argument_list|)
argument_list|,
name|provider
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
name|toKey
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
return|;
block|}
comment|/**          * If true, decompress until the end of the input. If false, stop after the          * first stream and leave the input position to point to the next byte after          * the stream          */
specifier|private
specifier|final
name|Boolean
name|decompressUntilEOF
decl_stmt|;
comment|/**          * If true, decompress until the end of the input. If false, stop after the          * first stream and leave the input position to point to the next byte after          * the stream          */
specifier|private
specifier|volatile
name|boolean
name|decompressConcatenated
init|=
literal|false
decl_stmt|;
comment|/**          * Create an instance with the provided decompress Concatenated option.          *          * @param decompressUntilEOF          *            if true, decompress until the end of the input; if false, stop          *            after the first stream and leave the input position to point          *            to the next byte after the stream. This setting applies to the          *            gzip, bzip2 and xz formats only.          * @since 1.10          */
specifier|public
name|TikaCompressorStreamFactory
parameter_list|(
specifier|final
name|boolean
name|decompressUntilEOF
parameter_list|,
specifier|final
name|int
name|memoryLimitInKb
parameter_list|)
block|{
name|this
operator|.
name|decompressUntilEOF
operator|=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|decompressUntilEOF
argument_list|)
expr_stmt|;
comment|// Also copy to existing variable so can continue to use that as the
comment|// current value
name|this
operator|.
name|decompressConcatenated
operator|=
name|decompressUntilEOF
expr_stmt|;
name|this
operator|.
name|memoryLimitInKb
operator|=
name|memoryLimitInKb
expr_stmt|;
block|}
comment|/**          * Try to detect the type of compressor stream.          *          * @param in input stream          * @return type of compressor stream detected          * @throws CompressorException if no compressor stream type was detected          *                             or if something else went wrong          * @throws IllegalArgumentException if stream is null or does not support mark          *          * @since 1.14          */
specifier|public
specifier|static
name|String
name|detect
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|CompressorException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Stream must not be null."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Mark is not supported."
argument_list|)
throw|;
block|}
specifier|final
name|byte
index|[]
name|signature
init|=
operator|new
name|byte
index|[
literal|12
index|]
decl_stmt|;
name|in
operator|.
name|mark
argument_list|(
name|signature
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|signatureLength
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|signatureLength
operator|=
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"IOException while reading signature."
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|BZip2CompressorInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|BZIP2
return|;
block|}
if|if
condition|(
name|GzipCompressorInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|GZIP
return|;
block|}
if|if
condition|(
name|Pack200CompressorInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|PACK200
return|;
block|}
if|if
condition|(
name|FramedSnappyCompressorInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|SNAPPY_FRAMED
return|;
block|}
if|if
condition|(
name|ZCompressorInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|Z
return|;
block|}
if|if
condition|(
name|DeflateCompressorInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|DEFLATE
return|;
block|}
if|if
condition|(
name|XZUtils
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|XZ
return|;
block|}
if|if
condition|(
name|LZMAUtils
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|LZMA
return|;
block|}
comment|/*            if (FramedLZ4CompressorInputStream.matches(signature, signatureLength)) {                 return LZ4_FRAMED;             }*/
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"No Compressor found for the stream signature."
argument_list|)
throw|;
block|}
specifier|public
name|SortedMap
argument_list|<
name|String
argument_list|,
name|CompressorStreamProvider
argument_list|>
name|getCompressorInputStreamProviders
parameter_list|()
block|{
if|if
condition|(
name|compressorInputStreamProviders
operator|==
literal|null
condition|)
block|{
name|compressorInputStreamProviders
operator|=
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|findAvailableCompressorInputStreamProviders
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|compressorInputStreamProviders
return|;
block|}
specifier|public
specifier|static
name|SortedMap
argument_list|<
name|String
argument_list|,
name|CompressorStreamProvider
argument_list|>
name|findAvailableCompressorInputStreamProviders
parameter_list|()
block|{
return|return
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|SortedMap
argument_list|<
name|String
argument_list|,
name|CompressorStreamProvider
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|String
argument_list|,
name|CompressorStreamProvider
argument_list|>
name|run
parameter_list|()
block|{
specifier|final
name|TreeMap
argument_list|<
name|String
argument_list|,
name|CompressorStreamProvider
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|putAll
argument_list|(
name|SINGLETON
operator|.
name|getInputStreamCompressorNames
argument_list|()
argument_list|,
name|SINGLETON
argument_list|,
name|map
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|CompressorStreamProvider
name|provider
range|:
name|findCompressorStreamProviders
argument_list|()
control|)
block|{
name|putAll
argument_list|(
name|provider
operator|.
name|getInputStreamCompressorNames
argument_list|()
argument_list|,
name|provider
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
block|}
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|CompressorStreamProvider
argument_list|>
name|findCompressorStreamProviders
parameter_list|()
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|serviceLoaderIterator
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Iterator
argument_list|<
name|CompressorStreamProvider
argument_list|>
name|serviceLoaderIterator
parameter_list|()
block|{
return|return
operator|new
name|ServiceLoaderIterator
argument_list|<>
argument_list|(
name|CompressorStreamProvider
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**          * Create an compressor input stream from an input stream, autodetecting the          * compressor type from the first few bytes of the stream. The InputStream          * must support marks, like BufferedInputStream.          *          * @param in          *            the input stream          * @return the compressor input stream          * @throws CompressorException          *             if the compressor name is not known          * @throws IllegalArgumentException          *             if the stream is null or does not support mark          * @since 1.1          */
specifier|public
name|CompressorInputStream
name|createCompressorInputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|CompressorException
throws|,
name|TikaMemoryLimitException
block|{
return|return
name|createCompressorInputStream
argument_list|(
name|detect
argument_list|(
name|in
argument_list|)
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**          * Creates a compressor input stream from a compressor name and an input          * stream.          *          * @param name          *            of the compressor, i.e. {@value #GZIP}, {@value #BZIP2},          *            {@value #XZ}, {@value #LZMA}, {@value #PACK200},          *            {@value #SNAPPY_RAW}, {@value #SNAPPY_FRAMED}, {@value #Z},          *            or {@value #DEFLATE}          * @param in          *            the input stream          * @return compressor input stream          * @throws CompressorException          *             if the compressor name is not known or not available          * @throws IllegalArgumentException          *             if the name or input stream is null          */
specifier|public
name|CompressorInputStream
name|createCompressorInputStream
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|CompressorException
throws|,
name|TikaMemoryLimitException
block|{
return|return
name|createCompressorInputStream
argument_list|(
name|name
argument_list|,
name|in
argument_list|,
name|decompressConcatenated
argument_list|)
return|;
block|}
specifier|public
name|CompressorInputStream
name|createCompressorInputStream
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|InputStream
name|in
parameter_list|,
specifier|final
name|boolean
name|actualDecompressConcatenated
parameter_list|)
throws|throws
name|CompressorException
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Compressor name and stream must not be null."
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|GZIP
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|GzipCompressorInputStream
argument_list|(
name|in
argument_list|,
name|actualDecompressConcatenated
argument_list|)
return|;
block|}
if|if
condition|(
name|BZIP2
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|BZip2CompressorInputStream
argument_list|(
name|in
argument_list|,
name|actualDecompressConcatenated
argument_list|)
return|;
block|}
if|if
condition|(
name|XZ
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|XZUtils
operator|.
name|isXZCompressionAvailable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"XZ compression is not available."
argument_list|)
throw|;
block|}
return|return
operator|new
name|XZCompressorInputStream
argument_list|(
name|in
argument_list|,
name|actualDecompressConcatenated
argument_list|)
return|;
block|}
if|if
condition|(
name|LZMA
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|LZMAUtils
operator|.
name|isLZMACompressionAvailable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"LZMA compression is not available"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
operator|new
name|SaferLZMACompressorInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MemoryLimitException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"MemoryLimitException: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|PACK200
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|Pack200CompressorInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|SNAPPY_RAW
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|SnappyCompressorInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|SNAPPY_FRAMED
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|FramedSnappyCompressorInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|Z
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
try|try
block|{
return|return
operator|new
name|SaferZCompressorInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|TikaRuntimeMemoryLimitException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"MemoryLimitException: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|DEFLATE
operator|.
name|equalsIgnoreCase
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|DeflateCompressorInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
comment|/* not currently supported                 if (LZ4_BLOCK.equalsIgnoreCase(name)) {                     return new BlockLZ4CompressorInputStream(in);                 }                  if (LZ4_FRAMED.equalsIgnoreCase(name)) {                     return new FramedLZ4CompressorInputStream(in, actualDecompressConcatenated);                 }  */
block|}
catch|catch
parameter_list|(
specifier|final
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"Could not create CompressorInputStream."
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|CompressorStreamProvider
name|compressorStreamProvider
init|=
name|getCompressorInputStreamProviders
argument_list|()
operator|.
name|get
argument_list|(
name|toKey
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|compressorStreamProvider
operator|!=
literal|null
condition|)
block|{
return|return
name|compressorStreamProvider
operator|.
name|createCompressorInputStream
argument_list|(
name|name
argument_list|,
name|in
argument_list|,
name|actualDecompressConcatenated
argument_list|)
return|;
block|}
throw|throw
operator|new
name|CompressorException
argument_list|(
literal|"Compressor: "
operator|+
name|name
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|CompressorOutputStream
name|createCompressorOutputStream
parameter_list|(
name|String
name|s
parameter_list|,
name|OutputStream
name|outputStream
parameter_list|)
throws|throws
name|CompressorException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
comment|// For Unit tests
name|boolean
name|getDecompressConcatenated
parameter_list|()
block|{
return|return
name|decompressConcatenated
return|;
block|}
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getInputStreamCompressorNames
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|newHashSet
argument_list|(
name|GZIP
argument_list|,
name|BZIP2
argument_list|,
name|XZ
argument_list|,
name|LZMA
argument_list|,
name|PACK200
argument_list|,
name|DEFLATE
argument_list|,
name|SNAPPY_RAW
argument_list|,
name|SNAPPY_FRAMED
argument_list|,
name|Z
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getOutputStreamCompressorNames
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|Boolean
name|getDecompressUntilEOF
parameter_list|()
block|{
return|return
name|decompressUntilEOF
return|;
block|}
specifier|private
class|class
name|SaferZCompressorInputStream
extends|extends
name|ZCompressorInputStream
block|{
specifier|public
name|SaferZCompressorInputStream
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|inputStream
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|initializeTables
parameter_list|(
name|int
name|maxCodeSize
parameter_list|)
block|{
name|int
name|maxTableSize
init|=
literal|1
operator|<<
name|maxCodeSize
decl_stmt|;
if|if
condition|(
name|memoryLimitInKb
operator|>
operator|-
literal|1
operator|&&
name|maxTableSize
operator|>
operator|(
name|memoryLimitInKb
operator|*
literal|1024
operator|)
condition|)
block|{
throw|throw
operator|new
name|TikaRuntimeMemoryLimitException
argument_list|(
literal|"Calculated maxCodeSize ("
operator|+
name|maxCodeSize
operator|+
literal|" bytes) is greater "
operator|+
literal|"than the maximum allowable ("
operator|+
operator|(
name|memoryLimitInKb
operator|*
literal|1024
operator|)
operator|+
literal|" bytes).\n"
operator|+
literal|"If the file is not corrupt, consider increasing "
operator|+
literal|"the memoryLimitInKb parameter in the CompressorParser"
argument_list|)
throw|;
block|}
name|super
operator|.
name|initializeTables
argument_list|(
name|maxCodeSize
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|TikaRuntimeMemoryLimitException
extends|extends
name|RuntimeException
block|{
specifier|public
name|TikaRuntimeMemoryLimitException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
class|class
name|SaferLZMACompressorInputStream
extends|extends
name|CompressorInputStream
block|{
specifier|private
specifier|final
name|InputStream
name|in
decl_stmt|;
comment|/**          * Creates a new input stream that decompresses LZMA-compressed data          * from the specified input stream.          *          * @param       inputStream where to read the compressed data          *          * @throws      IOException if the input is not in the .lzma format,          *                          the input is corrupt or truncated, the .lzma          *                          headers specify sizes that are not supported          *                          by this implementation, or the underlying          *<code>inputStream</code> throws an exception          */
specifier|public
name|SaferLZMACompressorInputStream
parameter_list|(
specifier|final
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|in
operator|=
operator|new
name|LZMAInputStream
argument_list|(
name|inputStream
argument_list|,
name|memoryLimitInKb
argument_list|)
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|ret
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
name|count
argument_list|(
name|ret
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|ret
init|=
name|in
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|count
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|long
name|skip
parameter_list|(
specifier|final
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|skip
argument_list|(
name|n
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|available
argument_list|()
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

