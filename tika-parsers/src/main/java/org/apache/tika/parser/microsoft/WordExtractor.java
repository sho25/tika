begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|microsoft
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|HWPFDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|HWPFOldDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|OldWordFileFormatException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|extractor
operator|.
name|Word6Extractor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|model
operator|.
name|FieldsDocumentPart
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|model
operator|.
name|PicturesTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|model
operator|.
name|SavedByEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|model
operator|.
name|SavedByTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|model
operator|.
name|StyleDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|CharacterRun
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|HeaderStories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|Paragraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|Picture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|Range
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|TableCell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|usermodel
operator|.
name|TableRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|DirectoryEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|DirectoryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|NPOIFSFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|io
operator|.
name|TikaInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|TikaCoreProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|sax
operator|.
name|XHTMLContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|helpers
operator|.
name|AttributesImpl
import|;
end_import

begin_class
specifier|public
class|class
name|WordExtractor
extends|extends
name|AbstractPOIFSExtractor
block|{
specifier|private
specifier|static
specifier|final
name|char
name|UNICODECHAR_NONBREAKING_HYPHEN
init|=
literal|'\u2011'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|UNICODECHAR_ZERO_WIDTH_SPACE
init|=
literal|'\u200b'
decl_stmt|;
comment|// could be improved by using the real delimiter in xchFollow [MS-DOC], v20140721, 2.4.6.3, Part 3, Step 3
specifier|private
specifier|static
specifier|final
name|String
name|LIST_DELIMITER
init|=
literal|" "
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TagAndStyle
argument_list|>
name|fixedParagraphStyles
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TagAndStyle
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|TagAndStyle
name|defaultParagraphStyle
init|=
operator|new
name|TagAndStyle
argument_list|(
literal|"p"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
static|static
block|{
name|fixedParagraphStyles
operator|.
name|put
argument_list|(
literal|"Default"
argument_list|,
name|defaultParagraphStyle
argument_list|)
expr_stmt|;
name|fixedParagraphStyles
operator|.
name|put
argument_list|(
literal|"Normal"
argument_list|,
name|defaultParagraphStyle
argument_list|)
expr_stmt|;
name|fixedParagraphStyles
operator|.
name|put
argument_list|(
literal|"heading"
argument_list|,
operator|new
name|TagAndStyle
argument_list|(
literal|"h1"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|fixedParagraphStyles
operator|.
name|put
argument_list|(
literal|"Heading"
argument_list|,
operator|new
name|TagAndStyle
argument_list|(
literal|"h1"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|fixedParagraphStyles
operator|.
name|put
argument_list|(
literal|"Title"
argument_list|,
operator|new
name|TagAndStyle
argument_list|(
literal|"h1"
argument_list|,
literal|"title"
argument_list|)
argument_list|)
expr_stmt|;
name|fixedParagraphStyles
operator|.
name|put
argument_list|(
literal|"Subtitle"
argument_list|,
operator|new
name|TagAndStyle
argument_list|(
literal|"h2"
argument_list|,
literal|"subtitle"
argument_list|)
argument_list|)
expr_stmt|;
name|fixedParagraphStyles
operator|.
name|put
argument_list|(
literal|"HTML Preformatted"
argument_list|,
operator|new
name|TagAndStyle
argument_list|(
literal|"pre"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// True if we are currently in the named style tag:
specifier|private
name|boolean
name|curStrikeThrough
decl_stmt|;
specifier|private
name|boolean
name|curBold
decl_stmt|;
specifier|private
name|boolean
name|curItalic
decl_stmt|;
specifier|private
specifier|final
name|Metadata
name|metadata
decl_stmt|;
specifier|public
name|WordExtractor
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|countParagraphs
parameter_list|(
name|Range
modifier|...
name|ranges
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Range
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|count
operator|+=
name|r
operator|.
name|numParagraphs
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Given a style name, return what tag should be used, and      * what style should be applied to it.      */
specifier|public
specifier|static
name|TagAndStyle
name|buildParagraphTagAndStyle
parameter_list|(
name|String
name|styleName
parameter_list|,
name|boolean
name|isTable
parameter_list|)
block|{
name|TagAndStyle
name|tagAndStyle
init|=
name|fixedParagraphStyles
operator|.
name|get
argument_list|(
name|styleName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tagAndStyle
operator|!=
literal|null
condition|)
block|{
return|return
name|tagAndStyle
return|;
block|}
if|if
condition|(
name|styleName
operator|.
name|equals
argument_list|(
literal|"Table Contents"
argument_list|)
operator|&&
name|isTable
condition|)
block|{
return|return
name|defaultParagraphStyle
return|;
block|}
name|String
name|tag
init|=
literal|"p"
decl_stmt|;
name|String
name|styleClass
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|styleName
operator|.
name|startsWith
argument_list|(
literal|"heading"
argument_list|)
operator|||
name|styleName
operator|.
name|startsWith
argument_list|(
literal|"Heading"
argument_list|)
condition|)
block|{
comment|// "Heading 3" or "Heading2" or "heading 4"
name|int
name|num
init|=
literal|1
decl_stmt|;
try|try
block|{
name|num
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|styleName
operator|.
name|substring
argument_list|(
name|styleName
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{             }
comment|// Turn it into a H1 - H6 (H7+ isn't valid!)
name|tag
operator|=
literal|"h"
operator|+
name|Math
operator|.
name|min
argument_list|(
name|num
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|styleClass
operator|=
name|styleName
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|styleClass
operator|=
name|styleClass
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
operator|+
name|styleClass
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|TagAndStyle
argument_list|(
name|tag
argument_list|,
name|styleClass
argument_list|)
return|;
block|}
specifier|protected
name|void
name|parse
parameter_list|(
name|NPOIFSFileSystem
name|filesystem
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|parse
argument_list|(
name|filesystem
operator|.
name|getRoot
argument_list|()
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|parse
parameter_list|(
name|DirectoryNode
name|root
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|HWPFDocument
name|document
decl_stmt|;
try|try
block|{
name|document
operator|=
operator|new
name|HWPFDocument
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OldWordFileFormatException
name|e
parameter_list|)
block|{
name|parseWord6
argument_list|(
name|root
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
return|return;
block|}
name|extractSavedByMetadata
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|extractor
operator|.
name|WordExtractor
name|wordExtractor
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hwpf
operator|.
name|extractor
operator|.
name|WordExtractor
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|HeaderStories
name|headerFooter
init|=
operator|new
name|HeaderStories
argument_list|(
name|document
argument_list|)
decl_stmt|;
comment|// Grab the list of pictures. As far as we can tell,
comment|//  the pictures should be in order, and may be directly
comment|//  placed or referenced from an anchor
name|PicturesTable
name|pictureTable
init|=
name|document
operator|.
name|getPicturesTable
argument_list|()
decl_stmt|;
name|PicturesSource
name|pictures
init|=
operator|new
name|PicturesSource
argument_list|(
name|document
argument_list|)
decl_stmt|;
comment|// Do any headers, if present
name|Range
index|[]
name|headers
init|=
operator|new
name|Range
index|[]
block|{
name|headerFooter
operator|.
name|getFirstHeaderSubrange
argument_list|()
block|,
name|headerFooter
operator|.
name|getEvenHeaderSubrange
argument_list|()
block|,
name|headerFooter
operator|.
name|getOddHeaderSubrange
argument_list|()
block|}
decl_stmt|;
name|handleHeaderFooter
argument_list|(
name|headers
argument_list|,
literal|"header"
argument_list|,
name|document
argument_list|,
name|pictures
argument_list|,
name|pictureTable
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
comment|// Do the main paragraph text
name|Range
name|r
init|=
name|document
operator|.
name|getRange
argument_list|()
decl_stmt|;
name|ListManager
name|listManager
init|=
operator|new
name|ListManager
argument_list|(
name|document
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r
operator|.
name|numParagraphs
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Paragraph
name|p
init|=
name|r
operator|.
name|getParagraph
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|i
operator|+=
name|handleParagraph
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|r
argument_list|,
name|document
argument_list|,
name|FieldsDocumentPart
operator|.
name|MAIN
argument_list|,
name|pictures
argument_list|,
name|pictureTable
argument_list|,
name|listManager
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
comment|// Do everything else
for|for
control|(
name|String
name|paragraph
range|:
name|wordExtractor
operator|.
name|getMainTextboxText
argument_list|()
control|)
block|{
name|xhtml
operator|.
name|element
argument_list|(
literal|"p"
argument_list|,
name|paragraph
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|paragraph
range|:
name|wordExtractor
operator|.
name|getFootnoteText
argument_list|()
control|)
block|{
name|xhtml
operator|.
name|element
argument_list|(
literal|"p"
argument_list|,
name|paragraph
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|paragraph
range|:
name|wordExtractor
operator|.
name|getCommentsText
argument_list|()
control|)
block|{
name|xhtml
operator|.
name|element
argument_list|(
literal|"p"
argument_list|,
name|paragraph
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|paragraph
range|:
name|wordExtractor
operator|.
name|getEndnoteText
argument_list|()
control|)
block|{
name|xhtml
operator|.
name|element
argument_list|(
literal|"p"
argument_list|,
name|paragraph
argument_list|)
expr_stmt|;
block|}
comment|// Do any footers, if present
name|Range
index|[]
name|footers
init|=
operator|new
name|Range
index|[]
block|{
name|headerFooter
operator|.
name|getFirstFooterSubrange
argument_list|()
block|,
name|headerFooter
operator|.
name|getEvenFooterSubrange
argument_list|()
block|,
name|headerFooter
operator|.
name|getOddFooterSubrange
argument_list|()
block|}
decl_stmt|;
name|handleHeaderFooter
argument_list|(
name|footers
argument_list|,
literal|"footer"
argument_list|,
name|document
argument_list|,
name|pictures
argument_list|,
name|pictureTable
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
comment|// Handle any pictures that we haven't output yet
for|for
control|(
name|Picture
name|p
init|=
name|pictures
operator|.
name|nextUnclaimed
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
control|)
block|{
name|handlePictureCharacterRun
argument_list|(
literal|null
argument_list|,
name|p
argument_list|,
name|pictures
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
name|p
operator|=
name|pictures
operator|.
name|nextUnclaimed
argument_list|()
expr_stmt|;
block|}
comment|// Handle any embeded office documents
try|try
block|{
name|DirectoryEntry
name|op
init|=
operator|(
name|DirectoryEntry
operator|)
name|root
operator|.
name|getEntry
argument_list|(
literal|"ObjectPool"
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|op
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
operator|&&
name|entry
operator|instanceof
name|DirectoryEntry
condition|)
block|{
name|handleEmbeddedOfficeDoc
argument_list|(
operator|(
name|DirectoryEntry
operator|)
name|entry
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{         }
block|}
specifier|private
name|void
name|extractSavedByMetadata
parameter_list|(
name|HWPFDocument
name|document
parameter_list|)
block|{
name|SavedByTable
name|savedByTable
init|=
name|document
operator|.
name|getSavedByTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|savedByTable
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|SavedByEntry
name|sbe
range|:
name|savedByTable
operator|.
name|getEntries
argument_list|()
control|)
block|{
name|metadata
operator|.
name|add
argument_list|(
name|TikaCoreProperties
operator|.
name|ORIGINAL_RESOURCE_NAME
argument_list|,
name|sbe
operator|.
name|getSaveLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleHeaderFooter
parameter_list|(
name|Range
index|[]
name|ranges
parameter_list|,
name|String
name|type
parameter_list|,
name|HWPFDocument
name|document
parameter_list|,
name|PicturesSource
name|pictures
parameter_list|,
name|PicturesTable
name|pictureTable
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|SAXException
throws|,
name|IOException
throws|,
name|TikaException
block|{
if|if
condition|(
name|countParagraphs
argument_list|(
name|ranges
argument_list|)
operator|>
literal|0
condition|)
block|{
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"div"
argument_list|,
literal|"class"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ListManager
name|listManager
init|=
operator|new
name|ListManager
argument_list|(
name|document
argument_list|)
decl_stmt|;
for|for
control|(
name|Range
name|r
range|:
name|ranges
control|)
block|{
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r
operator|.
name|numParagraphs
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Paragraph
name|p
init|=
name|r
operator|.
name|getParagraph
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|i
operator|+=
name|handleParagraph
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|r
argument_list|,
name|document
argument_list|,
name|FieldsDocumentPart
operator|.
name|HEADER
argument_list|,
name|pictures
argument_list|,
name|pictureTable
argument_list|,
name|listManager
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"div"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|handleParagraph
parameter_list|(
name|Paragraph
name|p
parameter_list|,
name|int
name|parentTableLevel
parameter_list|,
name|Range
name|r
parameter_list|,
name|HWPFDocument
name|document
parameter_list|,
name|FieldsDocumentPart
name|docPart
parameter_list|,
name|PicturesSource
name|pictures
parameter_list|,
name|PicturesTable
name|pictureTable
parameter_list|,
name|ListManager
name|listManager
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|SAXException
throws|,
name|IOException
throws|,
name|TikaException
block|{
comment|// Note - a poi bug means we can't currently properly recurse
comment|//  into nested tables, so currently we don't
if|if
condition|(
name|p
operator|.
name|isInTable
argument_list|()
operator|&&
name|p
operator|.
name|getTableLevel
argument_list|()
operator|>
name|parentTableLevel
operator|&&
name|parentTableLevel
operator|==
literal|0
condition|)
block|{
name|Table
name|t
init|=
name|r
operator|.
name|getTable
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"table"
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"tbody"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|rn
init|=
literal|0
init|;
name|rn
operator|<
name|t
operator|.
name|numRows
argument_list|()
condition|;
name|rn
operator|++
control|)
block|{
name|TableRow
name|row
init|=
name|t
operator|.
name|getRow
argument_list|(
name|rn
argument_list|)
decl_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"tr"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|cn
init|=
literal|0
init|;
name|cn
operator|<
name|row
operator|.
name|numCells
argument_list|()
condition|;
name|cn
operator|++
control|)
block|{
name|TableCell
name|cell
init|=
name|row
operator|.
name|getCell
argument_list|(
name|cn
argument_list|)
decl_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"td"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|pn
init|=
literal|0
init|;
name|pn
operator|<
name|cell
operator|.
name|numParagraphs
argument_list|()
condition|;
name|pn
operator|++
control|)
block|{
name|Paragraph
name|cellP
init|=
name|cell
operator|.
name|getParagraph
argument_list|(
name|pn
argument_list|)
decl_stmt|;
name|handleParagraph
argument_list|(
name|cellP
argument_list|,
name|p
operator|.
name|getTableLevel
argument_list|()
argument_list|,
name|cell
argument_list|,
name|document
argument_list|,
name|docPart
argument_list|,
name|pictures
argument_list|,
name|pictureTable
argument_list|,
name|listManager
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"td"
argument_list|)
expr_stmt|;
block|}
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"tr"
argument_list|)
expr_stmt|;
block|}
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"tbody"
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"table"
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|.
name|numParagraphs
argument_list|()
operator|-
literal|1
operator|)
return|;
block|}
name|String
name|text
init|=
name|p
operator|.
name|text
argument_list|()
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|replaceAll
argument_list|(
literal|"[\\r\\n\\s]+"
argument_list|,
literal|""
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Skip empty paragraphs
return|return
literal|0
return|;
block|}
name|TagAndStyle
name|tas
decl_stmt|;
name|String
name|numbering
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|document
operator|.
name|getStyleSheet
argument_list|()
operator|.
name|numStyles
argument_list|()
operator|>
name|p
operator|.
name|getStyleIndex
argument_list|()
condition|)
block|{
name|StyleDescription
name|style
init|=
name|document
operator|.
name|getStyleSheet
argument_list|()
operator|.
name|getStyleDescription
argument_list|(
name|p
operator|.
name|getStyleIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|style
operator|!=
literal|null
operator|&&
name|style
operator|.
name|getName
argument_list|()
operator|!=
literal|null
operator|&&
name|style
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|isInList
argument_list|()
condition|)
block|{
name|numbering
operator|=
name|listManager
operator|.
name|getFormattedNumber
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|tas
operator|=
name|buildParagraphTagAndStyle
argument_list|(
name|style
operator|.
name|getName
argument_list|()
argument_list|,
operator|(
name|parentTableLevel
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tas
operator|=
operator|new
name|TagAndStyle
argument_list|(
literal|"p"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tas
operator|=
operator|new
name|TagAndStyle
argument_list|(
literal|"p"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tas
operator|.
name|getStyleClass
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|xhtml
operator|.
name|startElement
argument_list|(
name|tas
operator|.
name|getTag
argument_list|()
argument_list|,
literal|"class"
argument_list|,
name|tas
operator|.
name|getStyleClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xhtml
operator|.
name|startElement
argument_list|(
name|tas
operator|.
name|getTag
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numbering
operator|!=
literal|null
condition|)
block|{
name|xhtml
operator|.
name|characters
argument_list|(
name|numbering
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|p
operator|.
name|numCharacterRuns
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|CharacterRun
name|cr
init|=
name|p
operator|.
name|getCharacterRun
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// FIELD_BEGIN_MARK:
if|if
condition|(
name|cr
operator|.
name|text
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0x13
condition|)
block|{
name|Field
name|field
init|=
name|document
operator|.
name|getFields
argument_list|()
operator|.
name|getFieldByStartOffset
argument_list|(
name|docPart
argument_list|,
name|cr
operator|.
name|getStartOffset
argument_list|()
argument_list|)
decl_stmt|;
comment|// 58 is an embedded document
comment|// 56 is a document link
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|(
name|field
operator|.
name|getType
argument_list|()
operator|==
literal|58
operator|||
name|field
operator|.
name|getType
argument_list|()
operator|==
literal|56
operator|)
condition|)
block|{
comment|// Embedded Object: add a<div
comment|// class="embedded" id="_X"/> so consumer can see where
comment|// in the main text each embedded document
comment|// occurred:
name|String
name|id
init|=
literal|"_unknown_id"
decl_stmt|;
comment|//this can return null (TIKA-1956)
name|CharacterRun
name|mscr
init|=
name|field
operator|.
name|getMarkSeparatorCharacterRun
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|mscr
operator|!=
literal|null
condition|)
block|{
name|id
operator|=
literal|"_"
operator|+
name|mscr
operator|.
name|getPicOffset
argument_list|()
expr_stmt|;
block|}
name|AttributesImpl
name|attributes
init|=
operator|new
name|AttributesImpl
argument_list|()
decl_stmt|;
name|attributes
operator|.
name|addAttribute
argument_list|(
literal|""
argument_list|,
literal|"class"
argument_list|,
literal|"class"
argument_list|,
literal|"CDATA"
argument_list|,
literal|"embedded"
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|addAttribute
argument_list|(
literal|""
argument_list|,
literal|"id"
argument_list|,
literal|"id"
argument_list|,
literal|"CDATA"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"div"
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"div"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cr
operator|.
name|text
argument_list|()
operator|.
name|equals
argument_list|(
literal|"\u0013"
argument_list|)
condition|)
block|{
name|j
operator|+=
name|handleSpecialCharacterRuns
argument_list|(
name|p
argument_list|,
name|j
argument_list|,
name|tas
operator|.
name|isHeading
argument_list|()
argument_list|,
name|pictures
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cr
operator|.
name|text
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"\u0008"
argument_list|)
condition|)
block|{
comment|// Floating Picture(s)
for|for
control|(
name|int
name|pn
init|=
literal|0
init|;
name|pn
operator|<
name|cr
operator|.
name|text
argument_list|()
operator|.
name|length
argument_list|()
condition|;
name|pn
operator|++
control|)
block|{
comment|// Assume they're in the order from the unclaimed list...
name|Picture
name|picture
init|=
name|pictures
operator|.
name|nextUnclaimed
argument_list|()
decl_stmt|;
comment|// Output
name|handlePictureCharacterRun
argument_list|(
name|cr
argument_list|,
name|picture
argument_list|,
name|pictures
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pictureTable
operator|.
name|hasPicture
argument_list|(
name|cr
argument_list|)
condition|)
block|{
comment|// Inline Picture
name|Picture
name|picture
init|=
name|pictures
operator|.
name|getFor
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|handlePictureCharacterRun
argument_list|(
name|cr
argument_list|,
name|picture
argument_list|,
name|pictures
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handleCharacterRun
argument_list|(
name|cr
argument_list|,
name|tas
operator|.
name|isHeading
argument_list|()
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Close any still open style tags
if|if
condition|(
name|curStrikeThrough
condition|)
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|curStrikeThrough
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|curItalic
condition|)
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|curItalic
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|curBold
condition|)
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|curBold
operator|=
literal|false
expr_stmt|;
block|}
name|xhtml
operator|.
name|endElement
argument_list|(
name|tas
operator|.
name|getTag
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|private
name|void
name|handleCharacterRun
parameter_list|(
name|CharacterRun
name|cr
parameter_list|,
name|boolean
name|skipStyling
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|SAXException
block|{
comment|// Skip trailing newlines
if|if
condition|(
operator|!
name|isRendered
argument_list|(
name|cr
argument_list|)
operator|||
name|cr
operator|.
name|text
argument_list|()
operator|.
name|equals
argument_list|(
literal|"\r"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|skipStyling
condition|)
block|{
if|if
condition|(
name|cr
operator|.
name|isBold
argument_list|()
operator|!=
name|curBold
condition|)
block|{
comment|// Enforce nesting -- must close s and i tags
if|if
condition|(
name|curStrikeThrough
condition|)
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|curStrikeThrough
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|curItalic
condition|)
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|curItalic
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|cr
operator|.
name|isBold
argument_list|()
condition|)
block|{
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
name|curBold
operator|=
name|cr
operator|.
name|isBold
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cr
operator|.
name|isItalic
argument_list|()
operator|!=
name|curItalic
condition|)
block|{
comment|// Enforce nesting -- must close s tag
if|if
condition|(
name|curStrikeThrough
condition|)
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|curStrikeThrough
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|cr
operator|.
name|isItalic
argument_list|()
condition|)
block|{
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|curItalic
operator|=
name|cr
operator|.
name|isItalic
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cr
operator|.
name|isStrikeThrough
argument_list|()
operator|!=
name|curStrikeThrough
condition|)
block|{
if|if
condition|(
name|cr
operator|.
name|isStrikeThrough
argument_list|()
condition|)
block|{
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
block|}
name|curStrikeThrough
operator|=
name|cr
operator|.
name|isStrikeThrough
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Clean up the text
name|String
name|text
init|=
name|cr
operator|.
name|text
argument_list|()
decl_stmt|;
name|text
operator|=
name|text
operator|.
name|replace
argument_list|(
literal|'\r'
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|endsWith
argument_list|(
literal|"\u0007"
argument_list|)
condition|)
block|{
comment|// Strip the table cell end marker
name|text
operator|=
name|text
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|text
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Copied from POI's org/apache/poi/hwpf/converter/AbstractWordConverter.processCharacters:
comment|// Non-breaking hyphens are returned as char 30
name|text
operator|=
name|text
operator|.
name|replace
argument_list|(
operator|(
name|char
operator|)
literal|30
argument_list|,
name|UNICODECHAR_NONBREAKING_HYPHEN
argument_list|)
expr_stmt|;
comment|// Non-required hyphens to zero-width space
name|text
operator|=
name|text
operator|.
name|replace
argument_list|(
operator|(
name|char
operator|)
literal|31
argument_list|,
name|UNICODECHAR_ZERO_WIDTH_SPACE
argument_list|)
expr_stmt|;
comment|// Control characters as line break
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"[\u0000-\u001f]"
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|characters
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|/**      * Can be \13..text..\15 or \13..control..\14..text..\15 .      * Nesting is allowed      */
specifier|private
name|int
name|handleSpecialCharacterRuns
parameter_list|(
name|Paragraph
name|p
parameter_list|,
name|int
name|index
parameter_list|,
name|boolean
name|skipStyling
parameter_list|,
name|PicturesSource
name|pictures
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|SAXException
throws|,
name|TikaException
throws|,
name|IOException
block|{
name|List
argument_list|<
name|CharacterRun
argument_list|>
name|controls
init|=
operator|new
name|ArrayList
argument_list|<
name|CharacterRun
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CharacterRun
argument_list|>
name|texts
init|=
operator|new
name|ArrayList
argument_list|<
name|CharacterRun
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|has14
init|=
literal|false
decl_stmt|;
comment|// Split it into before and after the 14
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|index
operator|+
literal|1
init|;
name|i
operator|<
name|p
operator|.
name|numCharacterRuns
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CharacterRun
name|cr
init|=
name|p
operator|.
name|getCharacterRun
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cr
operator|.
name|text
argument_list|()
operator|.
name|equals
argument_list|(
literal|"\u0013"
argument_list|)
condition|)
block|{
comment|// Nested, oh joy...
name|int
name|increment
init|=
name|handleSpecialCharacterRuns
argument_list|(
name|p
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|skipStyling
argument_list|,
name|pictures
argument_list|,
name|xhtml
argument_list|)
decl_stmt|;
name|i
operator|+=
name|increment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cr
operator|.
name|text
argument_list|()
operator|.
name|equals
argument_list|(
literal|"\u0014"
argument_list|)
condition|)
block|{
name|has14
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cr
operator|.
name|text
argument_list|()
operator|.
name|equals
argument_list|(
literal|"\u0015"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|has14
condition|)
block|{
name|texts
operator|=
name|controls
expr_stmt|;
name|controls
operator|=
operator|new
name|ArrayList
argument_list|<
name|CharacterRun
argument_list|>
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
if|if
condition|(
name|has14
condition|)
block|{
name|texts
operator|.
name|add
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|controls
operator|.
name|add
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Do we need to do something special with this?
if|if
condition|(
name|controls
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|text
init|=
name|controls
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|text
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|controls
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|text
operator|+=
name|controls
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|text
operator|.
name|startsWith
argument_list|(
literal|"HYPERLINK"
argument_list|)
operator|||
name|text
operator|.
name|startsWith
argument_list|(
literal|" HYPERLINK"
argument_list|)
operator|)
operator|&&
name|text
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|)
operator|>
operator|-
literal|1
condition|)
block|{
name|int
name|start
init|=
name|text
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|end
init|=
name|findHyperlinkEnd
argument_list|(
name|text
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|String
name|url
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|start
operator|>=
literal|0
operator|&&
name|start
operator|<
name|end
operator|&&
name|end
operator|<=
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
name|url
operator|=
name|text
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"a"
argument_list|,
literal|"href"
argument_list|,
name|url
argument_list|)
expr_stmt|;
for|for
control|(
name|CharacterRun
name|cr
range|:
name|texts
control|)
block|{
name|handleCharacterRun
argument_list|(
name|cr
argument_list|,
name|skipStyling
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Just output the text ones
for|for
control|(
name|CharacterRun
name|cr
range|:
name|texts
control|)
block|{
if|if
condition|(
name|pictures
operator|.
name|hasPicture
argument_list|(
name|cr
argument_list|)
condition|)
block|{
name|Picture
name|picture
init|=
name|pictures
operator|.
name|getFor
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|handlePictureCharacterRun
argument_list|(
name|cr
argument_list|,
name|picture
argument_list|,
name|pictures
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handleCharacterRun
argument_list|(
name|cr
argument_list|,
name|skipStyling
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// We only had text
comment|// Output as-is
for|for
control|(
name|CharacterRun
name|cr
range|:
name|texts
control|)
block|{
name|handleCharacterRun
argument_list|(
name|cr
argument_list|,
name|skipStyling
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Tell them how many to skip over
return|return
name|i
operator|-
name|index
return|;
block|}
comment|//temporary work around for TIKA-1512
specifier|private
name|int
name|findHyperlinkEnd
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|int
name|end
init|=
name|text
operator|.
name|lastIndexOf
argument_list|(
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|>
name|start
condition|)
block|{
return|return
name|end
return|;
block|}
name|end
operator|=
name|text
operator|.
name|lastIndexOf
argument_list|(
literal|'\u201D'
argument_list|)
expr_stmt|;
comment|//smart right double quote
if|if
condition|(
name|end
operator|>
name|start
condition|)
block|{
return|return
name|end
return|;
block|}
name|end
operator|=
name|text
operator|.
name|lastIndexOf
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|start
condition|)
block|{
return|return
name|end
return|;
block|}
comment|//if nothing so far, take the full length of the string
comment|//If the full string is> 256 characters, it appears
comment|//that the url is truncated in the .doc file.  This
comment|//will return the value as it is in the file, which
comment|//may be incorrect; but it is the same behavior as opening
comment|//the link in MSWord.
comment|//This code does not currently check that length is actually>= 256.
comment|//we might want to add that?
return|return
name|text
operator|.
name|length
argument_list|()
return|;
block|}
specifier|private
name|void
name|handlePictureCharacterRun
parameter_list|(
name|CharacterRun
name|cr
parameter_list|,
name|Picture
name|picture
parameter_list|,
name|PicturesSource
name|pictures
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|SAXException
throws|,
name|IOException
throws|,
name|TikaException
block|{
if|if
condition|(
operator|!
name|isRendered
argument_list|(
name|cr
argument_list|)
operator|||
name|picture
operator|==
literal|null
condition|)
block|{
comment|// Oh dear, we've run out...
comment|// Probably caused by multiple \u0008 images referencing
comment|//  the same real image
return|return;
block|}
comment|// Which one is it?
name|String
name|extension
init|=
name|picture
operator|.
name|suggestFileExtension
argument_list|()
decl_stmt|;
name|int
name|pictureNumber
init|=
name|pictures
operator|.
name|pictureNumber
argument_list|(
name|picture
argument_list|)
decl_stmt|;
comment|// Make up a name for the picture
comment|// There isn't one in the file, but we need to be able to reference
comment|//  the picture from the img tag and the embedded resource
name|String
name|filename
init|=
literal|"image"
operator|+
name|pictureNumber
operator|+
operator|(
name|extension
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
literal|"."
operator|+
name|extension
else|:
literal|""
operator|)
decl_stmt|;
comment|// Grab the mime type for the picture
name|String
name|mimeType
init|=
name|picture
operator|.
name|getMimeType
argument_list|()
decl_stmt|;
comment|// Output the img tag
name|AttributesImpl
name|attr
init|=
operator|new
name|AttributesImpl
argument_list|()
decl_stmt|;
name|attr
operator|.
name|addAttribute
argument_list|(
literal|""
argument_list|,
literal|"src"
argument_list|,
literal|"src"
argument_list|,
literal|"CDATA"
argument_list|,
literal|"embedded:"
operator|+
name|filename
argument_list|)
expr_stmt|;
name|attr
operator|.
name|addAttribute
argument_list|(
literal|""
argument_list|,
literal|"alt"
argument_list|,
literal|"alt"
argument_list|,
literal|"CDATA"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"img"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"img"
argument_list|)
expr_stmt|;
comment|// Have we already output this one?
comment|// (Only expose each individual image once)
if|if
condition|(
operator|!
name|pictures
operator|.
name|hasOutput
argument_list|(
name|picture
argument_list|)
condition|)
block|{
name|TikaInputStream
name|stream
init|=
name|TikaInputStream
operator|.
name|get
argument_list|(
name|picture
operator|.
name|getContent
argument_list|()
argument_list|)
decl_stmt|;
name|handleEmbeddedResource
argument_list|(
name|stream
argument_list|,
name|filename
argument_list|,
literal|null
argument_list|,
name|mimeType
argument_list|,
name|xhtml
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pictures
operator|.
name|recordOutput
argument_list|(
name|picture
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Outputs a section of text if the given text is non-empty.      *      * @param xhtml   XHTML content handler      * @param section the class of the&lt;div/&gt; section emitted      * @param text    text to be emitted, if any      * @throws SAXException if an error occurs      */
specifier|private
name|void
name|addTextIfAny
parameter_list|(
name|XHTMLContentHandler
name|xhtml
parameter_list|,
name|String
name|section
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|SAXException
block|{
if|if
condition|(
name|text
operator|!=
literal|null
operator|&&
name|text
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"div"
argument_list|,
literal|"class"
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|element
argument_list|(
literal|"p"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"div"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|parseWord6
parameter_list|(
name|NPOIFSFileSystem
name|filesystem
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|parseWord6
argument_list|(
name|filesystem
operator|.
name|getRoot
argument_list|()
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|parseWord6
parameter_list|(
name|DirectoryNode
name|root
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|HWPFOldDocument
name|doc
init|=
operator|new
name|HWPFOldDocument
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|Word6Extractor
name|extractor
init|=
operator|new
name|Word6Extractor
argument_list|(
name|doc
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|p
range|:
name|extractor
operator|.
name|getParagraphText
argument_list|()
control|)
block|{
name|xhtml
operator|.
name|element
argument_list|(
literal|"p"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Determines if character run should be included in the extraction.      *      * @param cr character run.      * @return true if character run should be included in extraction.      */
specifier|private
name|boolean
name|isRendered
parameter_list|(
specifier|final
name|CharacterRun
name|cr
parameter_list|)
block|{
return|return
name|cr
operator|==
literal|null
operator|||
operator|!
name|cr
operator|.
name|isMarkedDeleted
argument_list|()
return|;
block|}
specifier|public
specifier|static
class|class
name|TagAndStyle
block|{
specifier|private
name|String
name|tag
decl_stmt|;
specifier|private
name|String
name|styleClass
decl_stmt|;
specifier|public
name|TagAndStyle
parameter_list|(
name|String
name|tag
parameter_list|,
name|String
name|styleClass
parameter_list|)
block|{
name|this
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|this
operator|.
name|styleClass
operator|=
name|styleClass
expr_stmt|;
block|}
specifier|public
name|String
name|getTag
parameter_list|()
block|{
return|return
name|tag
return|;
block|}
specifier|public
name|String
name|getStyleClass
parameter_list|()
block|{
return|return
name|styleClass
return|;
block|}
specifier|public
name|boolean
name|isHeading
parameter_list|()
block|{
return|return
name|tag
operator|.
name|length
argument_list|()
operator|==
literal|2
operator|&&
name|tag
operator|.
name|startsWith
argument_list|(
literal|"h"
argument_list|)
return|;
block|}
block|}
comment|/**      * Provides access to the pictures both by offset, iteration      * over the un-claimed, and peeking forward      */
specifier|private
specifier|static
class|class
name|PicturesSource
block|{
specifier|private
name|PicturesTable
name|picturesTable
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|Picture
argument_list|>
name|output
init|=
operator|new
name|HashSet
argument_list|<
name|Picture
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Picture
argument_list|>
name|lookup
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Picture
argument_list|>
name|nonU1based
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Picture
argument_list|>
name|all
decl_stmt|;
specifier|private
name|int
name|pn
init|=
literal|0
decl_stmt|;
specifier|private
name|PicturesSource
parameter_list|(
name|HWPFDocument
name|doc
parameter_list|)
block|{
name|picturesTable
operator|=
name|doc
operator|.
name|getPicturesTable
argument_list|()
expr_stmt|;
name|all
operator|=
name|picturesTable
operator|.
name|getAllPictures
argument_list|()
expr_stmt|;
comment|// Build the Offset-Picture lookup map
name|lookup
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Picture
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Picture
name|p
range|:
name|all
control|)
block|{
name|lookup
operator|.
name|put
argument_list|(
name|p
operator|.
name|getStartOffset
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|// Work out which Pictures aren't referenced by
comment|//  a \u0001 in the main text
comment|// These are \u0008 escher floating ones, ones
comment|//  found outside the normal text, and who
comment|//  knows what else...
name|nonU1based
operator|=
operator|new
name|ArrayList
argument_list|<
name|Picture
argument_list|>
argument_list|()
expr_stmt|;
name|nonU1based
operator|.
name|addAll
argument_list|(
name|all
argument_list|)
expr_stmt|;
name|Range
name|r
init|=
name|doc
operator|.
name|getRange
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|r
operator|.
name|numCharacterRuns
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CharacterRun
name|cr
init|=
name|r
operator|.
name|getCharacterRun
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|picturesTable
operator|.
name|hasPicture
argument_list|(
name|cr
argument_list|)
condition|)
block|{
name|Picture
name|p
init|=
name|getFor
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|int
name|at
init|=
name|nonU1based
operator|.
name|indexOf
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|nonU1based
operator|.
name|set
argument_list|(
name|at
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|hasPicture
parameter_list|(
name|CharacterRun
name|cr
parameter_list|)
block|{
return|return
name|picturesTable
operator|.
name|hasPicture
argument_list|(
name|cr
argument_list|)
return|;
block|}
specifier|private
name|void
name|recordOutput
parameter_list|(
name|Picture
name|picture
parameter_list|)
block|{
name|output
operator|.
name|add
argument_list|(
name|picture
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|hasOutput
parameter_list|(
name|Picture
name|picture
parameter_list|)
block|{
return|return
name|output
operator|.
name|contains
argument_list|(
name|picture
argument_list|)
return|;
block|}
specifier|private
name|int
name|pictureNumber
parameter_list|(
name|Picture
name|picture
parameter_list|)
block|{
return|return
name|all
operator|.
name|indexOf
argument_list|(
name|picture
argument_list|)
operator|+
literal|1
return|;
block|}
specifier|private
name|Picture
name|getFor
parameter_list|(
name|CharacterRun
name|cr
parameter_list|)
block|{
return|return
name|lookup
operator|.
name|get
argument_list|(
name|cr
operator|.
name|getPicOffset
argument_list|()
argument_list|)
return|;
block|}
comment|/**          * Return the next unclaimed one, used towards          * the end          */
specifier|private
name|Picture
name|nextUnclaimed
parameter_list|()
block|{
name|Picture
name|p
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|pn
operator|<
name|nonU1based
operator|.
name|size
argument_list|()
condition|)
block|{
name|p
operator|=
name|nonU1based
operator|.
name|get
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|pn
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
return|return
name|p
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
block|}
end_class

end_unit

