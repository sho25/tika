begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|rtf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PushbackInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CoderResult
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CodingErrorAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Office
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OfficeOpenXMLCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OfficeOpenXMLExtended
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|TikaCoreProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|sax
operator|.
name|XHTMLContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|utils
operator|.
name|CharsetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/* Tokenizes and performs a "shallow" parse of the RTF  * document, just enough to properly decode the text.  *  * TODO: we should cutover to a "real" tokenizer (eg JFlex);  * it should give better perf, by replacing the excessive  * "else if" string compares with FSA traversal. */
end_comment

begin_class
specifier|final
class|class
name|TextExtractor
block|{
specifier|private
specifier|static
specifier|final
name|Charset
name|ASCII
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"US-ASCII"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|Charset
name|getCharset
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
return|return
name|CharsetUtils
operator|.
name|forName
argument_list|(
name|name
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
name|ASCII
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_1252
init|=
name|getCharset
argument_list|(
literal|"WINDOWS-1252"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MAC_ROMAN
init|=
name|getCharset
argument_list|(
literal|"MacRoman"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|SHIFT_JIS
init|=
name|getCharset
argument_list|(
literal|"Shift_JIS"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57011
init|=
name|getCharset
argument_list|(
literal|"windows-57011"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57010
init|=
name|getCharset
argument_list|(
literal|"windows-57010"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57009
init|=
name|getCharset
argument_list|(
literal|"windows-57009"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57008
init|=
name|getCharset
argument_list|(
literal|"windows-57008"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57007
init|=
name|getCharset
argument_list|(
literal|"windows-57007"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57006
init|=
name|getCharset
argument_list|(
literal|"windows-57006"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57005
init|=
name|getCharset
argument_list|(
literal|"windows-57005"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57004
init|=
name|getCharset
argument_list|(
literal|"windows-57004"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_57003
init|=
name|getCharset
argument_list|(
literal|"windows-57003"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|X_ISCII91
init|=
name|getCharset
argument_list|(
literal|"x-ISCII91"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|X_MAC_CENTRAL_EUROPE
init|=
name|getCharset
argument_list|(
literal|"x-MacCentralEurope"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MAC_CYRILLIC
init|=
name|getCharset
argument_list|(
literal|"MacCyrillic"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|X_JOHAB
init|=
name|getCharset
argument_list|(
literal|"x-Johab"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12582
init|=
name|getCharset
argument_list|(
literal|"CP1258"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12572
init|=
name|getCharset
argument_list|(
literal|"CP1257"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12562
init|=
name|getCharset
argument_list|(
literal|"CP1256"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12552
init|=
name|getCharset
argument_list|(
literal|"CP1255"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12542
init|=
name|getCharset
argument_list|(
literal|"CP1254"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12532
init|=
name|getCharset
argument_list|(
literal|"CP1253"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1252
init|=
name|getCharset
argument_list|(
literal|"CP1252"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12512
init|=
name|getCharset
argument_list|(
literal|"CP1251"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP12502
init|=
name|getCharset
argument_list|(
literal|"CP1250"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP950
init|=
name|getCharset
argument_list|(
literal|"CP950"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP949
init|=
name|getCharset
argument_list|(
literal|"CP949"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS9362
init|=
name|getCharset
argument_list|(
literal|"MS936"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS8742
init|=
name|getCharset
argument_list|(
literal|"MS874"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP866
init|=
name|getCharset
argument_list|(
literal|"CP866"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP865
init|=
name|getCharset
argument_list|(
literal|"CP865"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP864
init|=
name|getCharset
argument_list|(
literal|"CP864"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP863
init|=
name|getCharset
argument_list|(
literal|"CP863"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP862
init|=
name|getCharset
argument_list|(
literal|"CP862"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP860
init|=
name|getCharset
argument_list|(
literal|"CP860"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP852
init|=
name|getCharset
argument_list|(
literal|"CP852"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP8502
init|=
name|getCharset
argument_list|(
literal|"CP850"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP819
init|=
name|getCharset
argument_list|(
literal|"CP819"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_720
init|=
name|getCharset
argument_list|(
literal|"windows-720"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_711
init|=
name|getCharset
argument_list|(
literal|"windows-711"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_710
init|=
name|getCharset
argument_list|(
literal|"windows-710"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|WINDOWS_709
init|=
name|getCharset
argument_list|(
literal|"windows-709"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|ISO_8859_6
init|=
name|getCharset
argument_list|(
literal|"ISO-8859-6"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP4372
init|=
name|getCharset
argument_list|(
literal|"CP437"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP850
init|=
name|getCharset
argument_list|(
literal|"cp850"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP437
init|=
name|getCharset
argument_list|(
literal|"cp437"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS874
init|=
name|getCharset
argument_list|(
literal|"ms874"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1257
init|=
name|getCharset
argument_list|(
literal|"cp1257"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1256
init|=
name|getCharset
argument_list|(
literal|"cp1256"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1255
init|=
name|getCharset
argument_list|(
literal|"cp1255"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1258
init|=
name|getCharset
argument_list|(
literal|"cp1258"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1254
init|=
name|getCharset
argument_list|(
literal|"cp1254"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1253
init|=
name|getCharset
argument_list|(
literal|"cp1253"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS950
init|=
name|getCharset
argument_list|(
literal|"ms950"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS936
init|=
name|getCharset
argument_list|(
literal|"ms936"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS1361
init|=
name|getCharset
argument_list|(
literal|"ms1361"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS932
init|=
name|getCharset
argument_list|(
literal|"MS932"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1251
init|=
name|getCharset
argument_list|(
literal|"cp1251"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|CP1250
init|=
name|getCharset
argument_list|(
literal|"cp1250"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MAC_THAI
init|=
name|getCharset
argument_list|(
literal|"MacThai"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MAC_TURKISH
init|=
name|getCharset
argument_list|(
literal|"MacTurkish"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MAC_GREEK
init|=
name|getCharset
argument_list|(
literal|"MacGreek"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MAC_ARABIC
init|=
name|getCharset
argument_list|(
literal|"MacArabic"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MAC_HEBREW
init|=
name|getCharset
argument_list|(
literal|"MacHebrew"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|JOHAB
init|=
name|getCharset
argument_list|(
literal|"johab"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|BIG5
init|=
name|getCharset
argument_list|(
literal|"Big5"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|GB2312
init|=
name|getCharset
argument_list|(
literal|"GB2312"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|MS949
init|=
name|getCharset
argument_list|(
literal|"ms949"
argument_list|)
decl_stmt|;
specifier|private
name|int
name|written
init|=
literal|0
decl_stmt|;
comment|// Hold pending bytes (encoded in the current charset)
comment|// for text output:
specifier|private
name|byte
index|[]
name|pendingBytes
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
specifier|private
name|int
name|pendingByteCount
decl_stmt|;
specifier|private
name|ByteBuffer
name|pendingByteBuffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|pendingBytes
argument_list|)
decl_stmt|;
comment|// Holds pending chars for text output
specifier|private
name|char
index|[]
name|pendingChars
init|=
operator|new
name|char
index|[
literal|10
index|]
decl_stmt|;
specifier|private
name|int
name|pendingCharCount
decl_stmt|;
comment|// Holds chars for a still-being-tokenized control word
specifier|private
name|byte
index|[]
name|pendingControl
init|=
operator|new
name|byte
index|[
literal|10
index|]
decl_stmt|;
specifier|private
name|int
name|pendingControlCount
decl_stmt|;
comment|// Used when we decode bytes -> chars using CharsetDecoder:
specifier|private
specifier|final
name|char
index|[]
name|outputArray
init|=
operator|new
name|char
index|[
literal|128
index|]
decl_stmt|;
specifier|private
specifier|final
name|CharBuffer
name|outputBuffer
init|=
name|CharBuffer
operator|.
name|wrap
argument_list|(
name|outputArray
argument_list|)
decl_stmt|;
comment|// Reused when possible:
specifier|private
name|CharsetDecoder
name|decoder
decl_stmt|;
specifier|private
name|Charset
name|lastCharset
decl_stmt|;
specifier|private
name|Charset
name|globalCharset
init|=
name|WINDOWS_1252
decl_stmt|;
specifier|private
name|int
name|globalDefaultFont
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|curFontID
init|=
operator|-
literal|1
decl_stmt|;
comment|// Holds the font table from this RTF doc, mapping
comment|// the font number (from \fN control word) to the
comment|// corresponding charset:
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Charset
argument_list|>
name|fontToCharset
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Charset
argument_list|>
argument_list|()
decl_stmt|;
comment|// Group stack: when we open a new group, we push
comment|// the previous group state onto the stack; when we
comment|// close the group, we restore it
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|GroupState
argument_list|>
name|groupStates
init|=
operator|new
name|LinkedList
argument_list|<
name|GroupState
argument_list|>
argument_list|()
decl_stmt|;
comment|// Current group state; in theory this initial
comment|// GroupState is unused because the RTF doc should
comment|// immediately open the top group (start with {):
specifier|private
name|GroupState
name|groupState
init|=
operator|new
name|GroupState
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|inHeader
init|=
literal|true
decl_stmt|;
specifier|private
name|int
name|fontTableState
decl_stmt|;
specifier|private
name|int
name|fontTableDepth
decl_stmt|;
comment|// Non null if we are processing metadata (title,
comment|// keywords, etc.) inside the info group:
specifier|private
name|Property
name|nextMetaData
decl_stmt|;
specifier|private
name|boolean
name|inParagraph
decl_stmt|;
comment|// Non-zero if we are processing inside a field destination:
specifier|private
name|int
name|fieldState
decl_stmt|;
comment|// Non-zero list index
specifier|private
name|int
name|pendingListEnd
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ListDescriptor
argument_list|>
name|listTable
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ListDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ListDescriptor
argument_list|>
name|listOverrideTable
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ListDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ListDescriptor
argument_list|>
name|currentListTable
decl_stmt|;
specifier|private
name|ListDescriptor
name|currentList
decl_stmt|;
specifier|private
name|int
name|listTableLevel
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|ignoreLists
decl_stmt|;
comment|// Non-null if we've seen the url for a HYPERLINK but not yet
comment|// its text:
specifier|private
name|String
name|pendingURL
decl_stmt|;
specifier|private
specifier|final
name|StringBuilder
name|pendingBuffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Used to process the sub-groups inside the upr
comment|// group:
specifier|private
name|int
name|uprState
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|XHTMLContentHandler
name|out
decl_stmt|;
specifier|private
specifier|final
name|Metadata
name|metadata
decl_stmt|;
specifier|private
specifier|final
name|RTFEmbObjHandler
name|embObjHandler
decl_stmt|;
comment|// Used when extracting CREATION date:
specifier|private
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|;
comment|// How many next ansi chars we should skip; this
comment|// is 0 except when we are still in the "ansi
comment|// shadow" after seeing a unicode escape, at which
comment|// point it's set to the last ucN skip we had seen:
name|int
name|ansiSkip
init|=
literal|0
decl_stmt|;
comment|// The RTF doc has a "font table" that assigns ords
comment|// (f0, f1, f2, etc.) to fonts and charsets, using the
comment|// \fcharsetN control word.  This mapping maps from the
comment|// N to corresponding Java charset:
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Charset
argument_list|>
name|FCHARSET_MAP
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Charset
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|0
argument_list|,
name|WINDOWS_1252
argument_list|)
expr_stmt|;
comment|// ANSI
comment|// charset 1 is Default
comment|// charset 2 is Symbol
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|77
argument_list|,
name|MAC_ROMAN
argument_list|)
expr_stmt|;
comment|// Mac Roman
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|78
argument_list|,
name|SHIFT_JIS
argument_list|)
expr_stmt|;
comment|// Mac Shift Jis
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|79
argument_list|,
name|MS949
argument_list|)
expr_stmt|;
comment|// Mac Hangul
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|80
argument_list|,
name|GB2312
argument_list|)
expr_stmt|;
comment|// Mac GB2312
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|81
argument_list|,
name|BIG5
argument_list|)
expr_stmt|;
comment|// Mac Big5
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|82
argument_list|,
name|JOHAB
argument_list|)
expr_stmt|;
comment|// Mac Johab (old)
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|83
argument_list|,
name|MAC_HEBREW
argument_list|)
expr_stmt|;
comment|// Mac Hebrew
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|84
argument_list|,
name|MAC_ARABIC
argument_list|)
expr_stmt|;
comment|// Mac Arabic
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|85
argument_list|,
name|MAC_GREEK
argument_list|)
expr_stmt|;
comment|// Mac Greek
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|86
argument_list|,
name|MAC_TURKISH
argument_list|)
expr_stmt|;
comment|// Mac Turkish
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|87
argument_list|,
name|MAC_THAI
argument_list|)
expr_stmt|;
comment|// Mac Thai
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|88
argument_list|,
name|CP1250
argument_list|)
expr_stmt|;
comment|// Mac East Europe
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|89
argument_list|,
name|CP1251
argument_list|)
expr_stmt|;
comment|// Mac Russian
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|128
argument_list|,
name|MS932
argument_list|)
expr_stmt|;
comment|// Shift JIS
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|129
argument_list|,
name|MS949
argument_list|)
expr_stmt|;
comment|// Hangul
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|130
argument_list|,
name|MS1361
argument_list|)
expr_stmt|;
comment|// Johab
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|134
argument_list|,
name|MS936
argument_list|)
expr_stmt|;
comment|// GB2312
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|136
argument_list|,
name|MS950
argument_list|)
expr_stmt|;
comment|// Big5
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|161
argument_list|,
name|CP1253
argument_list|)
expr_stmt|;
comment|// Greek
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|162
argument_list|,
name|CP1254
argument_list|)
expr_stmt|;
comment|// Turkish
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|163
argument_list|,
name|CP1258
argument_list|)
expr_stmt|;
comment|// Vietnamese
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|177
argument_list|,
name|CP1255
argument_list|)
expr_stmt|;
comment|// Hebrew
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|178
argument_list|,
name|CP1256
argument_list|)
expr_stmt|;
comment|// Arabic
comment|// FCHARSET_MAP.put( 179, "" ); // Arabic Traditional
comment|// FCHARSET_MAP.put( 180, "" ); // Arabic user
comment|// FCHARSET_MAP.put( 181, "" ); // Hebrew user
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|186
argument_list|,
name|CP1257
argument_list|)
expr_stmt|;
comment|// Baltic
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|204
argument_list|,
name|CP1251
argument_list|)
expr_stmt|;
comment|// Russian
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|222
argument_list|,
name|MS874
argument_list|)
expr_stmt|;
comment|// Thai
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|238
argument_list|,
name|CP1250
argument_list|)
expr_stmt|;
comment|// Eastern European
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|254
argument_list|,
name|CP437
argument_list|)
expr_stmt|;
comment|// PC 437
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|255
argument_list|,
name|CP850
argument_list|)
expr_stmt|;
comment|// OEM
block|}
comment|// The RTF may specify the \ansicpgN charset in the
comment|// header; this maps the N to the corresponding Java
comment|// character set:
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Charset
argument_list|>
name|ANSICPG_MAP
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Charset
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|437
argument_list|,
name|CP4372
argument_list|)
expr_stmt|;
comment|// US IBM
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|708
argument_list|,
name|ISO_8859_6
argument_list|)
expr_stmt|;
comment|// Arabic (ASMO 708)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|709
argument_list|,
name|WINDOWS_709
argument_list|)
expr_stmt|;
comment|// Arabic (ASMO 449+, BCON V4)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|710
argument_list|,
name|WINDOWS_710
argument_list|)
expr_stmt|;
comment|// Arabic (transparent Arabic)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|710
argument_list|,
name|WINDOWS_711
argument_list|)
expr_stmt|;
comment|// Arabic (Nafitha Enhanced)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|710
argument_list|,
name|WINDOWS_720
argument_list|)
expr_stmt|;
comment|// Arabic (transparent ASMO)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|819
argument_list|,
name|CP819
argument_list|)
expr_stmt|;
comment|// Windows 3.1 (US& Western Europe)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|819
argument_list|,
name|CP819
argument_list|)
expr_stmt|;
comment|// Windows 3.1 (US& Western Europe)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|819
argument_list|,
name|CP819
argument_list|)
expr_stmt|;
comment|// Windows 3.1 (US& Western Europe)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|850
argument_list|,
name|CP8502
argument_list|)
expr_stmt|;
comment|// IBM Multilingual
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|852
argument_list|,
name|CP852
argument_list|)
expr_stmt|;
comment|// Eastern European
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|860
argument_list|,
name|CP860
argument_list|)
expr_stmt|;
comment|// Portuguese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|862
argument_list|,
name|CP862
argument_list|)
expr_stmt|;
comment|// Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|863
argument_list|,
name|CP863
argument_list|)
expr_stmt|;
comment|// French Canadian
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|864
argument_list|,
name|CP864
argument_list|)
expr_stmt|;
comment|// Arabic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|865
argument_list|,
name|CP865
argument_list|)
expr_stmt|;
comment|// Norwegian
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|866
argument_list|,
name|CP866
argument_list|)
expr_stmt|;
comment|// Soviet Union
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|874
argument_list|,
name|MS8742
argument_list|)
expr_stmt|;
comment|// Thai
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|932
argument_list|,
name|MS932
argument_list|)
expr_stmt|;
comment|// Japanese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|936
argument_list|,
name|MS9362
argument_list|)
expr_stmt|;
comment|// Simplified Chinese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|949
argument_list|,
name|CP949
argument_list|)
expr_stmt|;
comment|// Korean
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|950
argument_list|,
name|CP950
argument_list|)
expr_stmt|;
comment|// Traditional Chinese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1250
argument_list|,
name|CP12502
argument_list|)
expr_stmt|;
comment|// Eastern European
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1251
argument_list|,
name|CP12512
argument_list|)
expr_stmt|;
comment|// Cyrillic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1252
argument_list|,
name|CP1252
argument_list|)
expr_stmt|;
comment|// Western European
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1253
argument_list|,
name|CP12532
argument_list|)
expr_stmt|;
comment|// Greek
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1254
argument_list|,
name|CP12542
argument_list|)
expr_stmt|;
comment|// Turkish
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1255
argument_list|,
name|CP12552
argument_list|)
expr_stmt|;
comment|// Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1256
argument_list|,
name|CP12562
argument_list|)
expr_stmt|;
comment|// Arabic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1257
argument_list|,
name|CP12572
argument_list|)
expr_stmt|;
comment|// Baltic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1258
argument_list|,
name|CP12582
argument_list|)
expr_stmt|;
comment|// Vietnamese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1361
argument_list|,
name|X_JOHAB
argument_list|)
expr_stmt|;
comment|// Johab
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10000
argument_list|,
name|MAC_ROMAN
argument_list|)
expr_stmt|;
comment|// Mac Roman
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10001
argument_list|,
name|SHIFT_JIS
argument_list|)
expr_stmt|;
comment|// Mac Japan
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10004
argument_list|,
name|MAC_ARABIC
argument_list|)
expr_stmt|;
comment|// Mac Arabic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10005
argument_list|,
name|MAC_HEBREW
argument_list|)
expr_stmt|;
comment|// Mac Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10006
argument_list|,
name|MAC_GREEK
argument_list|)
expr_stmt|;
comment|// Mac Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10007
argument_list|,
name|MAC_CYRILLIC
argument_list|)
expr_stmt|;
comment|// Mac Cyrillic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10029
argument_list|,
name|X_MAC_CENTRAL_EUROPE
argument_list|)
expr_stmt|;
comment|// MAC Latin2
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10081
argument_list|,
name|MAC_TURKISH
argument_list|)
expr_stmt|;
comment|// Mac Turkish
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57002
argument_list|,
name|X_ISCII91
argument_list|)
expr_stmt|;
comment|// Devanagari
comment|// TODO: in theory these other charsets are simple
comment|// shifts off of Devanagari, so we could impl that
comment|// here:
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57003
argument_list|,
name|WINDOWS_57003
argument_list|)
expr_stmt|;
comment|// Bengali
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57004
argument_list|,
name|WINDOWS_57004
argument_list|)
expr_stmt|;
comment|// Tamil
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57005
argument_list|,
name|WINDOWS_57005
argument_list|)
expr_stmt|;
comment|// Telugu
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57006
argument_list|,
name|WINDOWS_57006
argument_list|)
expr_stmt|;
comment|// Assamese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57007
argument_list|,
name|WINDOWS_57007
argument_list|)
expr_stmt|;
comment|// Oriya
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57008
argument_list|,
name|WINDOWS_57008
argument_list|)
expr_stmt|;
comment|// Kannada
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57009
argument_list|,
name|WINDOWS_57009
argument_list|)
expr_stmt|;
comment|// Malayalam
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57010
argument_list|,
name|WINDOWS_57010
argument_list|)
expr_stmt|;
comment|// Gujariti
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57011
argument_list|,
name|WINDOWS_57011
argument_list|)
expr_stmt|;
comment|// Punjabi
block|}
specifier|public
name|TextExtractor
parameter_list|(
name|XHTMLContentHandler
name|out
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
name|RTFEmbObjHandler
name|embObjHandler
parameter_list|)
block|{
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|embObjHandler
operator|=
name|embObjHandler
expr_stmt|;
block|}
specifier|public
name|boolean
name|isIgnoringLists
parameter_list|()
block|{
return|return
name|ignoreLists
return|;
block|}
specifier|public
name|void
name|setIgnoreLists
parameter_list|(
name|boolean
name|ignore
parameter_list|)
block|{
name|this
operator|.
name|ignoreLists
operator|=
name|ignore
expr_stmt|;
block|}
specifier|protected
specifier|static
name|boolean
name|isHexChar
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isAlpha
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isDigit
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
return|;
block|}
specifier|protected
specifier|static
name|int
name|hexValue
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
return|return
name|ch
operator|-
literal|'0'
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
condition|)
block|{
return|return
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'a'
operator|)
return|;
block|}
else|else
block|{
assert|assert
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
assert|;
return|return
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'A'
operator|)
return|;
block|}
block|}
comment|// Push pending bytes or pending chars:
specifier|private
name|void
name|pushText
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingByteCount
operator|!=
literal|0
condition|)
block|{
assert|assert
name|pendingCharCount
operator|==
literal|0
assert|;
name|pushBytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pushChars
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Buffers the byte (unit in the current charset) for
comment|// output:
specifier|private
name|void
name|addOutputByte
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
assert|assert
name|b
operator|>=
literal|0
operator|&&
name|b
operator|<
literal|256
operator|:
literal|"byte value out of range: "
operator|+
name|b
assert|;
if|if
condition|(
name|pendingCharCount
operator|!=
literal|0
condition|)
block|{
name|pushChars
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|pictDepth
operator|>
literal|0
condition|)
block|{
name|embObjHandler
operator|.
name|writeMetadataChar
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Save the byte in pending buffer:
if|if
condition|(
name|pendingByteCount
operator|==
name|pendingBytes
operator|.
name|length
condition|)
block|{
comment|// Gradual but exponential growth:
specifier|final
name|byte
index|[]
name|newArray
init|=
operator|new
name|byte
index|[
call|(
name|int
call|)
argument_list|(
name|pendingBytes
operator|.
name|length
operator|*
literal|1.25
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|pendingBytes
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|pendingBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|pendingBytes
operator|=
name|newArray
expr_stmt|;
name|pendingByteBuffer
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|pendingBytes
argument_list|)
expr_stmt|;
block|}
name|pendingBytes
index|[
name|pendingByteCount
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
block|}
comment|// Buffers a byte as part of a control word:
specifier|private
name|void
name|addControl
parameter_list|(
name|int
name|b
parameter_list|)
block|{
assert|assert
name|isAlpha
argument_list|(
name|b
argument_list|)
assert|;
comment|// Save the byte in pending buffer:
if|if
condition|(
name|pendingControlCount
operator|==
name|pendingControl
operator|.
name|length
condition|)
block|{
comment|// Gradual but exponential growth:
specifier|final
name|byte
index|[]
name|newArray
init|=
operator|new
name|byte
index|[
call|(
name|int
call|)
argument_list|(
name|pendingControl
operator|.
name|length
operator|*
literal|1.25
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|pendingControl
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|pendingControl
operator|.
name|length
argument_list|)
expr_stmt|;
name|pendingControl
operator|=
name|newArray
expr_stmt|;
block|}
name|pendingControl
index|[
name|pendingControlCount
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
comment|// Buffers a UTF16 code unit for output
specifier|private
name|void
name|addOutputChar
parameter_list|(
name|char
name|ch
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingByteCount
operator|!=
literal|0
condition|)
block|{
name|pushBytes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inHeader
operator|||
name|fieldState
operator|==
literal|1
condition|)
block|{
name|pendingBuffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|groupState
operator|.
name|sn
operator|==
literal|true
operator|||
name|groupState
operator|.
name|sv
operator|==
literal|true
condition|)
block|{
name|embObjHandler
operator|.
name|writeMetadataChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pendingCharCount
operator|==
name|pendingChars
operator|.
name|length
condition|)
block|{
comment|// Gradual but exponential growth:
specifier|final
name|char
index|[]
name|newArray
init|=
operator|new
name|char
index|[
call|(
name|int
call|)
argument_list|(
name|pendingChars
operator|.
name|length
operator|*
literal|1.25
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|pendingChars
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|pendingChars
operator|.
name|length
argument_list|)
expr_stmt|;
name|pendingChars
operator|=
name|newArray
expr_stmt|;
block|}
name|pendingChars
index|[
name|pendingCharCount
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
block|}
comment|// Shallow parses the entire doc, writing output to
comment|// this.out and this.metadata
specifier|public
name|void
name|extract
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
comment|//        in = new FilterInputStream(in) {
comment|//            public int read() throws IOException {
comment|//                int r = super.read();
comment|//                System.out.write(r);
comment|//                System.out.flush();
comment|//                return r;
comment|//            }
comment|//            public int read(byte b[], int off, int len) throws IOException {
comment|//                int r = super.read(b, off, len);
comment|//                System.out.write(b, off, r);
comment|//                System.out.flush();
comment|//                return r;
comment|//            }
comment|//        };
name|extract
argument_list|(
operator|new
name|PushbackInputStream
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|extract
parameter_list|(
name|PushbackInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|out
operator|.
name|startDocument
argument_list|()
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|'\\'
condition|)
block|{
name|parseControlToken
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|'{'
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|processGroupStart
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|'}'
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|processGroupEnd
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupStates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// parsed document closing brace
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|groupState
operator|.
name|objdata
operator|==
literal|true
operator|||
name|groupState
operator|.
name|pictDepth
operator|==
literal|1
condition|)
block|{
name|embObjHandler
operator|.
name|writeHexChar
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|!=
literal|'\r'
operator|&&
name|b
operator|!=
literal|'\n'
operator|&&
operator|(
operator|!
name|groupState
operator|.
name|ignore
operator|||
name|nextMetaData
operator|!=
literal|null
operator|||
name|groupState
operator|.
name|sn
operator|==
literal|true
operator|||
name|groupState
operator|.
name|sv
operator|==
literal|true
operator|)
condition|)
block|{
comment|// Linefeed and carriage return are not
comment|// significant
if|if
condition|(
name|ansiSkip
operator|!=
literal|0
condition|)
block|{
name|ansiSkip
operator|--
expr_stmt|;
block|}
else|else
block|{
name|addOutputByte
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|endParagraph
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|out
operator|.
name|endDocument
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|parseControlToken
parameter_list|(
name|PushbackInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|'\''
condition|)
block|{
comment|// escaped hex char
name|parseHexChar
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isAlpha
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|// control word
name|parseControlWord
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|'{'
operator|||
name|b
operator|==
literal|'}'
operator|||
name|b
operator|==
literal|'\\'
operator|||
name|b
operator|==
literal|'\r'
operator|||
name|b
operator|==
literal|'\n'
condition|)
block|{
comment|// escaped char
name|addOutputByte
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// control symbol, eg \* or \~
name|processControlSymbol
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|parseHexChar
parameter_list|(
name|PushbackInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|int
name|hex1
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isHexChar
argument_list|(
name|hex1
argument_list|)
condition|)
block|{
comment|// DOC ERROR (malformed hex escape): ignore
name|in
operator|.
name|unread
argument_list|(
name|hex1
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|hex2
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isHexChar
argument_list|(
name|hex2
argument_list|)
condition|)
block|{
comment|// TODO: log a warning here, somehow?
comment|// DOC ERROR (malformed hex escape):
comment|// ignore
name|in
operator|.
name|unread
argument_list|(
name|hex2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ansiSkip
operator|!=
literal|0
condition|)
block|{
comment|// Skip this ansi char since we are
comment|// still in the shadow of a unicode
comment|// escape:
name|ansiSkip
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|// Unescape:
name|addOutputByte
argument_list|(
literal|16
operator|*
name|hexValue
argument_list|(
name|hex1
argument_list|)
operator|+
name|hexValue
argument_list|(
name|hex2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|parseControlWord
parameter_list|(
name|int
name|firstChar
parameter_list|,
name|PushbackInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|addControl
argument_list|(
name|firstChar
argument_list|)
expr_stmt|;
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|isAlpha
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|addControl
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|in
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|boolean
name|hasParam
init|=
literal|false
decl_stmt|;
name|boolean
name|negParam
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|'-'
condition|)
block|{
name|negParam
operator|=
literal|true
expr_stmt|;
name|hasParam
operator|=
literal|true
expr_stmt|;
name|b
operator|=
name|in
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|int
name|param
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isDigit
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|param
operator|*=
literal|10
expr_stmt|;
name|param
operator|+=
operator|(
name|b
operator|-
literal|'0'
operator|)
expr_stmt|;
name|hasParam
operator|=
literal|true
expr_stmt|;
name|b
operator|=
name|in
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
comment|// space is consumed as part of the
comment|// control word, but is not added to the
comment|// control word
if|if
condition|(
name|b
operator|!=
literal|' '
condition|)
block|{
name|in
operator|.
name|unread
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasParam
condition|)
block|{
if|if
condition|(
name|negParam
condition|)
block|{
name|param
operator|=
operator|-
name|param
expr_stmt|;
block|}
name|processControlWord
argument_list|(
name|param
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processControlWord
argument_list|()
expr_stmt|;
block|}
name|pendingControlCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|lazyStartParagraph
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
operator|!
name|inParagraph
condition|)
block|{
comment|// Ensure</i></b> order
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pendingListEnd
operator|!=
literal|0
operator|&&
name|groupState
operator|.
name|list
operator|!=
name|pendingListEnd
condition|)
block|{
name|endList
argument_list|(
name|pendingListEnd
argument_list|)
expr_stmt|;
name|pendingListEnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|inList
argument_list|()
operator|&&
name|pendingListEnd
operator|!=
name|groupState
operator|.
name|list
condition|)
block|{
name|startList
argument_list|(
name|groupState
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inList
argument_list|()
condition|)
block|{
name|out
operator|.
name|startElement
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|startElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
block|}
comment|// Ensure<b><i> order
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|inParagraph
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|endParagraph
parameter_list|(
name|boolean
name|preserveStyles
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|pushText
argument_list|()
expr_stmt|;
if|if
condition|(
name|inParagraph
condition|)
block|{
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
name|preserveStyles
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|bold
operator|=
name|preserveStyles
expr_stmt|;
block|}
if|if
condition|(
name|inList
argument_list|()
condition|)
block|{
name|out
operator|.
name|endElement
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|endElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preserveStyles
operator|&&
operator|(
name|groupState
operator|.
name|bold
operator|||
name|groupState
operator|.
name|italic
operator|)
condition|)
block|{
name|start
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|inParagraph
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|inParagraph
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Ensure closing the list at document end
if|if
condition|(
operator|!
name|preserveStyles
operator|&&
name|pendingListEnd
operator|!=
literal|0
condition|)
block|{
name|endList
argument_list|(
name|pendingListEnd
argument_list|)
expr_stmt|;
name|pendingListEnd
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Push pending UTF16 units to out ContentHandler
specifier|private
name|void
name|pushChars
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingCharCount
operator|!=
literal|0
condition|)
block|{
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|characters
argument_list|(
name|pendingChars
argument_list|,
literal|0
argument_list|,
name|pendingCharCount
argument_list|)
expr_stmt|;
name|pendingCharCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Decodes the buffered bytes in pendingBytes
comment|// into UTF16 code units, and sends the characters
comment|// to the out ContentHandler, if we are in the body,
comment|// else appends the characters to the pendingBuffer
specifier|private
name|void
name|pushBytes
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingByteCount
operator|>
literal|0
operator|&&
operator|(
operator|!
name|groupState
operator|.
name|ignore
operator|||
name|nextMetaData
operator|!=
literal|null
operator|)
condition|)
block|{
specifier|final
name|CharsetDecoder
name|decoder
init|=
name|getDecoder
argument_list|()
decl_stmt|;
name|pendingByteBuffer
operator|.
name|limit
argument_list|(
name|pendingByteCount
argument_list|)
expr_stmt|;
assert|assert
name|pendingByteBuffer
operator|.
name|position
argument_list|()
operator|==
literal|0
assert|;
assert|assert
name|outputBuffer
operator|.
name|position
argument_list|()
operator|==
literal|0
assert|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// We pass true for endOfInput because, when
comment|// we are called, we should have seen a
comment|// complete sequence of characters for this
comment|// charset:
specifier|final
name|CoderResult
name|result
init|=
name|decoder
operator|.
name|decode
argument_list|(
name|pendingByteBuffer
argument_list|,
name|outputBuffer
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|outputBuffer
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|inHeader
operator|||
name|fieldState
operator|==
literal|1
condition|)
block|{
name|pendingBuffer
operator|.
name|append
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|characters
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|outputBuffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|CoderResult
operator|.
name|UNDERFLOW
condition|)
block|{
break|break;
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|CoderResult
name|result
init|=
name|decoder
operator|.
name|flush
argument_list|(
name|outputBuffer
argument_list|)
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|outputBuffer
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|inHeader
operator|||
name|fieldState
operator|==
literal|1
condition|)
block|{
name|pendingBuffer
operator|.
name|append
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|characters
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|outputBuffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|CoderResult
operator|.
name|UNDERFLOW
condition|)
block|{
break|break;
block|}
block|}
comment|// Reset for next decode
name|decoder
operator|.
name|reset
argument_list|()
expr_stmt|;
name|pendingByteBuffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|pendingByteCount
operator|=
literal|0
expr_stmt|;
block|}
comment|// NOTE: s must be ascii alpha only
specifier|private
name|boolean
name|equals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|pendingControlCount
operator|!=
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|pendingControlCount
condition|;
name|idx
operator|++
control|)
block|{
assert|assert
name|isAlpha
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
argument_list|)
assert|;
if|if
condition|(
operator|(
operator|(
name|byte
operator|)
name|s
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|!=
name|pendingControl
index|[
name|idx
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|processControlSymbol
parameter_list|(
name|char
name|ch
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'~'
case|:
comment|// Non-breaking space -> unicode NON-BREAKING SPACE
name|addOutputChar
argument_list|(
literal|'\u00a0'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|// Ignorable destination (control words defined after
comment|// the 1987 RTF spec). These are already handled by
comment|// processGroupStart()
break|break;
case|case
literal|'-'
case|:
comment|// Optional hyphen -> unicode SOFT HYPHEN
name|addOutputChar
argument_list|(
literal|'\u00ad'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|// Non-breaking hyphen -> unicode NON-BREAKING HYPHEN
name|addOutputChar
argument_list|(
literal|'\u2011'
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
specifier|private
name|CharsetDecoder
name|getDecoder
parameter_list|()
throws|throws
name|TikaException
block|{
name|Charset
name|charset
init|=
name|getCharset
argument_list|()
decl_stmt|;
comment|// Common case: charset is same as last time, so
comment|// just reuse it:
if|if
condition|(
name|lastCharset
operator|==
literal|null
operator|||
operator|!
name|charset
operator|.
name|equals
argument_list|(
name|lastCharset
argument_list|)
condition|)
block|{
name|decoder
operator|=
name|charset
operator|.
name|newDecoder
argument_list|()
expr_stmt|;
name|decoder
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
name|decoder
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
name|lastCharset
operator|=
name|charset
expr_stmt|;
block|}
return|return
name|decoder
return|;
block|}
comment|// Return current charset in-use
specifier|private
name|Charset
name|getCharset
parameter_list|()
throws|throws
name|TikaException
block|{
comment|// If a specific font (fN) was set, use its charset
if|if
condition|(
name|groupState
operator|.
name|fontCharset
operator|!=
literal|null
condition|)
block|{
return|return
name|groupState
operator|.
name|fontCharset
return|;
block|}
comment|// Else, if global default font (defN) was set, use that one
if|if
condition|(
name|globalDefaultFont
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|inHeader
condition|)
block|{
name|Charset
name|cs
init|=
name|fontToCharset
operator|.
name|get
argument_list|(
name|globalDefaultFont
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
return|;
block|}
block|}
comment|// Else, use the global charset
if|if
condition|(
name|globalCharset
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"unable to determine charset"
argument_list|)
throw|;
block|}
return|return
name|globalCharset
return|;
block|}
comment|// Handle control word that takes a parameter:
specifier|private
name|void
name|processControlWord
parameter_list|(
name|int
name|param
parameter_list|,
name|PushbackInputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
comment|// TODO: afN?  (associated font number)
comment|// TODO: do these alter text output...?
comment|/*             } else if (equals("stshfdbch")) {                 // font to be used by default in                 // style sheet for East Asian chars                 // arg N is font table entry             } else if (equals("stshfloch")) {                 // font to be used by default in                 // style sheet for ASCII chars                 // arg N is font table entry             } else if (equals("stshfhich")) {                 // font to be used by default in                 // style sheet for High Ansi chars                 // arg N is font table entry             } else if (equals("stshfbi")) {                 // style sheet for Complex Scripts (BIDI) chars                 // arg N is font table entry                 */
comment|// TODO: inefficient that we check equals N times;
comment|// we'd get better perf w/ real lexer (eg
comment|// JFlex), which uses single-pass FSM to do cmp:
if|if
condition|(
name|inHeader
condition|)
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"ansicpg"
argument_list|)
condition|)
block|{
comment|// ANSI codepage
name|Charset
name|cs
init|=
name|ANSICPG_MAP
operator|.
name|get
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|globalCharset
operator|=
name|cs
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"deff"
argument_list|)
condition|)
block|{
comment|// Default font
name|globalDefaultFont
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"nofpages"
argument_list|)
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
name|Office
operator|.
name|PAGE_COUNT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"nofwords"
argument_list|)
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
name|Office
operator|.
name|WORD_COUNT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"nofchars"
argument_list|)
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
name|Office
operator|.
name|CHARACTER_COUNT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"yr"
argument_list|)
condition|)
block|{
name|year
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"mo"
argument_list|)
condition|)
block|{
name|month
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"dy"
argument_list|)
condition|)
block|{
name|day
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"hr"
argument_list|)
condition|)
block|{
name|hour
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"min"
argument_list|)
condition|)
block|{
name|minute
operator|=
name|param
expr_stmt|;
block|}
if|if
condition|(
name|fontTableState
operator|==
literal|1
condition|)
block|{
comment|// Still inside font table -- record the
comment|// mappings of fN to the fcharset:
if|if
condition|(
name|groupState
operator|.
name|depth
operator|<
name|fontTableDepth
condition|)
block|{
name|fontTableState
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"f"
argument_list|)
condition|)
block|{
comment|// Start new font definition
name|curFontID
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"fcharset"
argument_list|)
condition|)
block|{
name|Charset
name|cs
init|=
name|FCHARSET_MAP
operator|.
name|get
argument_list|(
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|fontToCharset
operator|.
name|put
argument_list|(
name|curFontID
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|currentList
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"listid"
argument_list|)
condition|)
block|{
name|currentList
operator|.
name|id
operator|=
name|param
expr_stmt|;
name|currentListTable
operator|.
name|put
argument_list|(
name|currentList
operator|.
name|id
argument_list|,
name|currentList
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"listtemplateid"
argument_list|)
condition|)
block|{
name|currentList
operator|.
name|templateID
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"levelnfc"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"levelnfcn"
argument_list|)
condition|)
block|{
comment|//sanity check to make sure list information isn't corrupt
if|if
condition|(
name|listTableLevel
operator|>
operator|-
literal|1
operator|&&
name|listTableLevel
operator|<
name|currentList
operator|.
name|numberType
operator|.
name|length
condition|)
block|{
name|currentList
operator|.
name|numberType
index|[
name|listTableLevel
index|]
operator|=
name|param
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// In document
if|if
condition|(
name|equals
argument_list|(
literal|"b"
argument_list|)
condition|)
block|{
comment|// b0
assert|assert
name|param
operator|==
literal|0
assert|;
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|groupState
operator|.
name|bold
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"i"
argument_list|)
condition|)
block|{
comment|// i0
assert|assert
name|param
operator|==
literal|0
assert|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"f"
argument_list|)
condition|)
block|{
comment|// Change current font
name|Charset
name|fontCharset
init|=
name|fontToCharset
operator|.
name|get
argument_list|(
name|param
argument_list|)
decl_stmt|;
comment|// Push any buffered text before changing
comment|// font:
name|pushText
argument_list|()
expr_stmt|;
if|if
condition|(
name|fontCharset
operator|!=
literal|null
condition|)
block|{
name|groupState
operator|.
name|fontCharset
operator|=
name|fontCharset
expr_stmt|;
block|}
else|else
block|{
comment|// DOC ERROR: font change referenced a
comment|// non-table'd font number
comment|// TODO: log a warning?  Throw an exc?
name|groupState
operator|.
name|fontCharset
operator|=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"ls"
argument_list|)
condition|)
block|{
name|groupState
operator|.
name|list
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"lslvl"
argument_list|)
condition|)
block|{
name|groupState
operator|.
name|listLevel
operator|=
name|param
expr_stmt|;
block|}
block|}
comment|// Process unicode escape. This can appear in doc
comment|// or in header, since the metadata (info) fields
comment|// in the header can be unicode escaped as well:
if|if
condition|(
name|equals
argument_list|(
literal|"u"
argument_list|)
condition|)
block|{
comment|// Unicode escape
if|if
condition|(
operator|!
name|groupState
operator|.
name|ignore
operator|||
name|groupState
operator|.
name|sv
operator|||
name|groupState
operator|.
name|sn
condition|)
block|{
specifier|final
name|char
name|utf16CodeUnit
init|=
call|(
name|char
call|)
argument_list|(
name|param
operator|&
literal|0xffff
argument_list|)
decl_stmt|;
name|addOutputChar
argument_list|(
name|utf16CodeUnit
argument_list|)
expr_stmt|;
block|}
comment|// After seeing a unicode escape we must
comment|// skip the next ucSkip ansi chars (the
comment|// "unicode shadow")
name|ansiSkip
operator|=
name|groupState
operator|.
name|ucSkip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"uc"
argument_list|)
condition|)
block|{
comment|// Change unicode shadow length
name|groupState
operator|.
name|ucSkip
operator|=
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"bin"
argument_list|)
condition|)
block|{
if|if
condition|(
name|param
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|groupState
operator|.
name|pictDepth
operator|==
literal|1
condition|)
block|{
try|try
block|{
name|embObjHandler
operator|.
name|writeBytes
argument_list|(
name|in
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//param was out of bounds or something went wrong during writing.
comment|//skip this obj and move on
comment|//TODO: log.warn
name|embObjHandler
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|bytesToRead
init|=
name|param
decl_stmt|;
name|byte
index|[]
name|tmpArray
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|min
argument_list|(
literal|1024
argument_list|,
name|bytesToRead
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|bytesToRead
operator|>
literal|0
condition|)
block|{
name|int
name|r
init|=
name|in
operator|.
name|read
argument_list|(
name|tmpArray
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|bytesToRead
argument_list|,
name|tmpArray
operator|.
name|length
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"unexpected end of file: need "
operator|+
name|param
operator|+
literal|" bytes of binary data, found "
operator|+
operator|(
name|param
operator|-
name|bytesToRead
operator|)
argument_list|)
throw|;
block|}
name|bytesToRead
operator|-=
name|r
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// log some warning?
block|}
block|}
block|}
specifier|private
name|boolean
name|inList
parameter_list|()
block|{
return|return
operator|!
name|ignoreLists
operator|&&
name|groupState
operator|.
name|list
operator|!=
literal|0
return|;
block|}
comment|/**      * Marks the current list as pending to end. This is done to be able to merge list items of      * the same list within the same enclosing list tag (ie. either<code>"ul"</code>, or      *<code>"ol"</code>).      */
specifier|private
name|void
name|pendingListEnd
parameter_list|()
block|{
name|pendingListEnd
operator|=
name|groupState
operator|.
name|list
expr_stmt|;
name|groupState
operator|.
name|list
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Emits the end tag of a list. Uses {@link #isUnorderedList(int)} to determine the list      * type for the given<code>listID</code>.      * @param listID The ID of the list.      * @throws IOException      * @throws SAXException      * @throws TikaException      */
specifier|private
name|void
name|endList
parameter_list|(
name|int
name|listID
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
operator|!
name|ignoreLists
condition|)
block|{
name|out
operator|.
name|endElement
argument_list|(
name|isUnorderedList
argument_list|(
name|listID
argument_list|)
condition|?
literal|"ul"
else|:
literal|"ol"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Emits the start tag of a list. Uses {@link #isUnorderedList(int)} to determine the list      * type for the given<code>listID</code>.      * @param listID The ID of the list.      * @throws IOException      * @throws SAXException      * @throws TikaException      */
specifier|private
name|void
name|startList
parameter_list|(
name|int
name|listID
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
operator|!
name|ignoreLists
condition|)
block|{
name|out
operator|.
name|startElement
argument_list|(
name|isUnorderedList
argument_list|(
name|listID
argument_list|)
condition|?
literal|"ul"
else|:
literal|"ol"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isUnorderedList
parameter_list|(
name|int
name|listID
parameter_list|)
block|{
name|ListDescriptor
name|list
init|=
name|listTable
operator|.
name|get
argument_list|(
name|listID
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
return|return
name|list
operator|.
name|isUnordered
argument_list|(
name|groupState
operator|.
name|listLevel
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|end
parameter_list|(
name|String
name|tag
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|out
operator|.
name|endElement
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|start
parameter_list|(
name|String
name|tag
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|out
operator|.
name|startElement
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
comment|// Handle non-parameter control word:
specifier|private
name|void
name|processControlWord
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|inHeader
condition|)
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"ansi"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
name|WINDOWS_1252
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"pca"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
name|CP850
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"pc"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
name|CP437
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"mac"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
name|MAC_ROMAN
expr_stmt|;
block|}
if|if
condition|(
name|equals
argument_list|(
literal|"colortbl"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"stylesheet"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"fonttbl"
argument_list|)
condition|)
block|{
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"listtable"
argument_list|)
condition|)
block|{
name|currentListTable
operator|=
name|listTable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"listoverridetable"
argument_list|)
condition|)
block|{
name|currentListTable
operator|=
name|listOverrideTable
expr_stmt|;
block|}
if|if
condition|(
name|uprState
operator|==
operator|-
literal|1
condition|)
block|{
comment|// TODO: we can also parse \creatim, \revtim,
comment|// \printim, \version, etc.
if|if
condition|(
name|equals
argument_list|(
literal|"author"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|TikaCoreProperties
operator|.
name|CREATOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"title"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|TikaCoreProperties
operator|.
name|TITLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"subject"
argument_list|)
condition|)
block|{
comment|// TODO: Move to OO subject in Tika 2.0
name|nextMetaData
operator|=
name|TikaCoreProperties
operator|.
name|TRANSITION_SUBJECT_TO_OO_SUBJECT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|TikaCoreProperties
operator|.
name|TRANSITION_KEYWORDS_TO_DC_SUBJECT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"category"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|OfficeOpenXMLCore
operator|.
name|CATEGORY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"comment"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|TikaCoreProperties
operator|.
name|COMMENTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"company"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|OfficeOpenXMLExtended
operator|.
name|COMPANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"manager"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|OfficeOpenXMLExtended
operator|.
name|MANAGER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"template"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|OfficeOpenXMLExtended
operator|.
name|TEMPLATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"creatim"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|TikaCoreProperties
operator|.
name|CREATED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fontTableState
operator|==
literal|0
condition|)
block|{
comment|// Didn't see font table yet
if|if
condition|(
name|equals
argument_list|(
literal|"fonttbl"
argument_list|)
condition|)
block|{
name|fontTableState
operator|=
literal|1
expr_stmt|;
name|fontTableDepth
operator|=
name|groupState
operator|.
name|depth
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fontTableState
operator|==
literal|1
condition|)
block|{
comment|// Inside font table
if|if
condition|(
name|groupState
operator|.
name|depth
operator|<
name|fontTableDepth
condition|)
block|{
name|fontTableState
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|// List table handling
if|if
condition|(
name|currentListTable
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"list"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"listoverride"
argument_list|)
condition|)
block|{
name|currentList
operator|=
operator|new
name|ListDescriptor
argument_list|()
expr_stmt|;
name|listTableLevel
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentList
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"liststylename"
argument_list|)
condition|)
block|{
name|currentList
operator|.
name|isStyle
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"listlevel"
argument_list|)
condition|)
block|{
name|listTableLevel
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|groupState
operator|.
name|ignore
operator|&&
operator|(
name|equals
argument_list|(
literal|"par"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"pard"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"sect"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"sectd"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"plain"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"ltrch"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"rtlch"
argument_list|)
operator|)
condition|)
block|{
name|inHeader
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"b"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|groupState
operator|.
name|bold
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|lazyStartParagraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
comment|// Make sure nesting is always<b><i>
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|groupState
operator|.
name|bold
operator|=
literal|true
expr_stmt|;
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"i"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|groupState
operator|.
name|italic
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|true
expr_stmt|;
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|boolean
name|ignored
init|=
name|groupState
operator|.
name|ignore
decl_stmt|;
if|if
condition|(
name|equals
argument_list|(
literal|"pard"
argument_list|)
condition|)
block|{
comment|// Reset styles
name|pushText
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|bold
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|inList
argument_list|()
condition|)
block|{
comment|//&& (groupStates.size() == 1 || groupStates.peekLast().list< 0))
name|pendingListEnd
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"par"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|endParagraph
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"shptxt"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Text inside a shape
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"atnid"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Annotation ID
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"atnauthor"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Annotation author
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"annotation"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Annotation
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"listtext"
argument_list|)
condition|)
block|{
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"cell"
argument_list|)
condition|)
block|{
comment|// TODO: we should produce a table output here?
comment|//addOutputChar(' ');
name|endParagraph
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"sp"
argument_list|)
condition|)
block|{
name|groupState
operator|.
name|sp
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"sn"
argument_list|)
condition|)
block|{
name|embObjHandler
operator|.
name|startSN
argument_list|()
expr_stmt|;
name|groupState
operator|.
name|sn
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"sv"
argument_list|)
condition|)
block|{
name|embObjHandler
operator|.
name|startSV
argument_list|()
expr_stmt|;
name|groupState
operator|.
name|sv
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"object"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|embObjHandler
operator|.
name|setInObject
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|object
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"objdata"
argument_list|)
condition|)
block|{
name|groupState
operator|.
name|objdata
operator|=
literal|true
expr_stmt|;
name|embObjHandler
operator|.
name|startObjData
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"pict"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// TODO: create img tag?  but can that support
comment|// embedded image data?
name|groupState
operator|.
name|pictDepth
operator|=
literal|1
expr_stmt|;
name|embObjHandler
operator|.
name|startPict
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"line"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"column"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|addOutputChar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"page"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"softline"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"softcolumn"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|addOutputChar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"softpage"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"tab"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"upr"
argument_list|)
condition|)
block|{
name|uprState
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"ud"
argument_list|)
operator|&&
name|uprState
operator|==
literal|1
condition|)
block|{
name|uprState
operator|=
operator|-
literal|1
expr_stmt|;
comment|// 2nd group inside the upr destination, which
comment|// contains the unicode encoding of the text, so
comment|// we want to keep that:
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"bullet"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode BULLET
name|addOutputChar
argument_list|(
literal|'\u2022'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"endash"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode EN DASH
name|addOutputChar
argument_list|(
literal|'\u2013'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"emdash"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode EM DASH
name|addOutputChar
argument_list|(
literal|'\u2014'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"enspace"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode EN SPACE
name|addOutputChar
argument_list|(
literal|'\u2002'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"qmspace"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// quarter em space -> unicode FOUR-PER-EM SPACE
name|addOutputChar
argument_list|(
literal|'\u2005'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"emspace"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode EM SPACE
name|addOutputChar
argument_list|(
literal|'\u2003'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"lquote"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode LEFT SINGLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u2018'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"rquote"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode RIGHT SINGLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u2019'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"ldblquote"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode LEFT DOUBLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u201C'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"rdblquote"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignored
condition|)
block|{
comment|// unicode RIGHT DOUBLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u201D'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"fldinst"
argument_list|)
condition|)
block|{
name|fieldState
operator|=
literal|1
expr_stmt|;
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"fldrslt"
argument_list|)
operator|&&
name|fieldState
operator|==
literal|2
condition|)
block|{
assert|assert
name|pendingURL
operator|!=
literal|null
assert|;
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|startElement
argument_list|(
literal|"a"
argument_list|,
literal|"href"
argument_list|,
name|pendingURL
argument_list|)
expr_stmt|;
name|pendingURL
operator|=
literal|null
expr_stmt|;
name|fieldState
operator|=
literal|3
expr_stmt|;
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Push new GroupState
specifier|private
name|void
name|processGroupStart
parameter_list|(
name|PushbackInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|ansiSkip
operator|=
literal|0
expr_stmt|;
comment|// Push current groupState onto the stack
name|groupStates
operator|.
name|add
argument_list|(
name|groupState
argument_list|)
expr_stmt|;
comment|// Make new GroupState
name|groupState
operator|=
operator|new
name|GroupState
argument_list|(
name|groupState
argument_list|)
expr_stmt|;
assert|assert
name|groupStates
operator|.
name|size
argument_list|()
operator|==
name|groupState
operator|.
name|depth
operator|:
literal|"size="
operator|+
name|groupStates
operator|.
name|size
argument_list|()
operator|+
literal|" depth="
operator|+
name|groupState
operator|.
name|depth
assert|;
if|if
condition|(
name|uprState
operator|==
literal|0
condition|)
block|{
name|uprState
operator|=
literal|1
expr_stmt|;
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
block|}
comment|// Check for ignorable groups. Note that
comment|// sometimes we un-ignore within this group, eg
comment|// when handling upr escape.
name|int
name|b2
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b2
operator|==
literal|'\\'
condition|)
block|{
name|int
name|b3
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b3
operator|==
literal|'*'
condition|)
block|{
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
block|}
name|in
operator|.
name|unread
argument_list|(
name|b3
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|unread
argument_list|(
name|b2
argument_list|)
expr_stmt|;
block|}
comment|// Pop current GroupState
specifier|private
name|void
name|processGroupEnd
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|inHeader
condition|)
block|{
if|if
condition|(
name|nextMetaData
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nextMetaData
operator|==
name|TikaCoreProperties
operator|.
name|CREATED
condition|)
block|{
name|Calendar
name|cal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|year
argument_list|,
name|month
operator|-
literal|1
argument_list|,
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|set
argument_list|(
name|nextMetaData
argument_list|,
name|cal
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextMetaData
operator|.
name|isMultiValuePermitted
argument_list|()
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
name|nextMetaData
argument_list|,
name|pendingBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metadata
operator|.
name|set
argument_list|(
name|nextMetaData
argument_list|,
name|pendingBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nextMetaData
operator|=
literal|null
expr_stmt|;
block|}
name|pendingBuffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
assert|assert
name|groupState
operator|.
name|depth
operator|>
literal|0
assert|;
name|ansiSkip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|objdata
operator|==
literal|true
condition|)
block|{
name|embObjHandler
operator|.
name|handleCompletedObject
argument_list|()
expr_stmt|;
name|groupState
operator|.
name|objdata
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|groupState
operator|.
name|pictDepth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|groupState
operator|.
name|sn
operator|==
literal|true
condition|)
block|{
name|embObjHandler
operator|.
name|endSN
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|groupState
operator|.
name|sv
operator|==
literal|true
condition|)
block|{
name|embObjHandler
operator|.
name|endSV
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|groupState
operator|.
name|sp
operator|==
literal|true
condition|)
block|{
name|embObjHandler
operator|.
name|endSP
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|groupState
operator|.
name|pictDepth
operator|==
literal|1
condition|)
block|{
name|embObjHandler
operator|.
name|handleCompletedObject
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|groupState
operator|.
name|object
operator|==
literal|true
condition|)
block|{
name|embObjHandler
operator|.
name|setInObject
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Be robust if RTF doc is corrupt (has too many
comment|// closing }s):
comment|// TODO: log a warning?
if|if
condition|(
name|groupStates
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Restore group state:
specifier|final
name|GroupState
name|outerGroupState
init|=
name|groupStates
operator|.
name|removeLast
argument_list|()
decl_stmt|;
comment|// Close italic, if outer does not have italic or
comment|// bold changed:
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
if|if
condition|(
operator|!
name|outerGroupState
operator|.
name|italic
operator|||
name|groupState
operator|.
name|bold
operator|!=
name|outerGroupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Close bold
if|if
condition|(
name|groupState
operator|.
name|bold
operator|&&
operator|!
name|outerGroupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
comment|// Open bold
if|if
condition|(
operator|!
name|groupState
operator|.
name|bold
operator|&&
name|outerGroupState
operator|.
name|bold
condition|)
block|{
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
comment|// Open italic
if|if
condition|(
operator|!
name|groupState
operator|.
name|italic
operator|&&
name|outerGroupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|groupState
operator|=
name|outerGroupState
expr_stmt|;
block|}
assert|assert
name|groupStates
operator|.
name|size
argument_list|()
operator|==
name|groupState
operator|.
name|depth
assert|;
if|if
condition|(
name|fieldState
operator|==
literal|1
condition|)
block|{
name|String
name|s
init|=
name|pendingBuffer
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|pendingBuffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"HYPERLINK"
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// TODO: what other instructions can be in a
comment|// HYPERLINK destination?
specifier|final
name|boolean
name|isLocalLink
init|=
name|s
operator|.
name|contains
argument_list|(
literal|"\\l "
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|idx2
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
literal|1
operator|+
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx2
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|idx
argument_list|,
name|idx2
argument_list|)
expr_stmt|;
block|}
block|}
name|pendingURL
operator|=
operator|(
name|isLocalLink
condition|?
literal|"#"
else|:
literal|""
operator|)
operator|+
name|s
expr_stmt|;
name|fieldState
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fieldState
operator|=
literal|0
expr_stmt|;
block|}
comment|// TODO: we could process the other known field
comment|// types.  Right now, we will extract their text
comment|// inlined, but fail to record them in metadata
comment|// as a field value.
block|}
elseif|else
if|if
condition|(
name|fieldState
operator|==
literal|3
condition|)
block|{
name|out
operator|.
name|endElement
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|fieldState
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

