begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|rtf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CoderResult
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CodingErrorAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|sax
operator|.
name|XHTMLContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|utils
operator|.
name|CharsetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/* Tokenizes and performs a "shallow" parse of the RTF  * document, just enough to properly decode the text.  *  * TODO: we should cutover to a "real" tokenizer (eg JFlex);  * it should give better perf, by replacing the excessive  * "else if" string compares with FSA traversal. */
end_comment

begin_class
specifier|final
class|class
name|TextExtractor
block|{
comment|// Hold pending bytes (encoded in the current charset)
comment|// for text output:
specifier|private
name|byte
index|[]
name|pendingBytes
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
specifier|private
name|int
name|pendingByteCount
decl_stmt|;
specifier|private
name|ByteBuffer
name|pendingByteBuffer
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|pendingBytes
argument_list|)
decl_stmt|;
comment|// Holds pending chars for text output
specifier|private
name|char
index|[]
name|pendingChars
init|=
operator|new
name|char
index|[
literal|10
index|]
decl_stmt|;
specifier|private
name|int
name|pendingCharCount
decl_stmt|;
comment|// Holds chars for a still-being-tokenized control word
specifier|private
name|byte
index|[]
name|pendingControl
init|=
operator|new
name|byte
index|[
literal|10
index|]
decl_stmt|;
specifier|private
name|int
name|pendingControlCount
decl_stmt|;
comment|// Used when we decode bytes -> chars using CharsetDecoder:
specifier|private
specifier|final
name|char
index|[]
name|outputArray
init|=
operator|new
name|char
index|[
literal|128
index|]
decl_stmt|;
specifier|private
specifier|final
name|CharBuffer
name|outputBuffer
init|=
name|CharBuffer
operator|.
name|wrap
argument_list|(
name|outputArray
argument_list|)
decl_stmt|;
comment|// Reused when possible:
specifier|private
name|CharsetDecoder
name|decoder
decl_stmt|;
specifier|private
name|String
name|lastCharset
decl_stmt|;
specifier|private
name|String
name|globalCharset
init|=
literal|"windows-1252"
decl_stmt|;
specifier|private
name|int
name|globalDefaultFont
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|curFontID
init|=
operator|-
literal|1
decl_stmt|;
comment|// Holds the font table from this RTF doc, mapping
comment|// the font number (from \fN control word) to the
comment|// corresponding charset:
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|fontToCharset
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Group stack: when we open a new group, we push
comment|// the previous group state onto the stack; when we
comment|// close the group, we restore it
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|GroupState
argument_list|>
name|groupStates
init|=
operator|new
name|LinkedList
argument_list|<
name|GroupState
argument_list|>
argument_list|()
decl_stmt|;
comment|// Current group state; in theory this initial
comment|// GroupState is unused because the RTF doc should
comment|// immediately open the top group (start with {):
specifier|private
name|GroupState
name|groupState
init|=
operator|new
name|GroupState
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|inHeader
init|=
literal|true
decl_stmt|;
specifier|private
name|int
name|fontTableState
decl_stmt|;
specifier|private
name|int
name|fontTableDepth
decl_stmt|;
comment|// Non null if we are processing metadata (title,
comment|// keywords, etc.) inside the info group:
specifier|private
name|String
name|nextMetaData
decl_stmt|;
specifier|private
name|boolean
name|inParagraph
decl_stmt|;
comment|// Non-zero if we are processing inside a field destination:
specifier|private
name|int
name|fieldState
decl_stmt|;
comment|// Non-null if we've seen the url for a HYPERLINK but not yet
comment|// its text:
specifier|private
name|String
name|pendingURL
decl_stmt|;
specifier|private
specifier|final
name|StringBuilder
name|pendingBuffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Used to process the sub-groups inside the upr
comment|// group:
specifier|private
name|int
name|uprState
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|XHTMLContentHandler
name|out
decl_stmt|;
specifier|private
specifier|final
name|Metadata
name|metadata
decl_stmt|;
comment|// How many next ansi chars we should skip; this
comment|// is 0 except when we are still in the "ansi
comment|// shadow" after seeing a unicode escape, at which
comment|// point it's set to the last ucN skip we had seen:
name|int
name|ansiSkip
init|=
literal|0
decl_stmt|;
comment|// The RTF doc has a "font table" that assigns ords
comment|// (f0, f1, f2, etc.) to fonts and charsets, using the
comment|// \fcharsetN control word.  This mapping maps from the
comment|// N to corresponding Java charset:
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|FCHARSET_MAP
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|0
argument_list|,
literal|"windows-1252"
argument_list|)
expr_stmt|;
comment|// ANSI
comment|// charset 1 is Default
comment|// charset 2 is Symbol
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|77
argument_list|,
literal|"MacRoman"
argument_list|)
expr_stmt|;
comment|// Mac Roman
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|78
argument_list|,
literal|"Shift_JIS"
argument_list|)
expr_stmt|;
comment|// Mac Shift Jis
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|79
argument_list|,
literal|"ms949"
argument_list|)
expr_stmt|;
comment|// Mac Hangul
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|80
argument_list|,
literal|"GB2312"
argument_list|)
expr_stmt|;
comment|// Mac GB2312
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|81
argument_list|,
literal|"Big5"
argument_list|)
expr_stmt|;
comment|// Mac Big5
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|82
argument_list|,
literal|"johab"
argument_list|)
expr_stmt|;
comment|// Mac Johab (old)
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|83
argument_list|,
literal|"MacHebrew"
argument_list|)
expr_stmt|;
comment|// Mac Hebrew
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|84
argument_list|,
literal|"MacArabic"
argument_list|)
expr_stmt|;
comment|// Mac Arabic
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|85
argument_list|,
literal|"MacGreek"
argument_list|)
expr_stmt|;
comment|// Mac Greek
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|86
argument_list|,
literal|"MacTurkish"
argument_list|)
expr_stmt|;
comment|// Mac Turkish
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|87
argument_list|,
literal|"MacThai"
argument_list|)
expr_stmt|;
comment|// Mac Thai
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|88
argument_list|,
literal|"cp1250"
argument_list|)
expr_stmt|;
comment|// Mac East Europe
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|89
argument_list|,
literal|"cp1251"
argument_list|)
expr_stmt|;
comment|// Mac Russian
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|128
argument_list|,
literal|"MS932"
argument_list|)
expr_stmt|;
comment|// Shift JIS
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|129
argument_list|,
literal|"ms949"
argument_list|)
expr_stmt|;
comment|// Hangul
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|130
argument_list|,
literal|"ms1361"
argument_list|)
expr_stmt|;
comment|// Johab
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|134
argument_list|,
literal|"ms936"
argument_list|)
expr_stmt|;
comment|// GB2312
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|136
argument_list|,
literal|"ms950"
argument_list|)
expr_stmt|;
comment|// Big5
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|161
argument_list|,
literal|"cp1253"
argument_list|)
expr_stmt|;
comment|// Greek
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|162
argument_list|,
literal|"cp1254"
argument_list|)
expr_stmt|;
comment|// Turkish
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|163
argument_list|,
literal|"cp1258"
argument_list|)
expr_stmt|;
comment|// Vietnamese
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|177
argument_list|,
literal|"cp1255"
argument_list|)
expr_stmt|;
comment|// Hebrew
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|178
argument_list|,
literal|"cp1256"
argument_list|)
expr_stmt|;
comment|// Arabic
comment|// FCHARSET_MAP.put( 179, "" ); // Arabic Traditional
comment|// FCHARSET_MAP.put( 180, "" ); // Arabic user
comment|// FCHARSET_MAP.put( 181, "" ); // Hebrew user
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|186
argument_list|,
literal|"cp1257"
argument_list|)
expr_stmt|;
comment|// Baltic
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|204
argument_list|,
literal|"cp1251"
argument_list|)
expr_stmt|;
comment|// Russian
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|222
argument_list|,
literal|"ms874"
argument_list|)
expr_stmt|;
comment|// Thai
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|238
argument_list|,
literal|"cp1250"
argument_list|)
expr_stmt|;
comment|// Eastern European
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|254
argument_list|,
literal|"cp437"
argument_list|)
expr_stmt|;
comment|// PC 437
name|FCHARSET_MAP
operator|.
name|put
argument_list|(
literal|255
argument_list|,
literal|"cp850"
argument_list|)
expr_stmt|;
comment|// OEM
block|}
comment|// The RTF may specify the \ansicpgN charset in the
comment|// header; this maps the N to the corresponding Java
comment|// character set:
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|ANSICPG_MAP
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|437
argument_list|,
literal|"CP437"
argument_list|)
expr_stmt|;
comment|// US IBM
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|708
argument_list|,
literal|"ISO-8859-6"
argument_list|)
expr_stmt|;
comment|// Arabic (ASMO 708)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|709
argument_list|,
literal|"windows-709"
argument_list|)
expr_stmt|;
comment|// Arabic (ASMO 449+, BCON V4)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|710
argument_list|,
literal|"windows-710"
argument_list|)
expr_stmt|;
comment|// Arabic (transparent Arabic)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|710
argument_list|,
literal|"windows-711"
argument_list|)
expr_stmt|;
comment|// Arabic (Nafitha Enhanced)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|710
argument_list|,
literal|"windows-720"
argument_list|)
expr_stmt|;
comment|// Arabic (transparent ASMO)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|819
argument_list|,
literal|"CP819"
argument_list|)
expr_stmt|;
comment|// Windows 3.1 (US& Western Europe)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|819
argument_list|,
literal|"CP819"
argument_list|)
expr_stmt|;
comment|// Windows 3.1 (US& Western Europe)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|819
argument_list|,
literal|"CP819"
argument_list|)
expr_stmt|;
comment|// Windows 3.1 (US& Western Europe)
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|850
argument_list|,
literal|"CP850"
argument_list|)
expr_stmt|;
comment|// IBM Multilingual
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|852
argument_list|,
literal|"CP852"
argument_list|)
expr_stmt|;
comment|// Eastern European
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|860
argument_list|,
literal|"CP860"
argument_list|)
expr_stmt|;
comment|// Portuguese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|862
argument_list|,
literal|"CP862"
argument_list|)
expr_stmt|;
comment|// Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|863
argument_list|,
literal|"CP863"
argument_list|)
expr_stmt|;
comment|// French Canadian
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|864
argument_list|,
literal|"CP864"
argument_list|)
expr_stmt|;
comment|// Arabic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|865
argument_list|,
literal|"CP865"
argument_list|)
expr_stmt|;
comment|// Norwegian
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|866
argument_list|,
literal|"CP866"
argument_list|)
expr_stmt|;
comment|// Soviet Union
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|874
argument_list|,
literal|"MS874"
argument_list|)
expr_stmt|;
comment|// Thai
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|932
argument_list|,
literal|"MS932"
argument_list|)
expr_stmt|;
comment|// Japanese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|936
argument_list|,
literal|"MS936"
argument_list|)
expr_stmt|;
comment|// Simplified Chinese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|949
argument_list|,
literal|"CP949"
argument_list|)
expr_stmt|;
comment|// Korean
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|950
argument_list|,
literal|"CP950"
argument_list|)
expr_stmt|;
comment|// Traditional Chinese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1250
argument_list|,
literal|"CP1250"
argument_list|)
expr_stmt|;
comment|// Eastern European
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1251
argument_list|,
literal|"CP1251"
argument_list|)
expr_stmt|;
comment|// Cyrillic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1252
argument_list|,
literal|"CP1252"
argument_list|)
expr_stmt|;
comment|// Western European
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1253
argument_list|,
literal|"CP1253"
argument_list|)
expr_stmt|;
comment|// Greek
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1254
argument_list|,
literal|"CP1254"
argument_list|)
expr_stmt|;
comment|// Turkish
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1255
argument_list|,
literal|"CP1255"
argument_list|)
expr_stmt|;
comment|// Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1256
argument_list|,
literal|"CP1256"
argument_list|)
expr_stmt|;
comment|// Arabic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1257
argument_list|,
literal|"CP1257"
argument_list|)
expr_stmt|;
comment|// Baltic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1258
argument_list|,
literal|"CP1258"
argument_list|)
expr_stmt|;
comment|// Vietnamese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|1361
argument_list|,
literal|"x-Johab"
argument_list|)
expr_stmt|;
comment|// Johab
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10000
argument_list|,
literal|"MacRoman"
argument_list|)
expr_stmt|;
comment|// Mac Roman
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10001
argument_list|,
literal|"Shift_JIS"
argument_list|)
expr_stmt|;
comment|// Mac Japan
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10004
argument_list|,
literal|"MacArabic"
argument_list|)
expr_stmt|;
comment|// Mac Arabic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10005
argument_list|,
literal|"MacHebrew"
argument_list|)
expr_stmt|;
comment|// Mac Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10006
argument_list|,
literal|"MacGreek"
argument_list|)
expr_stmt|;
comment|// Mac Hebrew
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10007
argument_list|,
literal|"MacCyrillic"
argument_list|)
expr_stmt|;
comment|// Mac Cyrillic
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10029
argument_list|,
literal|"x-MacCentralEurope"
argument_list|)
expr_stmt|;
comment|// MAC Latin2
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|10081
argument_list|,
literal|"MacTurkish"
argument_list|)
expr_stmt|;
comment|// Mac Turkish
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57002
argument_list|,
literal|"x-ISCII91"
argument_list|)
expr_stmt|;
comment|// Devanagari
comment|// TODO: in theory these other charsets are simple
comment|// shifts off of Devanagari, so we could impl that
comment|// here:
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57003
argument_list|,
literal|"windows-57003"
argument_list|)
expr_stmt|;
comment|// Bengali
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57004
argument_list|,
literal|"windows-57004"
argument_list|)
expr_stmt|;
comment|// Tamil
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57005
argument_list|,
literal|"windows-57005"
argument_list|)
expr_stmt|;
comment|// Telugu
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57006
argument_list|,
literal|"windows-57006"
argument_list|)
expr_stmt|;
comment|// Assamese
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57007
argument_list|,
literal|"windows-57007"
argument_list|)
expr_stmt|;
comment|// Oriya
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57008
argument_list|,
literal|"windows-57008"
argument_list|)
expr_stmt|;
comment|// Kannada
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57009
argument_list|,
literal|"windows-57009"
argument_list|)
expr_stmt|;
comment|// Malayalam
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57010
argument_list|,
literal|"windows-57010"
argument_list|)
expr_stmt|;
comment|// Gujariti
name|ANSICPG_MAP
operator|.
name|put
argument_list|(
literal|57011
argument_list|,
literal|"windows-57011"
argument_list|)
expr_stmt|;
comment|// Punjabi
block|}
specifier|public
name|TextExtractor
parameter_list|(
name|XHTMLContentHandler
name|out
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
block|{
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isHexChar
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isAlpha
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
operator|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isDigit
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
return|;
block|}
specifier|private
specifier|static
name|int
name|hexValue
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
return|return
name|ch
operator|-
literal|'0'
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
condition|)
block|{
return|return
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'a'
operator|)
return|;
block|}
else|else
block|{
assert|assert
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
assert|;
return|return
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'A'
operator|)
return|;
block|}
block|}
comment|// Push pending bytes or pending chars:
specifier|private
name|void
name|pushText
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingByteCount
operator|!=
literal|0
condition|)
block|{
assert|assert
name|pendingCharCount
operator|==
literal|0
assert|;
name|pushBytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pushChars
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Buffers the byte (unit in the current charset) for
comment|// output:
specifier|private
name|void
name|addOutputByte
parameter_list|(
name|byte
name|b
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingCharCount
operator|!=
literal|0
condition|)
block|{
name|pushChars
argument_list|()
expr_stmt|;
block|}
comment|// Save the byte in pending buffer:
if|if
condition|(
name|pendingByteCount
operator|==
name|pendingBytes
operator|.
name|length
condition|)
block|{
comment|// Gradual but exponential growth:
specifier|final
name|byte
index|[]
name|newArray
init|=
operator|new
name|byte
index|[
call|(
name|int
call|)
argument_list|(
name|pendingBytes
operator|.
name|length
operator|*
literal|1.25
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|pendingBytes
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|pendingBytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|pendingBytes
operator|=
name|newArray
expr_stmt|;
name|pendingByteBuffer
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|pendingBytes
argument_list|)
expr_stmt|;
block|}
name|pendingBytes
index|[
name|pendingByteCount
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|// Buffers a byte as part of a control word:
specifier|private
name|void
name|addControl
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
assert|assert
name|isAlpha
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
assert|;
comment|// Save the byte in pending buffer:
if|if
condition|(
name|pendingControlCount
operator|==
name|pendingControl
operator|.
name|length
condition|)
block|{
comment|// Gradual but exponential growth:
specifier|final
name|byte
index|[]
name|newArray
init|=
operator|new
name|byte
index|[
call|(
name|int
call|)
argument_list|(
name|pendingControl
operator|.
name|length
operator|*
literal|1.25
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|pendingControl
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|pendingControl
operator|.
name|length
argument_list|)
expr_stmt|;
name|pendingControl
operator|=
name|newArray
expr_stmt|;
block|}
name|pendingControl
index|[
name|pendingControlCount
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
comment|// Buffers a UTF16 code unit for output
specifier|private
name|void
name|addOutputChar
parameter_list|(
name|char
name|ch
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingByteCount
operator|!=
literal|0
condition|)
block|{
name|pushBytes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inHeader
operator|||
name|fieldState
operator|==
literal|1
condition|)
block|{
name|pendingBuffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pendingCharCount
operator|==
name|pendingChars
operator|.
name|length
condition|)
block|{
comment|// Gradual but exponential growth:
specifier|final
name|char
index|[]
name|newArray
init|=
operator|new
name|char
index|[
call|(
name|int
call|)
argument_list|(
name|pendingChars
operator|.
name|length
operator|*
literal|1.25
argument_list|)
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|pendingChars
argument_list|,
literal|0
argument_list|,
name|newArray
argument_list|,
literal|0
argument_list|,
name|pendingChars
operator|.
name|length
argument_list|)
expr_stmt|;
name|pendingChars
operator|=
name|newArray
expr_stmt|;
block|}
name|pendingChars
index|[
name|pendingCharCount
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
block|}
comment|// Shallow parses the entire doc, writing output to
comment|// this.out and this.metadata
specifier|public
name|void
name|extract
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|out
operator|.
name|startDocument
argument_list|()
expr_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|pushBack
init|=
operator|-
literal|2
decl_stmt|;
name|boolean
name|negParam
init|=
literal|false
decl_stmt|;
name|char
name|hex1
init|=
literal|0
decl_stmt|;
name|long
name|param
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|b
decl_stmt|;
if|if
condition|(
name|pushBack
operator|!=
operator|-
literal|2
condition|)
block|{
name|b
operator|=
name|pushBack
expr_stmt|;
name|pushBack
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
name|in
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
comment|// NOTE: this is always a 8bit clean byte (ie
comment|//< 128), but we use a char for
comment|// convenience in the testing below:
specifier|final
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|b
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'{'
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|processGroupStart
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'}'
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|processGroupEnd
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
operator|(
operator|!
name|groupState
operator|.
name|ignore
operator|||
name|nextMetaData
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Linefeed and carriage return are not
comment|// significant
if|if
condition|(
name|ansiSkip
operator|!=
literal|0
condition|)
block|{
name|ansiSkip
operator|--
expr_stmt|;
block|}
else|else
block|{
name|addOutputByte
argument_list|(
operator|(
name|byte
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|// saw \
case|case
literal|1
case|:
if|if
condition|(
name|ch
operator|==
literal|'\''
condition|)
block|{
comment|// escaped hex char
name|state
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isAlpha
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|// control word
comment|//pushText();
name|addControl
argument_list|(
operator|(
name|byte
operator|)
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'{'
operator|||
name|ch
operator|==
literal|'}'
operator|||
name|ch
operator|==
literal|'\\'
operator|||
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
condition|)
block|{
comment|// escaped char
name|addOutputByte
argument_list|(
operator|(
name|byte
operator|)
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// control symbol, eg \* or \~
comment|//pushText();
name|processControlSymbol
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|// saw \'
case|case
literal|2
case|:
if|if
condition|(
name|isHexChar
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|hex1
operator|=
name|ch
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|// DOC ERROR (malformed hex escape): ignore
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|// saw \'x
case|case
literal|3
case|:
if|if
condition|(
name|isHexChar
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|ansiSkip
operator|!=
literal|0
condition|)
block|{
comment|// Skip this ansi char since we are
comment|// still in the shadow of a unicode
comment|// escape:
name|ansiSkip
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|// Unescape:
name|addOutputByte
argument_list|(
call|(
name|byte
call|)
argument_list|(
literal|16
operator|*
name|hexValue
argument_list|(
name|hex1
argument_list|)
operator|+
name|hexValue
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: log a warning here, somehow?
comment|// DOC ERROR (malformed hex escape):
comment|// ignore
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|// inside control word
case|case
literal|4
case|:
if|if
condition|(
name|isAlpha
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|// still in control word
name|addControl
argument_list|(
operator|(
name|byte
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
comment|// end of control word, start of negative parameter
name|negParam
operator|=
literal|true
expr_stmt|;
name|param
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|// end of control word, start of positive parameter
name|negParam
operator|=
literal|false
expr_stmt|;
name|param
operator|=
call|(
name|long
call|)
argument_list|(
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
condition|)
block|{
comment|// space is consumed as part of the
comment|// control word, but is not added to the
comment|// control word
name|processControlWord
argument_list|()
expr_stmt|;
name|pendingControlCount
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|processControlWord
argument_list|()
expr_stmt|;
name|pendingControlCount
operator|=
literal|0
expr_stmt|;
comment|// eps transition back to start state
name|pushBack
operator|=
name|ch
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|// inside control word's numeric param
case|case
literal|5
case|:
if|if
condition|(
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|param
operator|=
operator|(
literal|10
operator|*
name|param
operator|)
operator|+
call|(
name|long
call|)
argument_list|(
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|negParam
condition|)
block|{
name|param
operator|=
operator|-
name|param
expr_stmt|;
block|}
name|processControlWord
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|pendingControlCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|' '
condition|)
block|{
comment|// space is consumed as part of the
comment|// control word
name|pushBack
operator|=
name|ch
expr_stmt|;
block|}
name|state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"invalid state"
argument_list|)
throw|;
block|}
block|}
name|endParagraph
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|out
operator|.
name|endDocument
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|lazyStartParagraph
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
operator|!
name|inParagraph
condition|)
block|{
comment|// Ensure</i></b> order
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|startElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
comment|// Ensure<b><i> order
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|inParagraph
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|endParagraph
parameter_list|(
name|boolean
name|preserveStyles
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|pushText
argument_list|()
expr_stmt|;
if|if
condition|(
name|inParagraph
condition|)
block|{
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
name|preserveStyles
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|bold
operator|=
name|preserveStyles
expr_stmt|;
block|}
name|out
operator|.
name|endElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserveStyles
operator|&&
operator|(
name|groupState
operator|.
name|bold
operator|||
name|groupState
operator|.
name|italic
operator|)
condition|)
block|{
name|start
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|inParagraph
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|inParagraph
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// Push pending UTF16 units to out ContentHandler
specifier|private
name|void
name|pushChars
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingCharCount
operator|!=
literal|0
condition|)
block|{
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|characters
argument_list|(
name|pendingChars
argument_list|,
literal|0
argument_list|,
name|pendingCharCount
argument_list|)
expr_stmt|;
name|pendingCharCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// Decodes the buffered bytes in pendingBytes
comment|// into UTF16 code units, and sends the characters
comment|// to the out ContentHandler, if we are in the body,
comment|// else appends the characters to the pendingBuffer
specifier|private
name|void
name|pushBytes
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|pendingByteCount
operator|>
literal|0
operator|&&
operator|(
operator|!
name|groupState
operator|.
name|ignore
operator|||
name|nextMetaData
operator|!=
literal|null
operator|)
condition|)
block|{
specifier|final
name|CharsetDecoder
name|decoder
init|=
name|getDecoder
argument_list|()
decl_stmt|;
name|pendingByteBuffer
operator|.
name|limit
argument_list|(
name|pendingByteCount
argument_list|)
expr_stmt|;
assert|assert
name|pendingByteBuffer
operator|.
name|position
argument_list|()
operator|==
literal|0
assert|;
assert|assert
name|outputBuffer
operator|.
name|position
argument_list|()
operator|==
literal|0
assert|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// We pass true for endOfInput because, when
comment|// we are called, we should have seen a
comment|// complete sequence of characters for this
comment|// charset:
specifier|final
name|CoderResult
name|result
init|=
name|decoder
operator|.
name|decode
argument_list|(
name|pendingByteBuffer
argument_list|,
name|outputBuffer
argument_list|,
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|outputBuffer
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|inHeader
operator|||
name|fieldState
operator|==
literal|1
condition|)
block|{
name|pendingBuffer
operator|.
name|append
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|characters
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|outputBuffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|CoderResult
operator|.
name|UNDERFLOW
condition|)
block|{
break|break;
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|CoderResult
name|result
init|=
name|decoder
operator|.
name|flush
argument_list|(
name|outputBuffer
argument_list|)
decl_stmt|;
specifier|final
name|int
name|pos
init|=
name|outputBuffer
operator|.
name|position
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|inHeader
operator|||
name|fieldState
operator|==
literal|1
condition|)
block|{
name|pendingBuffer
operator|.
name|append
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|characters
argument_list|(
name|outputArray
argument_list|,
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|outputBuffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|CoderResult
operator|.
name|UNDERFLOW
condition|)
block|{
break|break;
block|}
block|}
comment|// Reset for next decode
name|decoder
operator|.
name|reset
argument_list|()
expr_stmt|;
name|pendingByteBuffer
operator|.
name|position
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|pendingByteCount
operator|=
literal|0
expr_stmt|;
block|}
comment|// NOTE: s must be ascii alpha only
specifier|private
name|boolean
name|equals
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|pendingControlCount
operator|!=
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|pendingControlCount
condition|;
name|idx
operator|++
control|)
block|{
assert|assert
name|isAlpha
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
argument_list|)
assert|;
if|if
condition|(
operator|(
operator|(
name|byte
operator|)
name|s
operator|.
name|charAt
argument_list|(
name|idx
argument_list|)
operator|)
operator|!=
name|pendingControl
index|[
name|idx
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|processControlSymbol
parameter_list|(
name|char
name|ch
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'~'
case|:
comment|// Non-breaking space -> unicode NON-BREAKING SPACE
name|addOutputChar
argument_list|(
literal|'\u00a0'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|// Ignorable destination (control words defined
comment|// after the 1987 RTF spec).  Note that
comment|// sometimes we un-ignore within this group, eg
comment|// when handling upr escape.
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|// Optional hyphen -> unicode SOFT HYPHEN
name|addOutputChar
argument_list|(
literal|'\u00ad'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|// Non-breaking hyphen -> unicode NON-BREAKING HYPHEN
name|addOutputChar
argument_list|(
literal|'\u2011'
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
specifier|private
name|CharsetDecoder
name|getDecoder
parameter_list|()
throws|throws
name|TikaException
block|{
specifier|final
name|String
name|charset
init|=
name|getCharset
argument_list|()
decl_stmt|;
comment|// Common case: charset is same as last time, so
comment|// just reuse it:
if|if
condition|(
name|lastCharset
operator|==
literal|null
operator|||
operator|!
name|charset
operator|.
name|equals
argument_list|(
name|lastCharset
argument_list|)
condition|)
block|{
name|decoder
operator|=
name|CharsetUtils
operator|.
name|forName
argument_list|(
name|charset
argument_list|)
operator|.
name|newDecoder
argument_list|()
expr_stmt|;
if|if
condition|(
name|decoder
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"cannot find decoder for charset="
operator|+
name|charset
argument_list|)
throw|;
block|}
name|decoder
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
name|decoder
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
name|lastCharset
operator|=
name|charset
expr_stmt|;
block|}
return|return
name|decoder
return|;
block|}
comment|// Return current charset in-use
specifier|private
name|String
name|getCharset
parameter_list|()
throws|throws
name|TikaException
block|{
comment|// If a specific font (fN) was set, use its charset
if|if
condition|(
name|groupState
operator|.
name|fontCharset
operator|!=
literal|null
condition|)
block|{
return|return
name|groupState
operator|.
name|fontCharset
return|;
block|}
comment|// Else, if global default font (defN) was set, use
comment|// that
if|if
condition|(
name|globalDefaultFont
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|inHeader
condition|)
block|{
specifier|final
name|String
name|cs
init|=
name|fontToCharset
operator|.
name|get
argument_list|(
name|globalDefaultFont
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
return|;
block|}
block|}
comment|// Else, use the global charset
if|if
condition|(
name|globalCharset
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"unable to determine charset"
argument_list|)
throw|;
block|}
return|return
name|globalCharset
return|;
block|}
comment|// Handle control word that takes a parameter:
comment|// Param is long because spec says max value is 1+ Integer.MAX_VALUE!
specifier|private
name|void
name|processControlWord
parameter_list|(
name|long
name|param
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
comment|// TODO: afN?  (associated font number)
comment|// TODO: do these alter text output...?
comment|/*             } else if (equals("stshfdbch")) {                 // font to be used by default in                 // style sheet for East Asian chars                 // arg N is font table entry             } else if (equals("stshfloch")) {                 // font to be used by default in                 // style sheet for ASCII chars                 // arg N is font table entry             } else if (equals("stshfhich")) {                 // font to be used by default in                 // style sheet for High Ansi chars                 // arg N is font table entry             } else if (equals("stshfbi")) {                 // style sheet for Complex Scripts (BIDI) chars                 // arg N is font table entry                 */
comment|// TODO: inefficient that we check equals N times;
comment|// we'd get better perf w/ real lexer (eg
comment|// JFlex), which uses single-pass FSM to do cmp:
if|if
condition|(
name|inHeader
condition|)
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"ansicpg"
argument_list|)
condition|)
block|{
comment|// ANSI codepage
specifier|final
name|String
name|cs
init|=
name|ANSICPG_MAP
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|globalCharset
operator|=
name|cs
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"deff"
argument_list|)
condition|)
block|{
comment|// Default font
name|globalDefaultFont
operator|=
operator|(
name|int
operator|)
name|param
expr_stmt|;
block|}
if|if
condition|(
name|fontTableState
operator|==
literal|1
condition|)
block|{
comment|// Still inside font table -- record the
comment|// mappings of fN to the fcharset:
if|if
condition|(
name|groupState
operator|.
name|depth
operator|<
name|fontTableDepth
condition|)
block|{
name|fontTableState
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"f"
argument_list|)
condition|)
block|{
comment|// Start new font definition
name|curFontID
operator|=
operator|(
name|int
operator|)
name|param
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"fcharset"
argument_list|)
condition|)
block|{
specifier|final
name|String
name|cs
init|=
name|FCHARSET_MAP
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|fontToCharset
operator|.
name|put
argument_list|(
name|curFontID
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|// In document
if|if
condition|(
name|equals
argument_list|(
literal|"b"
argument_list|)
condition|)
block|{
comment|// b0
assert|assert
name|param
operator|==
literal|0
assert|;
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|groupState
operator|.
name|bold
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"i"
argument_list|)
condition|)
block|{
comment|// i0
assert|assert
name|param
operator|==
literal|0
assert|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"f"
argument_list|)
condition|)
block|{
comment|// Change current font
specifier|final
name|String
name|fontCharset
init|=
name|fontToCharset
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|param
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontCharset
operator|!=
literal|null
condition|)
block|{
name|groupState
operator|.
name|fontCharset
operator|=
name|fontCharset
expr_stmt|;
block|}
else|else
block|{
comment|// DOC ERROR: font change referenced a
comment|// non-table'd font number
comment|// TODO: log a warning?  Throw an exc?
name|groupState
operator|.
name|fontCharset
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|// Process unicode escape.  This can appear in doc
comment|// or in header, since the metadata (info) fields
comment|// in the header can be unicode escaped as well:
if|if
condition|(
name|pendingControl
index|[
literal|0
index|]
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|pendingControlCount
operator|==
literal|1
condition|)
block|{
comment|// Unicode escape
if|if
condition|(
operator|!
name|groupState
operator|.
name|ignore
condition|)
block|{
specifier|final
name|char
name|utf16CodeUnit
init|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|param
operator|)
operator|&
literal|0xffff
argument_list|)
decl_stmt|;
name|addOutputChar
argument_list|(
name|utf16CodeUnit
argument_list|)
expr_stmt|;
block|}
comment|// After seeing a unicode escape we must
comment|// skip the next ucSkip ansi chars (the
comment|// "unicode shadow")
name|ansiSkip
operator|=
name|groupState
operator|.
name|ucSkip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pendingControlCount
operator|==
literal|2
operator|&&
name|pendingControl
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
comment|// Change unicode shadow length
name|groupState
operator|.
name|ucSkip
operator|=
operator|(
name|int
operator|)
name|param
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|end
parameter_list|(
name|String
name|tag
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|out
operator|.
name|endElement
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|start
parameter_list|(
name|String
name|tag
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|out
operator|.
name|startElement
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
comment|// Handle non-parameter control word:
specifier|private
name|void
name|processControlWord
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|inHeader
condition|)
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"ansi"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
literal|"cp1252"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"pca"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
literal|"cp850"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"pc"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
literal|"cp437"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"mac"
argument_list|)
condition|)
block|{
name|globalCharset
operator|=
literal|"MacRoman"
expr_stmt|;
block|}
if|if
condition|(
name|equals
argument_list|(
literal|"colortbl"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"stylesheet"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"fonttbl"
argument_list|)
condition|)
block|{
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|uprState
operator|==
operator|-
literal|1
condition|)
block|{
comment|// TODO: we can also parse \creatim, \revtim,
comment|// \printim, \version, \nofpages, \nofwords,
comment|// \nofchars, etc.
if|if
condition|(
name|equals
argument_list|(
literal|"author"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|AUTHOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"title"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|TITLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"subject"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|SUBJECT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"keywords"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|KEYWORDS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"category"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|CATEGORY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"comment"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|COMMENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"company"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|COMPANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"manager"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|MANAGER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"template"
argument_list|)
condition|)
block|{
name|nextMetaData
operator|=
name|Metadata
operator|.
name|TEMPLATE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fontTableState
operator|==
literal|0
condition|)
block|{
comment|// Didn't see font table yet
if|if
condition|(
name|equals
argument_list|(
literal|"fonttbl"
argument_list|)
condition|)
block|{
name|fontTableState
operator|=
literal|1
expr_stmt|;
name|fontTableDepth
operator|=
name|groupState
operator|.
name|depth
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fontTableState
operator|==
literal|1
condition|)
block|{
comment|// Inside font table
if|if
condition|(
name|groupState
operator|.
name|depth
operator|<
name|fontTableDepth
condition|)
block|{
name|fontTableState
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|groupState
operator|.
name|ignore
operator|&&
operator|(
name|equals
argument_list|(
literal|"par"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"pard"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"sect"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"sectd"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"plain"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"ltrch"
argument_list|)
operator|||
name|equals
argument_list|(
literal|"rtlch"
argument_list|)
operator|)
condition|)
block|{
name|inHeader
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|equals
argument_list|(
literal|"b"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|groupState
operator|.
name|bold
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|lazyStartParagraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
comment|// Make sure nesting is always<b><i>
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|groupState
operator|.
name|bold
operator|=
literal|true
expr_stmt|;
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"i"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|groupState
operator|.
name|italic
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|true
expr_stmt|;
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|equals
argument_list|(
literal|"pard"
argument_list|)
condition|)
block|{
comment|// Reset styles
name|pushText
argument_list|()
expr_stmt|;
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|groupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|bold
operator|=
literal|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"par"
argument_list|)
condition|)
block|{
name|endParagraph
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"shptxt"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Text inside a shape
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"atnid"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Annotation ID
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"atnauthor"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Annotation author
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"annotation"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// Annotation
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"cell"
argument_list|)
condition|)
block|{
comment|// TODO: we should produce a table output here?
comment|//addOutputChar(' ');
name|endParagraph
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"pict"
argument_list|)
condition|)
block|{
name|pushText
argument_list|()
expr_stmt|;
comment|// TODO: create img tag?  but can that support
comment|// embedded image data?
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"line"
argument_list|)
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"column"
argument_list|)
condition|)
block|{
name|addOutputChar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"page"
argument_list|)
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"softline"
argument_list|)
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"softcolumn"
argument_list|)
condition|)
block|{
name|addOutputChar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"softpage"
argument_list|)
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"tab"
argument_list|)
condition|)
block|{
name|addOutputChar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"upr"
argument_list|)
condition|)
block|{
name|uprState
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"ud"
argument_list|)
operator|&&
name|uprState
operator|==
literal|1
condition|)
block|{
name|uprState
operator|=
operator|-
literal|1
expr_stmt|;
comment|// 2nd group inside the upr destination, which
comment|// contains the unicode encoding of the text, so
comment|// we want to keep that:
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"bullet"
argument_list|)
condition|)
block|{
comment|// unicode BULLET
name|addOutputChar
argument_list|(
literal|'\u2022'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"endash"
argument_list|)
condition|)
block|{
comment|// unicode EN DASH
name|addOutputChar
argument_list|(
literal|'\u2013'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"emdash"
argument_list|)
condition|)
block|{
comment|// unicode EM DASH
name|addOutputChar
argument_list|(
literal|'\u2014'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"enspace"
argument_list|)
condition|)
block|{
comment|// unicode EN SPACE
name|addOutputChar
argument_list|(
literal|'\u2002'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"qmspace"
argument_list|)
condition|)
block|{
comment|// quarter em space -> unicode FOUR-PER-EM SPACE
name|addOutputChar
argument_list|(
literal|'\u2005'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"emspace"
argument_list|)
condition|)
block|{
comment|// unicode EM SPACE
name|addOutputChar
argument_list|(
literal|'\u2003'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"lquote"
argument_list|)
condition|)
block|{
comment|// unicode LEFT SINGLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u2018'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"rquote"
argument_list|)
condition|)
block|{
comment|// unicode RIGHT SINGLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u2019'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"ldblquote"
argument_list|)
condition|)
block|{
comment|// unicode LEFT DOUBLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u201C'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"rdblquote"
argument_list|)
condition|)
block|{
comment|// unicode RIGHT DOUBLE QUOTATION MARK
name|addOutputChar
argument_list|(
literal|'\u201D'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"fldinst"
argument_list|)
condition|)
block|{
name|fieldState
operator|=
literal|1
expr_stmt|;
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
argument_list|(
literal|"fldrslt"
argument_list|)
operator|&&
name|fieldState
operator|==
literal|2
condition|)
block|{
assert|assert
name|pendingURL
operator|!=
literal|null
assert|;
name|lazyStartParagraph
argument_list|()
expr_stmt|;
name|out
operator|.
name|startElement
argument_list|(
literal|"a"
argument_list|,
literal|"href"
argument_list|,
name|pendingURL
argument_list|)
expr_stmt|;
name|pendingURL
operator|=
literal|null
expr_stmt|;
name|fieldState
operator|=
literal|3
expr_stmt|;
name|groupState
operator|.
name|ignore
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Push new GroupState
specifier|private
name|void
name|processGroupStart
parameter_list|()
throws|throws
name|IOException
block|{
name|ansiSkip
operator|=
literal|0
expr_stmt|;
comment|// Push current groupState onto the stack
name|groupStates
operator|.
name|add
argument_list|(
name|groupState
argument_list|)
expr_stmt|;
comment|// Make new GroupState
name|groupState
operator|=
operator|new
name|GroupState
argument_list|(
name|groupState
argument_list|)
expr_stmt|;
assert|assert
name|groupStates
operator|.
name|size
argument_list|()
operator|==
name|groupState
operator|.
name|depth
operator|:
literal|"size="
operator|+
name|groupStates
operator|.
name|size
argument_list|()
operator|+
literal|" depth="
operator|+
name|groupState
operator|.
name|depth
assert|;
if|if
condition|(
name|uprState
operator|==
literal|0
condition|)
block|{
name|uprState
operator|=
literal|1
expr_stmt|;
name|groupState
operator|.
name|ignore
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Pop current GroupState
specifier|private
name|void
name|processGroupEnd
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
if|if
condition|(
name|inHeader
condition|)
block|{
if|if
condition|(
name|nextMetaData
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
name|nextMetaData
argument_list|,
name|pendingBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|nextMetaData
operator|=
literal|null
expr_stmt|;
block|}
name|pendingBuffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
assert|assert
name|groupState
operator|.
name|depth
operator|>
literal|0
assert|;
name|ansiSkip
operator|=
literal|0
expr_stmt|;
comment|// Restore group state:
specifier|final
name|GroupState
name|outerGroupState
init|=
name|groupStates
operator|.
name|removeLast
argument_list|()
decl_stmt|;
comment|// Close italic, if outer does not have italic or
comment|// bold changed:
if|if
condition|(
name|groupState
operator|.
name|italic
condition|)
block|{
if|if
condition|(
operator|!
name|outerGroupState
operator|.
name|italic
operator|||
name|groupState
operator|.
name|bold
operator|!=
name|outerGroupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
name|groupState
operator|.
name|italic
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Close bold
if|if
condition|(
name|groupState
operator|.
name|bold
operator|&&
operator|!
name|outerGroupState
operator|.
name|bold
condition|)
block|{
name|end
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
comment|// Open bold
if|if
condition|(
operator|!
name|groupState
operator|.
name|bold
operator|&&
name|outerGroupState
operator|.
name|bold
condition|)
block|{
name|start
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
block|}
comment|// Open italic
if|if
condition|(
operator|!
name|groupState
operator|.
name|italic
operator|&&
name|outerGroupState
operator|.
name|italic
condition|)
block|{
name|start
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
block|}
name|groupState
operator|=
name|outerGroupState
expr_stmt|;
assert|assert
name|groupStates
operator|.
name|size
argument_list|()
operator|==
name|groupState
operator|.
name|depth
assert|;
if|if
condition|(
name|fieldState
operator|==
literal|1
condition|)
block|{
name|String
name|s
init|=
name|pendingBuffer
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|pendingBuffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"HYPERLINK"
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
comment|// TODO: what other instructions can be in a
comment|// HYPERLINK destination?
specifier|final
name|boolean
name|isLocalLink
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|"\\l "
argument_list|)
operator|!=
operator|-
literal|1
decl_stmt|;
name|int
name|idx
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|idx2
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'"'
argument_list|,
literal|1
operator|+
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx2
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|1
operator|+
name|idx
argument_list|,
name|idx2
argument_list|)
expr_stmt|;
block|}
block|}
name|pendingURL
operator|=
operator|(
name|isLocalLink
condition|?
literal|"#"
else|:
literal|""
operator|)
operator|+
name|s
expr_stmt|;
name|fieldState
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fieldState
operator|=
literal|0
expr_stmt|;
block|}
comment|// TODO: we could process the other known field
comment|// types.  Right now, we will extract their text
comment|// inlined, but fail to record them in metadata
comment|// as a field value.
block|}
elseif|else
if|if
condition|(
name|fieldState
operator|==
literal|3
condition|)
block|{
name|out
operator|.
name|endElement
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|fieldState
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

