begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * ******************************************************************************  * Copyright (C) 2005-2009, International Business Machines Corporation and    *  * others. All Rights Reserved.                                                *  * ******************************************************************************  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|txt
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_comment
comment|/**  *<code>CharsetDetector</code> provides a facility for detecting the  * charset or encoding of character data in an unknown format.  * The input data can either be from an input stream or an array of bytes.  * The result of the detection operation is a list of possibly matching  * charsets, or, for simple use, you can just ask for a Java Reader that  * will will work over the input data.  *<p/>  * Character set detection is at best an imprecise operation.  The detection  * process will attempt to identify the charset that best matches the characteristics  * of the byte data, but the process is partly statistical in nature, and  * the results can not be guaranteed to always be correct.  *<p/>  * For best accuracy in charset detection, the input data should be primarily  * in a single language, and a minimum of a few hundred bytes worth of plain text  * in the language are needed.  The detection process will attempt to  * ignore html or xml style markup that could otherwise obscure the content.  *<p/>  * @stable ICU 3.4  */
end_comment

begin_class
specifier|public
class|class
name|CharsetDetector
block|{
comment|//   Question: Should we have getters corresponding to the setters for input text
comment|//   and declared encoding?
comment|//   A thought: If we were to create our own type of Java Reader, we could defer
comment|//   figuring out an actual charset for data that starts out with too much English
comment|//   only ASCII until the user actually read through to something that didn't look
comment|//   like 7 bit English.  If  nothing else ever appeared, we would never need to
comment|//   actually choose the "real" charset.  All assuming that the application just
comment|//   wants the data, and doesn't care about a char set name.
specifier|private
specifier|static
specifier|final
name|int
name|kBufSize
init|=
literal|12000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_CONFIDENCE
init|=
literal|100
decl_stmt|;
specifier|private
specifier|static
name|String
index|[]
name|fCharsetNames
decl_stmt|;
comment|/*      * List of recognizers for all charsets known to the implementation.      */
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|CharsetRecognizer
argument_list|>
name|fCSRecognizers
init|=
name|createRecognizers
argument_list|()
decl_stmt|;
comment|/*      *  The following items are accessed by individual CharsetRecongizers during      *     the recognition process      *      */
name|byte
index|[]
name|fInputBytes
init|=
comment|// The text to be checked.  Markup will have been
operator|new
name|byte
index|[
name|kBufSize
index|]
decl_stmt|;
comment|//   removed if appropriate.
name|int
name|fInputLen
decl_stmt|;
comment|// Length of the byte data in fInputText.
name|short
name|fByteStats
index|[]
init|=
comment|// byte frequency statistics for the input text.
operator|new
name|short
index|[
literal|256
index|]
decl_stmt|;
comment|//   Value is percent, not absolute.
name|boolean
name|fC1Bytes
init|=
comment|// True if any bytes in the range 0x80 - 0x9F are in the input;
literal|false
decl_stmt|;
name|String
name|fDeclaredEncoding
decl_stmt|;
comment|//
comment|//  Stuff private to CharsetDetector
comment|//
name|byte
index|[]
name|fRawInput
decl_stmt|;
comment|// Original, untouched input bytes.
comment|//  If user gave us a byte array, this is it.
comment|//  If user gave us a stream, it's read to a
comment|//  buffer here.
name|int
name|fRawLength
decl_stmt|;
comment|// Length of data in fRawInput array.
name|InputStream
name|fInputStream
decl_stmt|;
comment|// User's input stream, or null if the user
name|boolean
name|fStripTags
init|=
comment|// If true, setText() will strip tags from input text.
literal|false
decl_stmt|;
comment|/**      *   Constructor      *      * @stable ICU 3.4      */
specifier|public
name|CharsetDetector
parameter_list|()
block|{     }
comment|/**      * Get the names of all char sets that can be recognized by the char set detector.      *      * @return an array of the names of all charsets that can be recognized      * by the charset detector.      *      * @stable ICU 3.4      */
specifier|public
specifier|static
name|String
index|[]
name|getAllDetectableCharsets
parameter_list|()
block|{
return|return
name|fCharsetNames
return|;
block|}
comment|/*      * Create the singleton instances of the CharsetRecognizer classes      */
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|CharsetRecognizer
argument_list|>
name|createRecognizers
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|CharsetRecognizer
argument_list|>
name|recognizers
init|=
operator|new
name|ArrayList
argument_list|<
name|CharsetRecognizer
argument_list|>
argument_list|()
decl_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_UTF8
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_Unicode
operator|.
name|CharsetRecog_UTF_16_BE
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_Unicode
operator|.
name|CharsetRecog_UTF_16_LE
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_Unicode
operator|.
name|CharsetRecog_UTF_32_BE
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_Unicode
operator|.
name|CharsetRecog_UTF_32_LE
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_mbcs
operator|.
name|CharsetRecog_sjis
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_2022
operator|.
name|CharsetRecog_2022JP
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_2022
operator|.
name|CharsetRecog_2022CN
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_2022
operator|.
name|CharsetRecog_2022KR
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_mbcs
operator|.
name|CharsetRecog_euc
operator|.
name|CharsetRecog_gb_18030
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_mbcs
operator|.
name|CharsetRecog_euc
operator|.
name|CharsetRecog_euc_jp
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_mbcs
operator|.
name|CharsetRecog_euc
operator|.
name|CharsetRecog_euc_kr
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_mbcs
operator|.
name|CharsetRecog_big5
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_da
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_de
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_en
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_es
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_fr
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_it
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_nl
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_no
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_pt
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_1_sv
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_2_cs
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_2_hu
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_2_pl
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_2_ro
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_5_ru
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_6_ar
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_7_el
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_8_I_he
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_8_he
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_windows_1251
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_windows_1256
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_KOI8_R
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_8859_9_tr
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_IBM424_he_rtl
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_IBM424_he_ltr
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_IBM420_ar_rtl
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_IBM420_ar_ltr
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_EBCDIC_500_en
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_EBCDIC_500_de
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_EBCDIC_500_es
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_EBCDIC_500_fr
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_EBCDIC_500_it
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_EBCDIC_500_nl
argument_list|()
argument_list|)
expr_stmt|;
name|recognizers
operator|.
name|add
argument_list|(
operator|new
name|CharsetRecog_sbcs
operator|.
name|CharsetRecog_IBM866_ru
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create an array of all charset names, as a side effect.
comment|// Needed for the getAllDetectableCharsets() API.
name|String
index|[]
name|charsetNames
init|=
operator|new
name|String
index|[
name|recognizers
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|out
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CharsetRecognizer
name|recognizer
range|:
name|recognizers
control|)
block|{
name|String
name|name
init|=
name|recognizer
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|out
operator|==
literal|0
operator|||
operator|!
name|name
operator|.
name|equals
argument_list|(
name|charsetNames
index|[
name|out
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|charsetNames
index|[
name|out
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
block|}
name|fCharsetNames
operator|=
operator|new
name|String
index|[
name|out
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|charsetNames
argument_list|,
literal|0
argument_list|,
name|fCharsetNames
argument_list|,
literal|0
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|recognizers
return|;
block|}
comment|/**      * Set the declared encoding for charset detection.      *  The declared encoding of an input text is an encoding obtained      *  from an http header or xml declaration or similar source that      *  can be provided as additional information to the charset detector.      *  A match between a declared encoding and a possible detected encoding      *  will raise the quality of that detected encoding by a small delta,      *  and will also appear as a "reason" for the match.      *<p/>      * A declared encoding that is incompatible with the input data being      * analyzed will not be added to the list of possible encodings.      *      *  @param encoding The declared encoding      *      * @stable ICU 3.4      */
specifier|public
name|CharsetDetector
name|setDeclaredEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
name|setCanonicalDeclaredEncoding
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Set the input text (byte) data whose charset is to be detected.      *      * @param in the input text of unknown encoding      *      * @return This CharsetDetector      *      * @stable ICU 3.4      */
specifier|public
name|CharsetDetector
name|setText
parameter_list|(
name|byte
index|[]
name|in
parameter_list|)
block|{
name|fRawInput
operator|=
name|in
expr_stmt|;
name|fRawLength
operator|=
name|in
operator|.
name|length
expr_stmt|;
name|MungeInput
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
comment|//   Value is rounded up, so zero really means zero occurences.
comment|/**      * Set the input text (byte) data whose charset is to be detected.      *<p/>      *   The input stream that supplies the character data must have markSupported()      *   == true; the charset detection process will read a small amount of data,      *   then return the stream to its original position via      *   the InputStream.reset() operation.  The exact amount that will      *   be read depends on the characteristics of the data itself.      *      * @param in the input text of unknown encoding      *      * @return This CharsetDetector      *      * @stable ICU 3.4      */
specifier|public
name|CharsetDetector
name|setText
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|fInputStream
operator|=
name|in
expr_stmt|;
name|fInputStream
operator|.
name|mark
argument_list|(
name|kBufSize
argument_list|)
expr_stmt|;
name|fRawInput
operator|=
operator|new
name|byte
index|[
name|kBufSize
index|]
expr_stmt|;
comment|// Always make a new buffer because the
comment|//   previous one may have come from the caller,
comment|//   in which case we can't touch it.
name|fRawLength
operator|=
literal|0
expr_stmt|;
name|int
name|remainingLength
init|=
name|kBufSize
decl_stmt|;
while|while
condition|(
name|remainingLength
operator|>
literal|0
condition|)
block|{
comment|// read() may give data in smallish chunks, esp. for remote sources.  Hence, this loop.
name|int
name|bytesRead
init|=
name|fInputStream
operator|.
name|read
argument_list|(
name|fRawInput
argument_list|,
name|fRawLength
argument_list|,
name|remainingLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|fRawLength
operator|+=
name|bytesRead
expr_stmt|;
name|remainingLength
operator|-=
name|bytesRead
expr_stmt|;
block|}
name|fInputStream
operator|.
name|reset
argument_list|()
expr_stmt|;
name|MungeInput
argument_list|()
expr_stmt|;
comment|// Strip html markup, collect byte stats.
return|return
name|this
return|;
block|}
comment|/**      * Return the charset that best matches the supplied input data.      *      * Note though, that because the detection      * only looks at the start of the input data,      * there is a possibility that the returned charset will fail to handle      * the full set of input data.      *<p/>      * Raise an exception if      *<ul>      *<li>no charset appears to match the data.</li>      *<li>no input text has been provided</li>      *</ul>      *      * @return a CharsetMatch object representing the best matching charset, or      *<code>null</code> if there are no matches.      *      * @stable ICU 3.4      */
specifier|public
name|CharsetMatch
name|detect
parameter_list|()
block|{
comment|//   TODO:  A better implementation would be to copy the detect loop from
comment|//          detectAll(), and cut it short as soon as a match with a high confidence
comment|//          is found.  This is something to be done later, after things are otherwise
comment|//          working.
name|CharsetMatch
name|matches
index|[]
init|=
name|detectAll
argument_list|()
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|null
operator|||
name|matches
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|matches
index|[
literal|0
index|]
return|;
block|}
comment|/**      *  Return an array of all charsets that appear to be plausible      *  matches with the input data.  The array is ordered with the      *  best quality match first.      *<p/>      * Raise an exception if      *<ul>      *<li>no charsets appear to match the input data.</li>      *<li>no input text has been provided</li>      *</ul>      *      * @return An array of CharsetMatch objects representing possibly matching charsets.      *      * @stable ICU 3.4      */
specifier|public
name|CharsetMatch
index|[]
name|detectAll
parameter_list|()
block|{
name|CharsetRecognizer
name|csr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|detectResults
decl_stmt|;
name|int
name|confidence
decl_stmt|;
name|ArrayList
argument_list|<
name|CharsetMatch
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<
name|CharsetMatch
argument_list|>
argument_list|()
decl_stmt|;
comment|//  Iterate over all possible charsets, remember all that
comment|//    give a match quality> 0.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fCSRecognizers
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|csr
operator|=
name|fCSRecognizers
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|detectResults
operator|=
name|csr
operator|.
name|match
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|confidence
operator|=
name|detectResults
operator|&
literal|0x000000ff
expr_stmt|;
if|if
condition|(
name|confidence
operator|>
literal|0
condition|)
block|{
comment|// Just to be safe, constrain
name|confidence
operator|=
name|Math
operator|.
name|min
argument_list|(
name|confidence
argument_list|,
name|MAX_CONFIDENCE
argument_list|)
expr_stmt|;
comment|// Apply charset hint.
if|if
condition|(
operator|(
name|fDeclaredEncoding
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|fDeclaredEncoding
operator|.
name|equalsIgnoreCase
argument_list|(
name|csr
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
comment|// Reduce lack of confidence (delta between "sure" and current) by 50%.
name|confidence
operator|+=
operator|(
name|MAX_CONFIDENCE
operator|-
name|confidence
operator|)
operator|/
literal|2
expr_stmt|;
block|}
name|CharsetMatch
name|m
init|=
operator|new
name|CharsetMatch
argument_list|(
name|this
argument_list|,
name|csr
argument_list|,
name|confidence
argument_list|)
decl_stmt|;
name|matches
operator|.
name|add
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|matches
argument_list|)
expr_stmt|;
comment|// CharsetMatch compares on confidence
name|Collections
operator|.
name|reverse
argument_list|(
name|matches
argument_list|)
expr_stmt|;
comment|//  Put best match first.
name|CharsetMatch
index|[]
name|resultArray
init|=
operator|new
name|CharsetMatch
index|[
name|matches
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|resultArray
operator|=
name|matches
operator|.
name|toArray
argument_list|(
name|resultArray
argument_list|)
expr_stmt|;
return|return
name|resultArray
return|;
block|}
comment|/**      * Autodetect the charset of an inputStream, and return a Java Reader      * to access the converted input data.      *<p/>      * This is a convenience method that is equivalent to      *<code>this.setDeclaredEncoding(declaredEncoding).setText(in).detect().getReader();</code>      *<p/>      *   For the input stream that supplies the character data, markSupported()      *   must be true; the  charset detection will read a small amount of data,      *   then return the stream to its original position via      *   the InputStream.reset() operation.  The exact amount that will      *    be read depends on the characteristics of the data itself.      *<p/>      * Raise an exception if no charsets appear to match the input data.      *      * @param in The source of the byte data in the unknown charset.      *      * @param declaredEncoding  A declared encoding for the data, if available,      *           or null or an empty string if none is available.      *      * @stable ICU 3.4      */
specifier|public
name|Reader
name|getReader
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|String
name|declaredEncoding
parameter_list|)
block|{
name|setCanonicalDeclaredEncoding
argument_list|(
name|declaredEncoding
argument_list|)
expr_stmt|;
try|try
block|{
name|setText
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|CharsetMatch
name|match
init|=
name|detect
argument_list|()
decl_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|match
operator|.
name|getReader
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Autodetect the charset of an inputStream, and return a String      * containing the converted input data.      *<p/>      * This is a convenience method that is equivalent to      *<code>this.setDeclaredEncoding(declaredEncoding).setText(in).detect().getString();</code>      *<p/>      * Raise an exception if no charsets appear to match the input data.      *      * @param in The source of the byte data in the unknown charset.      *      * @param declaredEncoding  A declared encoding for the data, if available,      *           or null or an empty string if none is available.      *      * @stable ICU 3.4      */
specifier|public
name|String
name|getString
parameter_list|(
name|byte
index|[]
name|in
parameter_list|,
name|String
name|declaredEncoding
parameter_list|)
block|{
name|setCanonicalDeclaredEncoding
argument_list|(
name|declaredEncoding
argument_list|)
expr_stmt|;
try|try
block|{
name|setText
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|CharsetMatch
name|match
init|=
name|detect
argument_list|()
decl_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|match
operator|.
name|getString
argument_list|(
operator|-
literal|1
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|//   gave us a byte array.
comment|/**      * Test whether or not input filtering is enabled.      *      * @return<code>true</code> if input text will be filtered.      *      * @see #enableInputFilter      *      * @stable ICU 3.4      */
specifier|public
name|boolean
name|inputFilterEnabled
parameter_list|()
block|{
return|return
name|fStripTags
return|;
block|}
comment|/**      * Enable filtering of input text. If filtering is enabled,      * text within angle brackets ("<" and ">") will be removed      * before detection.      *      * @param filter<code>true</code> to enable input text filtering.      *      * @return The previous setting.      *      * @stable ICU 3.4      */
specifier|public
name|boolean
name|enableInputFilter
parameter_list|(
name|boolean
name|filter
parameter_list|)
block|{
name|boolean
name|previous
init|=
name|fStripTags
decl_stmt|;
name|fStripTags
operator|=
name|filter
expr_stmt|;
return|return
name|previous
return|;
block|}
comment|/**      * Try to set fDeclaredEncoding to the canonical name for<encoding>, if it exists.      *      * @param encoding - name of character encoding      */
specifier|private
name|void
name|setCanonicalDeclaredEncoding
parameter_list|(
name|String
name|encoding
parameter_list|)
block|{
if|if
condition|(
operator|(
name|encoding
operator|==
literal|null
operator|)
operator|||
name|encoding
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Charset
name|cs
init|=
name|Charset
operator|.
name|forName
argument_list|(
name|encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|fDeclaredEncoding
operator|=
name|cs
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*      *  MungeInput - after getting a set of raw input data to be analyzed, preprocess      *               it by removing what appears to be html markup.      */
specifier|private
name|void
name|MungeInput
parameter_list|()
block|{
name|int
name|srci
init|=
literal|0
decl_stmt|;
name|int
name|dsti
init|=
literal|0
decl_stmt|;
name|byte
name|b
decl_stmt|;
name|boolean
name|inMarkup
init|=
literal|false
decl_stmt|;
name|int
name|openTags
init|=
literal|0
decl_stmt|;
name|int
name|badTags
init|=
literal|0
decl_stmt|;
comment|//
comment|//  html / xml markup stripping.
comment|//     quick and dirty, not 100% accurate, but hopefully good enough, statistically.
comment|//     discard everything within< brackets>
comment|//     Count how many total '<' and illegal (nested) '<' occur, so we can make some
comment|//     guess as to whether the input was actually marked up at all.
if|if
condition|(
name|fStripTags
condition|)
block|{
for|for
control|(
name|srci
operator|=
literal|0
init|;
name|srci
operator|<
name|fRawLength
operator|&&
name|dsti
operator|<
name|fInputBytes
operator|.
name|length
condition|;
name|srci
operator|++
control|)
block|{
name|b
operator|=
name|fRawInput
index|[
name|srci
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
operator|(
name|byte
operator|)
literal|'<'
condition|)
block|{
if|if
condition|(
name|inMarkup
condition|)
block|{
name|badTags
operator|++
expr_stmt|;
block|}
name|inMarkup
operator|=
literal|true
expr_stmt|;
name|openTags
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inMarkup
condition|)
block|{
name|fInputBytes
index|[
name|dsti
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
operator|(
name|byte
operator|)
literal|'>'
condition|)
block|{
name|inMarkup
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|fInputLen
operator|=
name|dsti
expr_stmt|;
block|}
comment|//
comment|//  If it looks like this input wasn't marked up, or if it looks like it's
comment|//    essentially nothing but markup abandon the markup stripping.
comment|//    Detection will have to work on the unstripped input.
comment|//
if|if
condition|(
name|openTags
operator|<
literal|5
operator|||
name|openTags
operator|/
literal|5
operator|<
name|badTags
operator|||
operator|(
name|fInputLen
argument_list|<
literal|100
operator|&&
name|fRawLength
argument_list|>
literal|600
operator|)
condition|)
block|{
name|int
name|limit
init|=
name|fRawLength
decl_stmt|;
if|if
condition|(
name|limit
operator|>
name|kBufSize
condition|)
block|{
name|limit
operator|=
name|kBufSize
expr_stmt|;
block|}
for|for
control|(
name|srci
operator|=
literal|0
init|;
name|srci
operator|<
name|limit
condition|;
name|srci
operator|++
control|)
block|{
name|fInputBytes
index|[
name|srci
index|]
operator|=
name|fRawInput
index|[
name|srci
index|]
expr_stmt|;
block|}
name|fInputLen
operator|=
name|srci
expr_stmt|;
block|}
comment|//
comment|// Tally up the byte occurence statistics.
comment|//   These are available for use by the various detectors.
comment|//
name|Arrays
operator|.
name|fill
argument_list|(
name|fByteStats
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|srci
operator|=
literal|0
init|;
name|srci
operator|<
name|fInputLen
condition|;
name|srci
operator|++
control|)
block|{
name|int
name|val
init|=
name|fInputBytes
index|[
name|srci
index|]
operator|&
literal|0x00ff
decl_stmt|;
name|fByteStats
index|[
name|val
index|]
operator|++
expr_stmt|;
block|}
name|fC1Bytes
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0x80
init|;
name|i
operator|<=
literal|0x9F
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|fByteStats
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|fC1Bytes
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_class

end_unit

