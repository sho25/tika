begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|pkg
package|;
end_package

begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveStreamFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveStreamProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|StreamingNotSupportedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ar
operator|.
name|ArArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ar
operator|.
name|ArArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|arj
operator|.
name|ArjArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|cpio
operator|.
name|CpioArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|cpio
operator|.
name|CpioArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|dump
operator|.
name|DumpArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|jar
operator|.
name|JarArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|jar
operator|.
name|JarArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|sevenz
operator|.
name|SevenZFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|tar
operator|.
name|TarArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|tar
operator|.
name|TarArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|ServiceLoaderIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**  * This is a temporary copy/paste hack from commons-compress for Tika 1.15  * that 1) allows detection without initialization of a stream and  * 2) prevents easily preventable OOM on three file formats.  *  * Once commons-compress 1.14 is released, we will delete this class  * and go back to commons-compress's CompressorStreamFactory.  */
end_comment

begin_class
annotation|@
name|Deprecated
class|class
name|TikaArchiveStreamFactory
implements|implements
name|ArchiveStreamProvider
block|{
specifier|private
specifier|static
specifier|final
name|int
name|TAR_HEADER_SIZE
init|=
literal|512
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DUMP_SIGNATURE_SIZE
init|=
literal|32
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SIGNATURE_SIZE
init|=
literal|12
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ArchiveStreamFactory
name|SINGLETON
init|=
operator|new
name|ArchiveStreamFactory
argument_list|()
decl_stmt|;
comment|/**      * Constant (value {@value}) used to identify the AR archive format.      * @since 1.1      */
specifier|public
specifier|static
specifier|final
name|String
name|AR
init|=
literal|"ar"
decl_stmt|;
comment|/**      * Constant (value {@value}) used to identify the ARJ archive format.      * Not supported as an output stream type.      * @since 1.6      */
specifier|public
specifier|static
specifier|final
name|String
name|ARJ
init|=
literal|"arj"
decl_stmt|;
comment|/**      * Constant (value {@value}) used to identify the CPIO archive format.      * @since 1.1      */
specifier|public
specifier|static
specifier|final
name|String
name|CPIO
init|=
literal|"cpio"
decl_stmt|;
comment|/**      * Constant (value {@value}) used to identify the Unix DUMP archive format.      * Not supported as an output stream type.      * @since 1.3      */
specifier|public
specifier|static
specifier|final
name|String
name|DUMP
init|=
literal|"dump"
decl_stmt|;
comment|/**      * Constant (value {@value}) used to identify the JAR archive format.      * @since 1.1      */
specifier|public
specifier|static
specifier|final
name|String
name|JAR
init|=
literal|"jar"
decl_stmt|;
comment|/**      * Constant used to identify the TAR archive format.      * @since 1.1      */
specifier|public
specifier|static
specifier|final
name|String
name|TAR
init|=
literal|"tar"
decl_stmt|;
comment|/**      * Constant (value {@value}) used to identify the ZIP archive format.      * @since 1.1      */
specifier|public
specifier|static
specifier|final
name|String
name|ZIP
init|=
literal|"zip"
decl_stmt|;
comment|/**      * Constant (value {@value}) used to identify the 7z archive format.      * @since 1.8      */
specifier|public
specifier|static
specifier|final
name|String
name|SEVEN_Z
init|=
literal|"7z"
decl_stmt|;
comment|/**      * Entry encoding, null for the platform default.      */
specifier|private
specifier|final
name|String
name|encoding
decl_stmt|;
comment|/**      * Entry encoding, null for the default.      */
specifier|private
specifier|volatile
name|String
name|entryEncoding
decl_stmt|;
specifier|private
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|archiveInputStreamProviders
decl_stmt|;
specifier|private
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|archiveOutputStreamProviders
decl_stmt|;
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|ArchiveStreamProvider
argument_list|>
name|findArchiveStreamProviders
parameter_list|()
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
name|serviceLoaderIterator
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|void
name|putAll
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|names
parameter_list|,
name|ArchiveStreamProvider
name|provider
parameter_list|,
name|TreeMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|toKey
argument_list|(
name|name
argument_list|)
argument_list|,
name|provider
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|Iterator
argument_list|<
name|ArchiveStreamProvider
argument_list|>
name|serviceLoaderIterator
parameter_list|()
block|{
return|return
operator|new
name|ServiceLoaderIterator
argument_list|<>
argument_list|(
name|ArchiveStreamProvider
operator|.
name|class
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|toKey
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
return|;
block|}
comment|/**      * Constructs a new sorted map from input stream provider names to provider      * objects.      *      *<p>      * The map returned by this method will have one entry for each provider for      * which support is available in the current Java virtual machine. If two or      * more supported provider have the same name then the resulting map will      * contain just one of them; which one it will contain is not specified.      *</p>      *      *<p>      * The invocation of this method, and the subsequent use of the resulting      * map, may cause time-consuming disk or network I/O operations to occur.      * This method is provided for applications that need to enumerate all of      * the available providers, for example to allow user provider selection.      *</p>      *      *<p>      * This method may return different results at different times if new      * providers are dynamically made available to the current Java virtual      * machine.      *</p>      *      * @return An immutable, map from names to provider objects      * @since 1.13      */
specifier|public
specifier|static
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|findAvailableArchiveInputStreamProviders
parameter_list|()
block|{
return|return
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|run
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|putAll
argument_list|(
name|SINGLETON
operator|.
name|getInputStreamArchiveNames
argument_list|()
argument_list|,
name|SINGLETON
argument_list|,
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|ArchiveStreamProvider
name|provider
range|:
name|findArchiveStreamProviders
argument_list|()
control|)
block|{
name|putAll
argument_list|(
name|provider
operator|.
name|getInputStreamArchiveNames
argument_list|()
argument_list|,
name|provider
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Constructs a new sorted map from output stream provider names to provider      * objects.      *      *<p>      * The map returned by this method will have one entry for each provider for      * which support is available in the current Java virtual machine. If two or      * more supported provider have the same name then the resulting map will      * contain just one of them; which one it will contain is not specified.      *</p>      *      *<p>      * The invocation of this method, and the subsequent use of the resulting      * map, may cause time-consuming disk or network I/O operations to occur.      * This method is provided for applications that need to enumerate all of      * the available providers, for example to allow user provider selection.      *</p>      *      *<p>      * This method may return different results at different times if new      * providers are dynamically made available to the current Java virtual      * machine.      *</p>      *      * @return An immutable, map from names to provider objects      * @since 1.13      */
specifier|public
specifier|static
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|findAvailableArchiveOutputStreamProviders
parameter_list|()
block|{
return|return
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|run
parameter_list|()
block|{
name|TreeMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|putAll
argument_list|(
name|SINGLETON
operator|.
name|getOutputStreamArchiveNames
argument_list|()
argument_list|,
name|SINGLETON
argument_list|,
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|ArchiveStreamProvider
name|provider
range|:
name|findArchiveStreamProviders
argument_list|()
control|)
block|{
name|putAll
argument_list|(
name|provider
operator|.
name|getOutputStreamArchiveNames
argument_list|()
argument_list|,
name|provider
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Create an instance using the specified encoding.      *      * @param encoding the encoding to be used.      *      * @since 1.10      */
specifier|public
name|TikaArchiveStreamFactory
parameter_list|(
specifier|final
name|String
name|encoding
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|encoding
operator|=
name|encoding
expr_stmt|;
comment|// Also set the original field so can continue to use it.
name|this
operator|.
name|entryEncoding
operator|=
name|encoding
expr_stmt|;
block|}
comment|/**      * Returns the encoding to use for arj, jar, zip, dump, cpio and tar      * files, or null for the archiver default.      *      * @return entry encoding, or null for the archiver default      * @since 1.5      */
specifier|public
name|String
name|getEntryEncoding
parameter_list|()
block|{
return|return
name|entryEncoding
return|;
block|}
comment|/**      * Sets the encoding to use for arj, jar, zip, dump, cpio and tar files. Use null for the archiver default.      *      * @param entryEncoding the entry encoding, null uses the archiver default.      * @since 1.5      * @deprecated 1.10 use {@link #TikaArchiveStreamFactory(String)} to specify the encoding      * @throws IllegalStateException if the constructor {@link #TikaArchiveStreamFactory(String)}      * was used to specify the factory encoding.      */
annotation|@
name|Deprecated
specifier|public
name|void
name|setEntryEncoding
parameter_list|(
specifier|final
name|String
name|entryEncoding
parameter_list|)
block|{
comment|// Note: this does not detect new ArchiveStreamFactory(null) but that does not set the encoding anyway
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot overide encoding set by the constructor"
argument_list|)
throw|;
block|}
name|this
operator|.
name|entryEncoding
operator|=
name|entryEncoding
expr_stmt|;
block|}
comment|/**      * Creates an archive input stream from an archiver name and an input stream.      *      * @param archiverName the archive name,      * i.e. {@value #AR}, {@value #ARJ}, {@value #ZIP}, {@value #TAR}, {@value #JAR}, {@value #CPIO}, {@value #DUMP} or {@value #SEVEN_Z}      * @param in the input stream      * @return the archive input stream      * @throws ArchiveException if the archiver name is not known      * @throws StreamingNotSupportedException if the format cannot be      * read from a stream      * @throws IllegalArgumentException if the archiver name or stream is null      */
specifier|public
name|ArchiveInputStream
name|createArchiveInputStream
parameter_list|(
specifier|final
name|String
name|archiverName
parameter_list|,
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|ArchiveException
block|{
return|return
name|createArchiveInputStream
argument_list|(
name|archiverName
argument_list|,
name|in
argument_list|,
name|entryEncoding
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ArchiveInputStream
name|createArchiveInputStream
parameter_list|(
specifier|final
name|String
name|archiverName
parameter_list|,
specifier|final
name|InputStream
name|in
parameter_list|,
specifier|final
name|String
name|actualEncoding
parameter_list|)
throws|throws
name|ArchiveException
block|{
if|if
condition|(
name|archiverName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Archivername must not be null."
argument_list|)
throw|;
block|}
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"InputStream must not be null."
argument_list|)
throw|;
block|}
if|if
condition|(
name|AR
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
return|return
operator|new
name|ArArchiveInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|ARJ
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ArjArchiveInputStream
argument_list|(
name|in
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|ArjArchiveInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|ZIP
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ZipArchiveInputStream
argument_list|(
name|in
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|ZipArchiveInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|TAR
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|TarArchiveInputStream
argument_list|(
name|in
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|TarArchiveInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|JAR
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|JarArchiveInputStream
argument_list|(
name|in
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|JarArchiveInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|CPIO
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|CpioArchiveInputStream
argument_list|(
name|in
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|CpioArchiveInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|DUMP
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|DumpArchiveInputStream
argument_list|(
name|in
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|DumpArchiveInputStream
argument_list|(
name|in
argument_list|)
return|;
block|}
if|if
condition|(
name|SEVEN_Z
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StreamingNotSupportedException
argument_list|(
name|SEVEN_Z
argument_list|)
throw|;
block|}
specifier|final
name|ArchiveStreamProvider
name|archiveStreamProvider
init|=
name|getArchiveInputStreamProviders
argument_list|()
operator|.
name|get
argument_list|(
name|toKey
argument_list|(
name|archiverName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|archiveStreamProvider
operator|!=
literal|null
condition|)
block|{
return|return
name|archiveStreamProvider
operator|.
name|createArchiveInputStream
argument_list|(
name|archiverName
argument_list|,
name|in
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
throw|throw
operator|new
name|ArchiveException
argument_list|(
literal|"Archiver: "
operator|+
name|archiverName
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
comment|/**      * Creates an archive output stream from an archiver name and an output stream.      *      * @param archiverName the archive name,      * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO}      * @param out the output stream      * @return the archive output stream      * @throws ArchiveException if the archiver name is not known      * @throws StreamingNotSupportedException if the format cannot be      * written to a stream      * @throws IllegalArgumentException if the archiver name or stream is null      */
specifier|public
name|ArchiveOutputStream
name|createArchiveOutputStream
parameter_list|(
specifier|final
name|String
name|archiverName
parameter_list|,
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|ArchiveException
block|{
return|return
name|createArchiveOutputStream
argument_list|(
name|archiverName
argument_list|,
name|out
argument_list|,
name|entryEncoding
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ArchiveOutputStream
name|createArchiveOutputStream
parameter_list|(
specifier|final
name|String
name|archiverName
parameter_list|,
specifier|final
name|OutputStream
name|out
parameter_list|,
specifier|final
name|String
name|actualEncoding
parameter_list|)
throws|throws
name|ArchiveException
block|{
if|if
condition|(
name|archiverName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Archivername must not be null."
argument_list|)
throw|;
block|}
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"OutputStream must not be null."
argument_list|)
throw|;
block|}
if|if
condition|(
name|AR
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
return|return
operator|new
name|ArArchiveOutputStream
argument_list|(
name|out
argument_list|)
return|;
block|}
if|if
condition|(
name|ZIP
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
specifier|final
name|ZipArchiveOutputStream
name|zip
init|=
operator|new
name|ZipArchiveOutputStream
argument_list|(
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
name|zip
operator|.
name|setEncoding
argument_list|(
name|actualEncoding
argument_list|)
expr_stmt|;
block|}
return|return
name|zip
return|;
block|}
if|if
condition|(
name|TAR
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|TarArchiveOutputStream
argument_list|(
name|out
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|TarArchiveOutputStream
argument_list|(
name|out
argument_list|)
return|;
block|}
if|if
condition|(
name|JAR
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|JarArchiveOutputStream
argument_list|(
name|out
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|JarArchiveOutputStream
argument_list|(
name|out
argument_list|)
return|;
block|}
if|if
condition|(
name|CPIO
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
if|if
condition|(
name|actualEncoding
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|CpioArchiveOutputStream
argument_list|(
name|out
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
return|return
operator|new
name|CpioArchiveOutputStream
argument_list|(
name|out
argument_list|)
return|;
block|}
if|if
condition|(
name|SEVEN_Z
operator|.
name|equalsIgnoreCase
argument_list|(
name|archiverName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StreamingNotSupportedException
argument_list|(
name|SEVEN_Z
argument_list|)
throw|;
block|}
specifier|final
name|ArchiveStreamProvider
name|archiveStreamProvider
init|=
name|getArchiveOutputStreamProviders
argument_list|()
operator|.
name|get
argument_list|(
name|toKey
argument_list|(
name|archiverName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|archiveStreamProvider
operator|!=
literal|null
condition|)
block|{
return|return
name|archiveStreamProvider
operator|.
name|createArchiveOutputStream
argument_list|(
name|archiverName
argument_list|,
name|out
argument_list|,
name|actualEncoding
argument_list|)
return|;
block|}
throw|throw
operator|new
name|ArchiveException
argument_list|(
literal|"Archiver: "
operator|+
name|archiverName
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
comment|/**      * Create an archive input stream from an input stream, autodetecting      * the archive type from the first few bytes of the stream. The InputStream      * must support marks, like BufferedInputStream.      *      * @param in the input stream      * @return the archive input stream      * @throws ArchiveException if the archiver name is not known      * @throws StreamingNotSupportedException if the format cannot be      * read from a stream      * @throws IllegalArgumentException if the stream is null or does not support mark      */
specifier|public
name|ArchiveInputStream
name|createArchiveInputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|ArchiveException
block|{
return|return
name|createArchiveInputStream
argument_list|(
name|detect
argument_list|(
name|in
argument_list|)
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**      * Try to determine the type of Archiver      * @param in input stream      * @return type of archiver if found      * @throws ArchiveException if an archiver cannot be detected in the stream      * @since 1.14      */
specifier|public
specifier|static
name|String
name|detect
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|ArchiveException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Stream must not be null."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|in
operator|.
name|markSupported
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Mark is not supported."
argument_list|)
throw|;
block|}
specifier|final
name|byte
index|[]
name|signature
init|=
operator|new
name|byte
index|[
name|SIGNATURE_SIZE
index|]
decl_stmt|;
name|in
operator|.
name|mark
argument_list|(
name|signature
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|signatureLength
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|signatureLength
operator|=
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ArchiveException
argument_list|(
literal|"IOException while reading signature."
argument_list|)
throw|;
block|}
if|if
condition|(
name|ZipArchiveInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|ZIP
return|;
block|}
elseif|else
if|if
condition|(
name|JarArchiveInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|JAR
return|;
block|}
if|if
condition|(
name|ArArchiveInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|AR
return|;
block|}
elseif|else
if|if
condition|(
name|CpioArchiveInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|CPIO
return|;
block|}
elseif|else
if|if
condition|(
name|ArjArchiveInputStream
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|ARJ
return|;
block|}
elseif|else
if|if
condition|(
name|SevenZFile
operator|.
name|matches
argument_list|(
name|signature
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|SEVEN_Z
return|;
block|}
comment|// Dump needs a bigger buffer to check the signature;
specifier|final
name|byte
index|[]
name|dumpsig
init|=
operator|new
name|byte
index|[
name|DUMP_SIGNATURE_SIZE
index|]
decl_stmt|;
name|in
operator|.
name|mark
argument_list|(
name|dumpsig
operator|.
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|signatureLength
operator|=
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|dumpsig
argument_list|)
expr_stmt|;
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ArchiveException
argument_list|(
literal|"IOException while reading dump signature"
argument_list|)
throw|;
block|}
if|if
condition|(
name|DumpArchiveInputStream
operator|.
name|matches
argument_list|(
name|dumpsig
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|DUMP
return|;
block|}
comment|// Tar needs an even bigger buffer to check the signature; read the first block
specifier|final
name|byte
index|[]
name|tarHeader
init|=
operator|new
name|byte
index|[
name|TAR_HEADER_SIZE
index|]
decl_stmt|;
name|in
operator|.
name|mark
argument_list|(
name|tarHeader
operator|.
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|signatureLength
operator|=
name|IOUtils
operator|.
name|readFully
argument_list|(
name|in
argument_list|,
name|tarHeader
argument_list|)
expr_stmt|;
name|in
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ArchiveException
argument_list|(
literal|"IOException while reading tar signature"
argument_list|)
throw|;
block|}
if|if
condition|(
name|TarArchiveInputStream
operator|.
name|matches
argument_list|(
name|tarHeader
argument_list|,
name|signatureLength
argument_list|)
condition|)
block|{
return|return
name|TAR
return|;
block|}
comment|// COMPRESS-117 - improve auto-recognition
if|if
condition|(
name|signatureLength
operator|>=
name|TAR_HEADER_SIZE
condition|)
block|{
name|TarArchiveInputStream
name|tais
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tais
operator|=
operator|new
name|TarArchiveInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|tarHeader
argument_list|)
argument_list|)
expr_stmt|;
comment|// COMPRESS-191 - verify the header checksum
if|if
condition|(
name|tais
operator|.
name|getNextTarEntry
argument_list|()
operator|.
name|isCheckSumOK
argument_list|()
condition|)
block|{
return|return
name|TAR
return|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
comment|// NOPMD
comment|// can generate IllegalArgumentException as well
comment|// as IOException
comment|// autodetection, simply not a TAR
comment|// ignored
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|tais
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|ArchiveException
argument_list|(
literal|"No Archiver found for the stream signature"
argument_list|)
throw|;
block|}
specifier|public
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|getArchiveInputStreamProviders
parameter_list|()
block|{
if|if
condition|(
name|archiveInputStreamProviders
operator|==
literal|null
condition|)
block|{
name|archiveInputStreamProviders
operator|=
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|findAvailableArchiveInputStreamProviders
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|archiveInputStreamProviders
return|;
block|}
specifier|public
name|SortedMap
argument_list|<
name|String
argument_list|,
name|ArchiveStreamProvider
argument_list|>
name|getArchiveOutputStreamProviders
parameter_list|()
block|{
if|if
condition|(
name|archiveOutputStreamProviders
operator|==
literal|null
condition|)
block|{
name|archiveOutputStreamProviders
operator|=
name|Collections
operator|.
name|unmodifiableSortedMap
argument_list|(
name|findAvailableArchiveOutputStreamProviders
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|archiveOutputStreamProviders
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getInputStreamArchiveNames
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|newHashSet
argument_list|(
name|AR
argument_list|,
name|ARJ
argument_list|,
name|ZIP
argument_list|,
name|TAR
argument_list|,
name|JAR
argument_list|,
name|CPIO
argument_list|,
name|DUMP
argument_list|,
name|SEVEN_Z
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getOutputStreamArchiveNames
parameter_list|()
block|{
return|return
name|Sets
operator|.
name|newHashSet
argument_list|(
name|AR
argument_list|,
name|ZIP
argument_list|,
name|TAR
argument_list|,
name|JAR
argument_list|,
name|CPIO
argument_list|,
name|SEVEN_Z
argument_list|)
return|;
block|}
block|}
end_class

end_unit

