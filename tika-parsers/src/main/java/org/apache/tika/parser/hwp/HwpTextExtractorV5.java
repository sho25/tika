begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|hwp
package|;
end_package

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|Cipher
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|CipherInputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|NoSuchPaddingException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|spec
operator|.
name|SecretKeySpec
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|InvalidKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Inflater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|InflaterInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hpsf
operator|.
name|NoPropertySetStreamException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hpsf
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hpsf
operator|.
name|PropertySet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|DirectoryEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|DirectoryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|DocumentEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|DocumentInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|POIFSFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|util
operator|.
name|LittleEndian
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|EncryptedDocumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|UnsupportedFormatException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Office
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OfficeOpenXMLCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|TikaCoreProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|sax
operator|.
name|XHTMLContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_class
specifier|public
class|class
name|HwpTextExtractorV5
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|protected
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HwpTextExtractorV5
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|HWP_V5_SIGNATURE
init|=
literal|"HWP Document File"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|HWPTAG_BEGIN
init|=
literal|0x010
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|I
init|=
literal|1
decl_stmt|;
comment|// INLINE
specifier|private
specifier|static
specifier|final
name|int
name|C
init|=
literal|2
decl_stmt|;
comment|// CONTROL
specifier|private
specifier|static
specifier|final
name|int
name|X
init|=
literal|3
decl_stmt|;
comment|// EXTENDED
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|HWP_CHAR_TYPE
init|=
operator|new
name|int
index|[]
block|{
name|C
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
name|I
block|,
comment|// 0-9
name|C
block|,
name|X
block|,
name|X
block|,
name|C
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|I
block|,
comment|// 10-19
name|I
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|C
block|,
name|C
block|,
name|C
block|,
name|C
block|,
name|C
block|,
name|C
block|,
comment|// 20-29
name|C
block|,
name|C
block|}
decl_stmt|;
comment|// 30-31
comment|/**      * extract Text from HWP Stream.      *      * @param source      * @param metadata      * @param xhtml      * @return      * @throws FileNotFoundException      * @throws IOException      * @throws SAXException      */
specifier|public
name|void
name|extract
parameter_list|(
name|InputStream
name|source
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
throws|,
name|TikaException
throws|,
name|SAXException
block|{
if|if
condition|(
name|source
operator|==
literal|null
operator|||
name|xhtml
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|POIFSFileSystem
name|fs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fs
operator|=
operator|new
name|POIFSFileSystem
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|DirectoryNode
name|root
init|=
name|fs
operator|.
name|getRoot
argument_list|()
decl_stmt|;
name|extract0
argument_list|(
name|root
argument_list|,
name|metadata
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"error occurred when parsing HWP Format, It may not HWP Format."
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|extract0
parameter_list|(
name|DirectoryNode
name|root
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
name|Entry
name|headerEntry
init|=
name|root
operator|.
name|getEntry
argument_list|(
literal|"FileHeader"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|headerEntry
operator|.
name|isDocumentEntry
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedFormatException
argument_list|(
literal|"cannot parse the File Header"
argument_list|)
throw|;
block|}
name|FileHeader
name|header
init|=
name|getHeader
argument_list|(
name|headerEntry
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedFormatException
argument_list|(
literal|"cannot parse the File Header"
argument_list|)
throw|;
block|}
if|if
condition|(
name|header
operator|.
name|encrypted
condition|)
block|{
throw|throw
operator|new
name|EncryptedDocumentException
argument_list|(
literal|"document is encrypted"
argument_list|)
throw|;
block|}
name|parseSummaryInformation
argument_list|(
name|root
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|viewtext
condition|)
block|{
name|parseViewText
argument_list|(
name|header
argument_list|,
name|root
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parseBodyText
argument_list|(
name|header
argument_list|,
name|root
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|parseSummaryInformation
parameter_list|(
name|DirectoryNode
name|root
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|TikaException
block|{
try|try
block|{
name|Entry
name|summaryEntry
init|=
name|root
operator|.
name|getEntry
argument_list|(
literal|"\u0005HwpSummaryInformation"
argument_list|)
decl_stmt|;
name|populateMatadata
argument_list|(
name|summaryEntry
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoPropertySetStreamException
decl||
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedFormatException
argument_list|(
literal|"cannot parse the Summary Information"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|populateMatadata
parameter_list|(
name|Entry
name|summaryEntry
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoPropertySetStreamException
block|{
name|DocumentInputStream
name|summaryStream
init|=
operator|new
name|DocumentInputStream
argument_list|(
operator|(
name|DocumentEntry
operator|)
name|summaryEntry
argument_list|)
decl_stmt|;
name|PropertySet
name|ps
init|=
operator|new
name|PropertySet
argument_list|(
name|summaryStream
argument_list|)
decl_stmt|;
name|Property
index|[]
name|props
init|=
name|ps
operator|.
name|getProperties
argument_list|()
decl_stmt|;
for|for
control|(
name|Property
name|prop
range|:
name|props
control|)
block|{
name|int
name|propID
init|=
operator|(
name|int
operator|)
name|prop
operator|.
name|getID
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|prop
operator|.
name|getValue
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|propID
condition|)
block|{
case|case
literal|2
case|:
name|metadata
operator|.
name|set
argument_list|(
name|TikaCoreProperties
operator|.
name|TITLE
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|metadata
operator|.
name|set
argument_list|(
name|OfficeOpenXMLCore
operator|.
name|SUBJECT
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|metadata
operator|.
name|set
argument_list|(
name|TikaCoreProperties
operator|.
name|CREATOR
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|metadata
operator|.
name|set
argument_list|(
name|Office
operator|.
name|KEYWORDS
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|metadata
operator|.
name|set
argument_list|(
name|TikaCoreProperties
operator|.
name|COMMENTS
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|metadata
operator|.
name|set
argument_list|(
name|TikaCoreProperties
operator|.
name|MODIFIER
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|metadata
operator|.
name|set
argument_list|(
name|TikaCoreProperties
operator|.
name|CREATED
argument_list|,
operator|(
name|Date
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|metadata
operator|.
name|set
argument_list|(
name|TikaCoreProperties
operator|.
name|MODIFIED
argument_list|,
operator|(
name|Date
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|metadata
operator|.
name|set
argument_list|(
name|Office
operator|.
name|PAGE_COUNT
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
block|}
block|}
comment|/**      * extract the HWP File Header      *      * @param headerEntry      * @return      * @throws IOException      */
specifier|private
name|FileHeader
name|getHeader
parameter_list|(
name|Entry
name|headerEntry
parameter_list|)
throws|throws
name|IOException
block|{
comment|// confirm signature
name|byte
index|[]
name|header
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
comment|// the length of File header is 256
try|try
init|(
name|DocumentInputStream
name|headerStream
init|=
operator|new
name|DocumentInputStream
argument_list|(
operator|(
name|DocumentEntry
operator|)
name|headerEntry
argument_list|)
init|)
block|{
name|int
name|read
init|=
name|headerStream
operator|.
name|read
argument_list|(
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|!=
literal|256
operator|||
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|HWP_V5_SIGNATURE
argument_list|,
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|header
argument_list|,
literal|0
argument_list|,
name|HWP_V5_SIGNATURE
operator|.
name|length
argument_list|)
argument_list|)
condition|)
return|return
literal|null
return|;
block|}
name|FileHeader
name|fileHeader
init|=
operator|new
name|FileHeader
argument_list|()
decl_stmt|;
comment|// version. debug
name|fileHeader
operator|.
name|version
operator|=
name|HwpVersion
operator|.
name|parseVersion
argument_list|(
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|header
argument_list|,
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|flags
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|header
argument_list|,
literal|36
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Flags={}"
argument_list|,
name|Long
operator|.
name|toBinaryString
argument_list|(
name|flags
argument_list|)
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
name|fileHeader
operator|.
name|compressed
operator|=
operator|(
name|flags
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
expr_stmt|;
name|fileHeader
operator|.
name|encrypted
operator|=
operator|(
name|flags
operator|&
literal|0x02
operator|)
operator|==
literal|0x02
expr_stmt|;
name|fileHeader
operator|.
name|viewtext
operator|=
operator|(
name|flags
operator|&
literal|0x04
operator|)
operator|==
literal|0x04
expr_stmt|;
return|return
name|fileHeader
return|;
block|}
comment|/**      * extract Text      *      * @param header      * @param root      * @param xhtml      * @return      * @throws IOException      * @throws SAXException      */
specifier|private
name|void
name|parseBodyText
parameter_list|(
name|FileHeader
name|header
parameter_list|,
name|DirectoryNode
name|root
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
comment|// read BodyText
name|Entry
name|bodyText
init|=
name|root
operator|.
name|getEntry
argument_list|(
literal|"BodyText"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bodyText
operator|==
literal|null
operator|||
operator|!
name|bodyText
operator|.
name|isDirectoryEntry
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid BodyText"
argument_list|)
throw|;
name|Iterator
argument_list|<
name|Entry
argument_list|>
name|iterator
init|=
operator|(
operator|(
name|DirectoryEntry
operator|)
name|bodyText
operator|)
operator|.
name|getEntries
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Section"
argument_list|)
operator|&&
name|entry
operator|instanceof
name|DocumentEntry
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"extract {}"
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|InputStream
name|input
init|=
operator|new
name|DocumentInputStream
argument_list|(
operator|(
name|DocumentEntry
operator|)
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|.
name|compressed
condition|)
name|input
operator|=
operator|new
name|InflaterInputStream
argument_list|(
name|input
argument_list|,
operator|new
name|Inflater
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|HwpStreamReader
name|reader
init|=
operator|new
name|HwpStreamReader
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|parse
argument_list|(
name|reader
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown Entry '{}'({})"
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * 텍스트 추출      *      * @param header      * @param root      * @param xhtml      * @return      * @throws IOException      */
specifier|private
name|void
name|parseViewText
parameter_list|(
name|FileHeader
name|header
parameter_list|,
name|DirectoryNode
name|root
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
block|{
comment|// read BodyText
name|Entry
name|bodyText
init|=
name|root
operator|.
name|getEntry
argument_list|(
literal|"ViewText"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bodyText
operator|==
literal|null
operator|||
operator|!
name|bodyText
operator|.
name|isDirectoryEntry
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid ViewText"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|Entry
argument_list|>
name|iterator
init|=
operator|(
operator|(
name|DirectoryEntry
operator|)
name|bodyText
operator|)
operator|.
name|getEntries
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"Section"
argument_list|)
operator|&&
name|entry
operator|instanceof
name|DocumentEntry
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"extract {}"
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|InputStream
name|input
init|=
operator|new
name|DocumentInputStream
argument_list|(
operator|(
name|DocumentEntry
operator|)
name|entry
argument_list|)
decl_stmt|;
try|try
block|{
name|Key
name|key
init|=
name|readKey
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|input
operator|=
name|createDecryptStream
argument_list|(
name|input
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|compressed
condition|)
block|{
name|input
operator|=
operator|new
name|InflaterInputStream
argument_list|(
name|input
argument_list|,
operator|new
name|Inflater
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HwpStreamReader
name|sectionStream
init|=
operator|new
name|HwpStreamReader
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|parse
argument_list|(
name|sectionStream
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidKeyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchPaddingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"unknown Entry '{}'({})"
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Key
name|readKey
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|260
index|]
decl_stmt|;
if|if
condition|(
name|IOUtils
operator|.
name|readFully
argument_list|(
name|input
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
block|{
comment|// TAG,
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
if|if
condition|(
name|IOUtils
operator|.
name|readFully
argument_list|(
name|input
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
operator|!=
literal|256
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
name|SRand
name|srand
init|=
operator|new
name|SRand
argument_list|(
name|LittleEndian
operator|.
name|getInt
argument_list|(
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|xor
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|n
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
operator|,
name|n
operator|--
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|xor
operator|=
call|(
name|byte
call|)
argument_list|(
name|srand
operator|.
name|rand
argument_list|()
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|srand
operator|.
name|rand
argument_list|()
operator|&
literal|0xF
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|4
condition|)
block|{
name|data
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|data
index|[
name|i
index|]
operator|)
operator|^
operator|(
name|xor
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|offset
init|=
literal|4
operator|+
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0xF
operator|)
decl_stmt|;
comment|// 4 + (0~15) ?
name|byte
index|[]
name|key
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
literal|16
argument_list|)
decl_stmt|;
name|SecretKeySpec
name|secretKey
init|=
operator|new
name|SecretKeySpec
argument_list|(
name|key
argument_list|,
literal|"AES"
argument_list|)
decl_stmt|;
return|return
name|secretKey
return|;
block|}
specifier|public
name|InputStream
name|createDecryptStream
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|Key
name|key
parameter_list|)
throws|throws
name|NoSuchAlgorithmException
throws|,
name|NoSuchPaddingException
throws|,
name|InvalidKeyException
block|{
name|Cipher
name|cipher
init|=
literal|null
decl_stmt|;
name|cipher
operator|=
name|Cipher
operator|.
name|getInstance
argument_list|(
literal|"AES/ECB/NoPadding"
argument_list|)
expr_stmt|;
name|cipher
operator|.
name|init
argument_list|(
name|Cipher
operator|.
name|DECRYPT_MODE
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|new
name|CipherInputStream
argument_list|(
name|input
argument_list|,
name|cipher
argument_list|)
return|;
block|}
comment|/**      * extract characters from Section stream      *      * @param reader      * @param xhtml      * @throws IOException      * @throws SAXException      */
specifier|private
name|void
name|parse
parameter_list|(
name|HwpStreamReader
name|reader
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
name|TagInfo
name|tag
init|=
operator|new
name|TagInfo
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|readTag
argument_list|(
name|reader
argument_list|,
name|tag
argument_list|)
condition|)
break|break;
if|if
condition|(
name|HWPTAG_BEGIN
operator|+
literal|51
operator|==
name|tag
operator|.
name|id
condition|)
block|{
if|if
condition|(
name|tag
operator|.
name|length
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid block size"
argument_list|)
throw|;
block|}
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|writeParaText
argument_list|(
name|reader
argument_list|,
name|tag
operator|.
name|length
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|characters
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reader
operator|.
name|ensureSkip
argument_list|(
name|tag
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * transfer character stream of HWPTAG_PARA_TEXT to STRING      *      * @param reader      * @param datasize      * @param buf      * @throws IOException      */
specifier|private
name|void
name|writeParaText
parameter_list|(
name|HwpStreamReader
name|reader
parameter_list|,
name|long
name|datasize
parameter_list|,
name|StringBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|int
index|[]
name|chars
init|=
name|reader
operator|.
name|uint16
argument_list|(
call|(
name|int
call|)
argument_list|(
name|datasize
operator|/
literal|2
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|chars
operator|.
name|length
condition|;
name|index
operator|++
control|)
block|{
name|int
name|ch
init|=
name|chars
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|32
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|9
condition|)
block|{
comment|// tab, INLINE
name|buf
operator|.
name|append
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|int
name|type
init|=
name|HWP_CHAR_TYPE
index|[
name|ch
index|]
decl_stmt|;
if|if
condition|(
name|I
operator|==
name|type
condition|)
block|{
comment|// INLINE
name|index
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|X
operator|==
name|type
condition|)
block|{
comment|// EXTENDED
name|index
operator|+=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|C
operator|==
name|type
condition|)
block|{
comment|// CONTROL
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|readTag
parameter_list|(
name|HwpStreamReader
name|reader
parameter_list|,
name|TagInfo
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
comment|// see p.24 of hwp 5.0 format guide
name|long
name|recordHeader
init|=
name|reader
operator|.
name|uint32
argument_list|()
decl_stmt|;
if|if
condition|(
name|recordHeader
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|tag
operator|.
name|id
operator|=
name|recordHeader
operator|&
literal|0x3FF
expr_stmt|;
name|tag
operator|.
name|level
operator|=
operator|(
name|recordHeader
operator|>>
literal|10
operator|)
operator|&
literal|0x3FF
expr_stmt|;
name|tag
operator|.
name|length
operator|=
operator|(
name|recordHeader
operator|>>
literal|20
operator|)
operator|&
literal|0xFFF
expr_stmt|;
comment|// see p.24 of hwp 5.0 format guide
if|if
condition|(
name|tag
operator|.
name|length
operator|==
literal|0xFFF
condition|)
name|tag
operator|.
name|length
operator|=
name|reader
operator|.
name|uint32
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
class|class
name|SRand
block|{
specifier|private
name|int
name|random_seed
decl_stmt|;
specifier|private
name|SRand
parameter_list|(
name|int
name|seed
parameter_list|)
block|{
name|random_seed
operator|=
name|seed
expr_stmt|;
block|}
specifier|private
name|int
name|rand
parameter_list|()
block|{
name|random_seed
operator|=
operator|(
name|random_seed
operator|*
literal|214013
operator|+
literal|2531011
operator|)
operator|&
literal|0xFFFFFFFF
expr_stmt|;
return|return
operator|(
name|random_seed
operator|>>
literal|16
operator|)
operator|&
literal|0x7FFF
return|;
block|}
block|}
specifier|static
class|class
name|FileHeader
block|{
name|HwpVersion
name|version
decl_stmt|;
name|boolean
name|compressed
decl_stmt|;
comment|// bit 0
name|boolean
name|encrypted
decl_stmt|;
comment|// bit 1
name|boolean
name|viewtext
decl_stmt|;
comment|// bit 2
block|}
specifier|static
class|class
name|TagInfo
block|{
name|long
name|id
decl_stmt|;
name|long
name|level
decl_stmt|;
name|long
name|length
decl_stmt|;
block|}
specifier|static
class|class
name|HwpVersion
block|{
name|int
name|m
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|US
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|,
name|r
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|HwpVersion
name|parseVersion
parameter_list|(
name|long
name|longVersion
parameter_list|)
block|{
name|HwpVersion
name|version
init|=
operator|new
name|HwpVersion
argument_list|()
decl_stmt|;
name|version
operator|.
name|m
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|longVersion
operator|&
literal|0xFF000000L
operator|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|version
operator|.
name|n
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|longVersion
operator|&
literal|0x00FF0000L
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|version
operator|.
name|p
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|longVersion
operator|&
literal|0x0000FF00L
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|version
operator|.
name|r
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|longVersion
operator|&
literal|0x000000FFL
operator|)
argument_list|)
expr_stmt|;
return|return
name|version
return|;
block|}
block|}
block|}
end_class

end_unit

