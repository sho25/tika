begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Â© 2016 and later: Unicode, Inc. and others.
end_comment

begin_comment
comment|// License& terms of use: http://www.unicode.org/copyright.html#License
end_comment

begin_comment
comment|/*  ****************************************************************************  * Copyright (C) 2005-2012, International Business Machines Corporation and *  * others. All Rights Reserved.                                             *  ****************************************************************************  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|txt
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * CharsetRecognizer implemenation for Asian  - double or multi-byte - charsets.  * Match is determined mostly by the input data adhering to the  * encoding scheme for the charset, and, optionally,  * frequency-of-occurence of characters.  *<p/>  * Instances of this class are singletons, one per encoding  * being recognized.  They are created in the main  * CharsetDetector class and kept in the global list of available  * encodings to be checked.  The specific encoding being recognized  * is determined by subclass.  */
end_comment

begin_class
specifier|abstract
class|class
name|CharsetRecog_mbcs
extends|extends
name|CharsetRecognizer
block|{
comment|/**      * Get the IANA name of this charset.      *      * @return the charset name.      */
specifier|abstract
name|String
name|getName
parameter_list|()
function_decl|;
comment|/**      * Test the match of this charset with the input text data      * which is obtained via the CharsetDetector object.      *      * @param det The CharsetDetector, which contains the input text      *            to be checked for being in this charset.      * @return Two values packed into one int  (Damn java, anyhow)      *<br/>      * bits 0-7:  the match confidence, ranging from 0-100      *<br/>      * bits 8-15: The match reason, an enum-like value.      */
name|int
name|match
parameter_list|(
name|CharsetDetector
name|det
parameter_list|,
name|int
index|[]
name|commonChars
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|int
name|singleByteCharCount
init|=
literal|0
decl_stmt|;
comment|//TODO Do we really need this?
name|int
name|doubleByteCharCount
init|=
literal|0
decl_stmt|;
name|int
name|commonCharCount
init|=
literal|0
decl_stmt|;
name|int
name|badCharCount
init|=
literal|0
decl_stmt|;
name|int
name|totalCharCount
init|=
literal|0
decl_stmt|;
name|int
name|confidence
init|=
literal|0
decl_stmt|;
name|iteratedChar
name|iter
init|=
operator|new
name|iteratedChar
argument_list|()
decl_stmt|;
name|detectBlock
label|:
block|{
for|for
control|(
name|iter
operator|.
name|reset
argument_list|()
init|;
name|nextChar
argument_list|(
name|iter
argument_list|,
name|det
argument_list|)
condition|;
control|)
block|{
name|totalCharCount
operator|++
expr_stmt|;
if|if
condition|(
name|iter
operator|.
name|error
condition|)
block|{
name|badCharCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|long
name|cv
init|=
name|iter
operator|.
name|charValue
operator|&
literal|0xFFFFFFFFL
decl_stmt|;
if|if
condition|(
name|cv
operator|<=
literal|0xff
condition|)
block|{
name|singleByteCharCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|doubleByteCharCount
operator|++
expr_stmt|;
if|if
condition|(
name|commonChars
operator|!=
literal|null
condition|)
block|{
comment|// NOTE: This assumes that there are no 4-byte common chars.
if|if
condition|(
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|commonChars
argument_list|,
operator|(
name|int
operator|)
name|cv
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|commonCharCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|badCharCount
operator|>=
literal|2
operator|&&
name|badCharCount
operator|*
literal|5
operator|>=
name|doubleByteCharCount
condition|)
block|{
comment|// Bail out early if the byte data is not matching the encoding scheme.
break|break
name|detectBlock
break|;
block|}
block|}
if|if
condition|(
name|doubleByteCharCount
operator|<=
literal|10
operator|&&
name|badCharCount
operator|==
literal|0
condition|)
block|{
comment|// Not many multi-byte chars.
if|if
condition|(
name|doubleByteCharCount
operator|==
literal|0
operator|&&
name|totalCharCount
operator|<
literal|10
condition|)
block|{
comment|// There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.
comment|// We don't have enough data to have any confidence.
comment|// Statistical analysis of single byte non-ASCII charcters would probably help here.
name|confidence
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|//   ASCII or ISO file?  It's probably not our encoding,
comment|//   but is not incompatible with our encoding, so don't give it a zero.
name|confidence
operator|=
literal|10
expr_stmt|;
block|}
break|break
name|detectBlock
break|;
block|}
comment|//
comment|//  No match if there are too many characters that don't fit the encoding scheme.
comment|//    (should we have zero tolerance for these?)
comment|//
if|if
condition|(
name|doubleByteCharCount
operator|<
literal|20
operator|*
name|badCharCount
condition|)
block|{
name|confidence
operator|=
literal|0
expr_stmt|;
break|break
name|detectBlock
break|;
block|}
if|if
condition|(
name|commonChars
operator|==
literal|null
condition|)
block|{
comment|// We have no statistics on frequently occuring characters.
comment|//  Assess confidence purely on having a reasonable number of
comment|//  multi-byte characters (the more the better
name|confidence
operator|=
literal|30
operator|+
name|doubleByteCharCount
operator|-
literal|20
operator|*
name|badCharCount
expr_stmt|;
if|if
condition|(
name|confidence
operator|>
literal|100
condition|)
block|{
name|confidence
operator|=
literal|100
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//
comment|// Frequency of occurence statistics exist.
comment|//
name|double
name|maxVal
init|=
name|Math
operator|.
name|log
argument_list|(
operator|(
name|float
operator|)
name|doubleByteCharCount
operator|/
literal|4
argument_list|)
decl_stmt|;
name|double
name|scaleFactor
init|=
literal|90.0
operator|/
name|maxVal
decl_stmt|;
name|confidence
operator|=
call|(
name|int
call|)
argument_list|(
name|Math
operator|.
name|log
argument_list|(
name|commonCharCount
operator|+
literal|1
argument_list|)
operator|*
name|scaleFactor
operator|+
literal|10
argument_list|)
expr_stmt|;
name|confidence
operator|=
name|Math
operator|.
name|min
argument_list|(
name|confidence
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end of detectBlock:
return|return
name|confidence
return|;
block|}
comment|/**      * Get the next character (however many bytes it is) from the input data      * Subclasses for specific charset encodings must implement this function      * to get characters according to the rules of their encoding scheme.      *<p>      * This function is not a method of class iteratedChar only because      * that would require a lot of extra derived classes, which is awkward.      *      * @param it  The iteratedChar "struct" into which the returned char is placed.      * @param det The charset detector, which is needed to get at the input byte data      *            being iterated over.      * @return True if a character was returned, false at end of input.      */
specifier|abstract
name|boolean
name|nextChar
parameter_list|(
name|iteratedChar
name|it
parameter_list|,
name|CharsetDetector
name|det
parameter_list|)
function_decl|;
comment|// "Character"  iterated character class.
comment|//    Recognizers for specific mbcs encodings make their "characters" available
comment|//    by providing a nextChar() function that fills in an instance of iteratedChar
comment|//    with the next char from the input.
comment|//    The returned characters are not converted to Unicode, but remain as the raw
comment|//    bytes (concatenated into an int) from the codepage data.
comment|//
comment|//  For Asian charsets, use the raw input rather than the input that has been
comment|//   stripped of markup.  Detection only considers multi-byte chars, effectively
comment|//   stripping markup anyway, and double byte chars do occur in markup too.
comment|//
specifier|static
class|class
name|iteratedChar
block|{
name|int
name|charValue
init|=
literal|0
decl_stmt|;
comment|// 1-4 bytes from the raw input data
name|int
name|nextIndex
init|=
literal|0
decl_stmt|;
name|boolean
name|error
init|=
literal|false
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
name|void
name|reset
parameter_list|()
block|{
name|charValue
operator|=
literal|0
expr_stmt|;
name|nextIndex
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|false
expr_stmt|;
name|done
operator|=
literal|false
expr_stmt|;
block|}
name|int
name|nextByte
parameter_list|(
name|CharsetDetector
name|det
parameter_list|)
block|{
if|if
condition|(
name|nextIndex
operator|>=
name|det
operator|.
name|fRawLength
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|byteValue
init|=
operator|(
name|int
operator|)
name|det
operator|.
name|fRawInput
index|[
name|nextIndex
operator|++
index|]
operator|&
literal|0x00ff
decl_stmt|;
return|return
name|byteValue
return|;
block|}
block|}
comment|/**      * Shift-JIS charset recognizer.      */
specifier|static
class|class
name|CharsetRecog_sjis
extends|extends
name|CharsetRecog_mbcs
block|{
specifier|static
name|int
index|[]
name|commonChars
init|=
comment|// TODO:  This set of data comes from the character frequency-
comment|//        of-occurence analysis tool.  The data needs to be moved
comment|//        into a resource and loaded from there.
block|{
literal|0x8140
block|,
literal|0x8141
block|,
literal|0x8142
block|,
literal|0x8145
block|,
literal|0x815b
block|,
literal|0x8169
block|,
literal|0x816a
block|,
literal|0x8175
block|,
literal|0x8176
block|,
literal|0x82a0
block|,
literal|0x82a2
block|,
literal|0x82a4
block|,
literal|0x82a9
block|,
literal|0x82aa
block|,
literal|0x82ab
block|,
literal|0x82ad
block|,
literal|0x82af
block|,
literal|0x82b1
block|,
literal|0x82b3
block|,
literal|0x82b5
block|,
literal|0x82b7
block|,
literal|0x82bd
block|,
literal|0x82be
block|,
literal|0x82c1
block|,
literal|0x82c4
block|,
literal|0x82c5
block|,
literal|0x82c6
block|,
literal|0x82c8
block|,
literal|0x82c9
block|,
literal|0x82cc
block|,
literal|0x82cd
block|,
literal|0x82dc
block|,
literal|0x82e0
block|,
literal|0x82e7
block|,
literal|0x82e8
block|,
literal|0x82e9
block|,
literal|0x82ea
block|,
literal|0x82f0
block|,
literal|0x82f1
block|,
literal|0x8341
block|,
literal|0x8343
block|,
literal|0x834e
block|,
literal|0x834f
block|,
literal|0x8358
block|,
literal|0x835e
block|,
literal|0x8362
block|,
literal|0x8367
block|,
literal|0x8375
block|,
literal|0x8376
block|,
literal|0x8389
block|,
literal|0x838a
block|,
literal|0x838b
block|,
literal|0x838d
block|,
literal|0x8393
block|,
literal|0x8e96
block|,
literal|0x93fa
block|,
literal|0x95aa
block|}
decl_stmt|;
name|boolean
name|nextChar
parameter_list|(
name|iteratedChar
name|it
parameter_list|,
name|CharsetDetector
name|det
parameter_list|)
block|{
name|it
operator|.
name|error
operator|=
literal|false
expr_stmt|;
name|int
name|firstByte
decl_stmt|;
name|firstByte
operator|=
name|it
operator|.
name|charValue
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstByte
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|firstByte
operator|<=
literal|0x7f
operator|||
operator|(
name|firstByte
operator|>
literal|0xa0
operator|&&
name|firstByte
operator|<=
literal|0xdf
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|secondByte
init|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondByte
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|it
operator|.
name|charValue
operator|=
operator|(
name|firstByte
operator|<<
literal|8
operator|)
operator||
name|secondByte
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|secondByte
operator|>=
literal|0x40
operator|&&
name|secondByte
operator|<=
literal|0x7f
operator|)
operator|||
operator|(
name|secondByte
operator|>=
literal|0x80
operator|&&
name|secondByte
operator|<=
literal|0xff
operator|)
operator|)
condition|)
block|{
comment|// Illegal second byte value.
name|it
operator|.
name|error
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|CharsetMatch
name|match
parameter_list|(
name|CharsetDetector
name|det
parameter_list|)
block|{
name|int
name|confidence
init|=
name|match
argument_list|(
name|det
argument_list|,
name|commonChars
argument_list|)
decl_stmt|;
return|return
name|confidence
operator|==
literal|0
condition|?
literal|null
else|:
operator|new
name|CharsetMatch
argument_list|(
name|det
argument_list|,
name|this
argument_list|,
name|confidence
argument_list|)
return|;
block|}
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"Shift_JIS"
return|;
block|}
specifier|public
name|String
name|getLanguage
parameter_list|()
block|{
return|return
literal|"ja"
return|;
block|}
block|}
comment|/**      * Big5 charset recognizer.      */
specifier|static
class|class
name|CharsetRecog_big5
extends|extends
name|CharsetRecog_mbcs
block|{
specifier|static
name|int
index|[]
name|commonChars
init|=
comment|// TODO:  This set of data comes from the character frequency-
comment|//        of-occurence analysis tool.  The data needs to be moved
comment|//        into a resource and loaded from there.
block|{
literal|0xa140
block|,
literal|0xa141
block|,
literal|0xa142
block|,
literal|0xa143
block|,
literal|0xa147
block|,
literal|0xa149
block|,
literal|0xa175
block|,
literal|0xa176
block|,
literal|0xa440
block|,
literal|0xa446
block|,
literal|0xa447
block|,
literal|0xa448
block|,
literal|0xa451
block|,
literal|0xa454
block|,
literal|0xa457
block|,
literal|0xa464
block|,
literal|0xa46a
block|,
literal|0xa46c
block|,
literal|0xa477
block|,
literal|0xa4a3
block|,
literal|0xa4a4
block|,
literal|0xa4a7
block|,
literal|0xa4c1
block|,
literal|0xa4ce
block|,
literal|0xa4d1
block|,
literal|0xa4df
block|,
literal|0xa4e8
block|,
literal|0xa4fd
block|,
literal|0xa540
block|,
literal|0xa548
block|,
literal|0xa558
block|,
literal|0xa569
block|,
literal|0xa5cd
block|,
literal|0xa5e7
block|,
literal|0xa657
block|,
literal|0xa661
block|,
literal|0xa662
block|,
literal|0xa668
block|,
literal|0xa670
block|,
literal|0xa6a8
block|,
literal|0xa6b3
block|,
literal|0xa6b9
block|,
literal|0xa6d3
block|,
literal|0xa6db
block|,
literal|0xa6e6
block|,
literal|0xa6f2
block|,
literal|0xa740
block|,
literal|0xa751
block|,
literal|0xa759
block|,
literal|0xa7da
block|,
literal|0xa8a3
block|,
literal|0xa8a5
block|,
literal|0xa8ad
block|,
literal|0xa8d1
block|,
literal|0xa8d3
block|,
literal|0xa8e4
block|,
literal|0xa8fc
block|,
literal|0xa9c0
block|,
literal|0xa9d2
block|,
literal|0xa9f3
block|,
literal|0xaa6b
block|,
literal|0xaaba
block|,
literal|0xaabe
block|,
literal|0xaacc
block|,
literal|0xaafc
block|,
literal|0xac47
block|,
literal|0xac4f
block|,
literal|0xacb0
block|,
literal|0xacd2
block|,
literal|0xad59
block|,
literal|0xaec9
block|,
literal|0xafe0
block|,
literal|0xb0ea
block|,
literal|0xb16f
block|,
literal|0xb2b3
block|,
literal|0xb2c4
block|,
literal|0xb36f
block|,
literal|0xb44c
block|,
literal|0xb44e
block|,
literal|0xb54c
block|,
literal|0xb5a5
block|,
literal|0xb5bd
block|,
literal|0xb5d0
block|,
literal|0xb5d8
block|,
literal|0xb671
block|,
literal|0xb7ed
block|,
literal|0xb867
block|,
literal|0xb944
block|,
literal|0xbad8
block|,
literal|0xbb44
block|,
literal|0xbba1
block|,
literal|0xbdd1
block|,
literal|0xc2c4
block|,
literal|0xc3b9
block|,
literal|0xc440
block|,
literal|0xc45f
block|}
decl_stmt|;
name|boolean
name|nextChar
parameter_list|(
name|iteratedChar
name|it
parameter_list|,
name|CharsetDetector
name|det
parameter_list|)
block|{
name|it
operator|.
name|error
operator|=
literal|false
expr_stmt|;
name|int
name|firstByte
decl_stmt|;
name|firstByte
operator|=
name|it
operator|.
name|charValue
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstByte
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|firstByte
operator|<=
literal|0x7f
operator|||
name|firstByte
operator|==
literal|0xff
condition|)
block|{
comment|// single byte character.
return|return
literal|true
return|;
block|}
name|int
name|secondByte
init|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondByte
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|it
operator|.
name|charValue
operator|=
operator|(
name|it
operator|.
name|charValue
operator|<<
literal|8
operator|)
operator||
name|secondByte
expr_stmt|;
if|if
condition|(
name|secondByte
operator|<
literal|0x40
operator|||
name|secondByte
operator|==
literal|0x7f
operator|||
name|secondByte
operator|==
literal|0xff
condition|)
block|{
name|it
operator|.
name|error
operator|=
literal|true
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
name|CharsetMatch
name|match
parameter_list|(
name|CharsetDetector
name|det
parameter_list|)
block|{
name|int
name|confidence
init|=
name|match
argument_list|(
name|det
argument_list|,
name|commonChars
argument_list|)
decl_stmt|;
return|return
name|confidence
operator|==
literal|0
condition|?
literal|null
else|:
operator|new
name|CharsetMatch
argument_list|(
name|det
argument_list|,
name|this
argument_list|,
name|confidence
argument_list|)
return|;
block|}
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"Big5"
return|;
block|}
specifier|public
name|String
name|getLanguage
parameter_list|()
block|{
return|return
literal|"zh"
return|;
block|}
block|}
comment|/**      * EUC charset recognizers.  One abstract class that provides the common function      * for getting the next character according to the EUC encoding scheme,      * and nested derived classes for EUC_KR, EUC_JP, EUC_CN.      */
specifier|abstract
specifier|static
class|class
name|CharsetRecog_euc
extends|extends
name|CharsetRecog_mbcs
block|{
comment|/*          *  (non-Javadoc)          *  Get the next character value for EUC based encodings.          *  Character "value" is simply the raw bytes that make up the character          *     packed into an int.          */
name|boolean
name|nextChar
parameter_list|(
name|iteratedChar
name|it
parameter_list|,
name|CharsetDetector
name|det
parameter_list|)
block|{
name|it
operator|.
name|error
operator|=
literal|false
expr_stmt|;
name|int
name|firstByte
init|=
literal|0
decl_stmt|;
name|int
name|secondByte
init|=
literal|0
decl_stmt|;
name|int
name|thirdByte
init|=
literal|0
decl_stmt|;
comment|//int fourthByte = 0;
name|buildChar
label|:
block|{
name|firstByte
operator|=
name|it
operator|.
name|charValue
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstByte
operator|<
literal|0
condition|)
block|{
comment|// Ran off the end of the input data
name|it
operator|.
name|done
operator|=
literal|true
expr_stmt|;
break|break
name|buildChar
break|;
block|}
if|if
condition|(
name|firstByte
operator|<=
literal|0x8d
condition|)
block|{
comment|// single byte char
break|break
name|buildChar
break|;
block|}
name|secondByte
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
name|it
operator|.
name|charValue
operator|=
operator|(
name|it
operator|.
name|charValue
operator|<<
literal|8
operator|)
operator||
name|secondByte
expr_stmt|;
if|if
condition|(
name|firstByte
operator|>=
literal|0xA1
operator|&&
name|firstByte
operator|<=
literal|0xfe
condition|)
block|{
comment|// Two byte Char
if|if
condition|(
name|secondByte
operator|<
literal|0xa1
condition|)
block|{
name|it
operator|.
name|error
operator|=
literal|true
expr_stmt|;
block|}
break|break
name|buildChar
break|;
block|}
if|if
condition|(
name|firstByte
operator|==
literal|0x8e
condition|)
block|{
comment|// Code Set 2.
comment|//   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.
comment|//   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.
comment|// We don't know which we've got.
comment|// Treat it like EUC-JP.  If the data really was EUC-TW, the following two
comment|//   bytes will look like a well formed 2 byte char.
if|if
condition|(
name|secondByte
operator|<
literal|0xa1
condition|)
block|{
name|it
operator|.
name|error
operator|=
literal|true
expr_stmt|;
block|}
break|break
name|buildChar
break|;
block|}
if|if
condition|(
name|firstByte
operator|==
literal|0x8f
condition|)
block|{
comment|// Code set 3.
comment|// Three byte total char size, two bytes of actual char value.
name|thirdByte
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
name|it
operator|.
name|charValue
operator|=
operator|(
name|it
operator|.
name|charValue
operator|<<
literal|8
operator|)
operator||
name|thirdByte
expr_stmt|;
if|if
condition|(
name|thirdByte
operator|<
literal|0xa1
condition|)
block|{
name|it
operator|.
name|error
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|it
operator|.
name|done
operator|==
literal|false
operator|)
return|;
block|}
comment|/**          * The charset recognize for EUC-JP.  A singleton instance of this class          * is created and kept by the public CharsetDetector class          */
specifier|static
class|class
name|CharsetRecog_euc_jp
extends|extends
name|CharsetRecog_euc
block|{
specifier|static
name|int
index|[]
name|commonChars
init|=
comment|// TODO:  This set of data comes from the character frequency-
comment|//        of-occurence analysis tool.  The data needs to be moved
comment|//        into a resource and loaded from there.
block|{
literal|0xa1a1
block|,
literal|0xa1a2
block|,
literal|0xa1a3
block|,
literal|0xa1a6
block|,
literal|0xa1bc
block|,
literal|0xa1ca
block|,
literal|0xa1cb
block|,
literal|0xa1d6
block|,
literal|0xa1d7
block|,
literal|0xa4a2
block|,
literal|0xa4a4
block|,
literal|0xa4a6
block|,
literal|0xa4a8
block|,
literal|0xa4aa
block|,
literal|0xa4ab
block|,
literal|0xa4ac
block|,
literal|0xa4ad
block|,
literal|0xa4af
block|,
literal|0xa4b1
block|,
literal|0xa4b3
block|,
literal|0xa4b5
block|,
literal|0xa4b7
block|,
literal|0xa4b9
block|,
literal|0xa4bb
block|,
literal|0xa4bd
block|,
literal|0xa4bf
block|,
literal|0xa4c0
block|,
literal|0xa4c1
block|,
literal|0xa4c3
block|,
literal|0xa4c4
block|,
literal|0xa4c6
block|,
literal|0xa4c7
block|,
literal|0xa4c8
block|,
literal|0xa4c9
block|,
literal|0xa4ca
block|,
literal|0xa4cb
block|,
literal|0xa4ce
block|,
literal|0xa4cf
block|,
literal|0xa4d0
block|,
literal|0xa4de
block|,
literal|0xa4df
block|,
literal|0xa4e1
block|,
literal|0xa4e2
block|,
literal|0xa4e4
block|,
literal|0xa4e8
block|,
literal|0xa4e9
block|,
literal|0xa4ea
block|,
literal|0xa4eb
block|,
literal|0xa4ec
block|,
literal|0xa4ef
block|,
literal|0xa4f2
block|,
literal|0xa4f3
block|,
literal|0xa5a2
block|,
literal|0xa5a3
block|,
literal|0xa5a4
block|,
literal|0xa5a6
block|,
literal|0xa5a7
block|,
literal|0xa5aa
block|,
literal|0xa5ad
block|,
literal|0xa5af
block|,
literal|0xa5b0
block|,
literal|0xa5b3
block|,
literal|0xa5b5
block|,
literal|0xa5b7
block|,
literal|0xa5b8
block|,
literal|0xa5b9
block|,
literal|0xa5bf
block|,
literal|0xa5c3
block|,
literal|0xa5c6
block|,
literal|0xa5c7
block|,
literal|0xa5c8
block|,
literal|0xa5c9
block|,
literal|0xa5cb
block|,
literal|0xa5d0
block|,
literal|0xa5d5
block|,
literal|0xa5d6
block|,
literal|0xa5d7
block|,
literal|0xa5de
block|,
literal|0xa5e0
block|,
literal|0xa5e1
block|,
literal|0xa5e5
block|,
literal|0xa5e9
block|,
literal|0xa5ea
block|,
literal|0xa5eb
block|,
literal|0xa5ec
block|,
literal|0xa5ed
block|,
literal|0xa5f3
block|,
literal|0xb8a9
block|,
literal|0xb9d4
block|,
literal|0xbaee
block|,
literal|0xbbc8
block|,
literal|0xbef0
block|,
literal|0xbfb7
block|,
literal|0xc4ea
block|,
literal|0xc6fc
block|,
literal|0xc7bd
block|,
literal|0xcab8
block|,
literal|0xcaf3
block|,
literal|0xcbdc
block|,
literal|0xcdd1
block|}
decl_stmt|;
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"EUC-JP"
return|;
block|}
name|CharsetMatch
name|match
parameter_list|(
name|CharsetDetector
name|det
parameter_list|)
block|{
name|int
name|confidence
init|=
name|match
argument_list|(
name|det
argument_list|,
name|commonChars
argument_list|)
decl_stmt|;
return|return
name|confidence
operator|==
literal|0
condition|?
literal|null
else|:
operator|new
name|CharsetMatch
argument_list|(
name|det
argument_list|,
name|this
argument_list|,
name|confidence
argument_list|)
return|;
block|}
specifier|public
name|String
name|getLanguage
parameter_list|()
block|{
return|return
literal|"ja"
return|;
block|}
block|}
comment|/**          * The charset recognize for EUC-KR.  A singleton instance of this class          * is created and kept by the public CharsetDetector class          */
specifier|static
class|class
name|CharsetRecog_euc_kr
extends|extends
name|CharsetRecog_euc
block|{
specifier|static
name|int
index|[]
name|commonChars
init|=
comment|// TODO:  This set of data comes from the character frequency-
comment|//        of-occurence analysis tool.  The data needs to be moved
comment|//        into a resource and loaded from there.
block|{
literal|0xb0a1
block|,
literal|0xb0b3
block|,
literal|0xb0c5
block|,
literal|0xb0cd
block|,
literal|0xb0d4
block|,
literal|0xb0e6
block|,
literal|0xb0ed
block|,
literal|0xb0f8
block|,
literal|0xb0fa
block|,
literal|0xb0fc
block|,
literal|0xb1b8
block|,
literal|0xb1b9
block|,
literal|0xb1c7
block|,
literal|0xb1d7
block|,
literal|0xb1e2
block|,
literal|0xb3aa
block|,
literal|0xb3bb
block|,
literal|0xb4c2
block|,
literal|0xb4cf
block|,
literal|0xb4d9
block|,
literal|0xb4eb
block|,
literal|0xb5a5
block|,
literal|0xb5b5
block|,
literal|0xb5bf
block|,
literal|0xb5c7
block|,
literal|0xb5e9
block|,
literal|0xb6f3
block|,
literal|0xb7af
block|,
literal|0xb7c2
block|,
literal|0xb7ce
block|,
literal|0xb8a6
block|,
literal|0xb8ae
block|,
literal|0xb8b6
block|,
literal|0xb8b8
block|,
literal|0xb8bb
block|,
literal|0xb8e9
block|,
literal|0xb9ab
block|,
literal|0xb9ae
block|,
literal|0xb9cc
block|,
literal|0xb9ce
block|,
literal|0xb9fd
block|,
literal|0xbab8
block|,
literal|0xbace
block|,
literal|0xbad0
block|,
literal|0xbaf1
block|,
literal|0xbbe7
block|,
literal|0xbbf3
block|,
literal|0xbbfd
block|,
literal|0xbcad
block|,
literal|0xbcba
block|,
literal|0xbcd2
block|,
literal|0xbcf6
block|,
literal|0xbdba
block|,
literal|0xbdc0
block|,
literal|0xbdc3
block|,
literal|0xbdc5
block|,
literal|0xbec6
block|,
literal|0xbec8
block|,
literal|0xbedf
block|,
literal|0xbeee
block|,
literal|0xbef8
block|,
literal|0xbefa
block|,
literal|0xbfa1
block|,
literal|0xbfa9
block|,
literal|0xbfc0
block|,
literal|0xbfe4
block|,
literal|0xbfeb
block|,
literal|0xbfec
block|,
literal|0xbff8
block|,
literal|0xc0a7
block|,
literal|0xc0af
block|,
literal|0xc0b8
block|,
literal|0xc0ba
block|,
literal|0xc0bb
block|,
literal|0xc0bd
block|,
literal|0xc0c7
block|,
literal|0xc0cc
block|,
literal|0xc0ce
block|,
literal|0xc0cf
block|,
literal|0xc0d6
block|,
literal|0xc0da
block|,
literal|0xc0e5
block|,
literal|0xc0fb
block|,
literal|0xc0fc
block|,
literal|0xc1a4
block|,
literal|0xc1a6
block|,
literal|0xc1b6
block|,
literal|0xc1d6
block|,
literal|0xc1df
block|,
literal|0xc1f6
block|,
literal|0xc1f8
block|,
literal|0xc4a1
block|,
literal|0xc5cd
block|,
literal|0xc6ae
block|,
literal|0xc7cf
block|,
literal|0xc7d1
block|,
literal|0xc7d2
block|,
literal|0xc7d8
block|,
literal|0xc7e5
block|,
literal|0xc8ad
block|}
decl_stmt|;
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"EUC-KR"
return|;
block|}
name|CharsetMatch
name|match
parameter_list|(
name|CharsetDetector
name|det
parameter_list|)
block|{
name|int
name|confidence
init|=
name|match
argument_list|(
name|det
argument_list|,
name|commonChars
argument_list|)
decl_stmt|;
return|return
name|confidence
operator|==
literal|0
condition|?
literal|null
else|:
operator|new
name|CharsetMatch
argument_list|(
name|det
argument_list|,
name|this
argument_list|,
name|confidence
argument_list|)
return|;
block|}
specifier|public
name|String
name|getLanguage
parameter_list|()
block|{
return|return
literal|"ko"
return|;
block|}
block|}
block|}
comment|/**      * GB-18030 recognizer. Uses simplified Chinese statistics.      */
specifier|static
class|class
name|CharsetRecog_gb_18030
extends|extends
name|CharsetRecog_mbcs
block|{
specifier|static
name|int
index|[]
name|commonChars
init|=
comment|// TODO:  This set of data comes from the character frequency-
comment|//        of-occurence analysis tool.  The data needs to be moved
comment|//        into a resource and loaded from there.
block|{
literal|0xa1a1
block|,
literal|0xa1a2
block|,
literal|0xa1a3
block|,
literal|0xa1a4
block|,
literal|0xa1b0
block|,
literal|0xa1b1
block|,
literal|0xa1f1
block|,
literal|0xa1f3
block|,
literal|0xa3a1
block|,
literal|0xa3ac
block|,
literal|0xa3ba
block|,
literal|0xb1a8
block|,
literal|0xb1b8
block|,
literal|0xb1be
block|,
literal|0xb2bb
block|,
literal|0xb3c9
block|,
literal|0xb3f6
block|,
literal|0xb4f3
block|,
literal|0xb5bd
block|,
literal|0xb5c4
block|,
literal|0xb5e3
block|,
literal|0xb6af
block|,
literal|0xb6d4
block|,
literal|0xb6e0
block|,
literal|0xb7a2
block|,
literal|0xb7a8
block|,
literal|0xb7bd
block|,
literal|0xb7d6
block|,
literal|0xb7dd
block|,
literal|0xb8b4
block|,
literal|0xb8df
block|,
literal|0xb8f6
block|,
literal|0xb9ab
block|,
literal|0xb9c9
block|,
literal|0xb9d8
block|,
literal|0xb9fa
block|,
literal|0xb9fd
block|,
literal|0xbacd
block|,
literal|0xbba7
block|,
literal|0xbbd6
block|,
literal|0xbbe1
block|,
literal|0xbbfa
block|,
literal|0xbcbc
block|,
literal|0xbcdb
block|,
literal|0xbcfe
block|,
literal|0xbdcc
block|,
literal|0xbecd
block|,
literal|0xbedd
block|,
literal|0xbfb4
block|,
literal|0xbfc6
block|,
literal|0xbfc9
block|,
literal|0xc0b4
block|,
literal|0xc0ed
block|,
literal|0xc1cb
block|,
literal|0xc2db
block|,
literal|0xc3c7
block|,
literal|0xc4dc
block|,
literal|0xc4ea
block|,
literal|0xc5cc
block|,
literal|0xc6f7
block|,
literal|0xc7f8
block|,
literal|0xc8ab
block|,
literal|0xc8cb
block|,
literal|0xc8d5
block|,
literal|0xc8e7
block|,
literal|0xc9cf
block|,
literal|0xc9fa
block|,
literal|0xcab1
block|,
literal|0xcab5
block|,
literal|0xcac7
block|,
literal|0xcad0
block|,
literal|0xcad6
block|,
literal|0xcaf5
block|,
literal|0xcafd
block|,
literal|0xccec
block|,
literal|0xcdf8
block|,
literal|0xceaa
block|,
literal|0xcec4
block|,
literal|0xced2
block|,
literal|0xcee5
block|,
literal|0xcfb5
block|,
literal|0xcfc2
block|,
literal|0xcfd6
block|,
literal|0xd0c2
block|,
literal|0xd0c5
block|,
literal|0xd0d0
block|,
literal|0xd0d4
block|,
literal|0xd1a7
block|,
literal|0xd2aa
block|,
literal|0xd2b2
block|,
literal|0xd2b5
block|,
literal|0xd2bb
block|,
literal|0xd2d4
block|,
literal|0xd3c3
block|,
literal|0xd3d0
block|,
literal|0xd3fd
block|,
literal|0xd4c2
block|,
literal|0xd4da
block|,
literal|0xd5e2
block|,
literal|0xd6d0
block|}
decl_stmt|;
comment|/*          *  (non-Javadoc)          *  Get the next character value for EUC based encodings.          *  Character "value" is simply the raw bytes that make up the character          *     packed into an int.          */
name|boolean
name|nextChar
parameter_list|(
name|iteratedChar
name|it
parameter_list|,
name|CharsetDetector
name|det
parameter_list|)
block|{
name|it
operator|.
name|error
operator|=
literal|false
expr_stmt|;
name|int
name|firstByte
init|=
literal|0
decl_stmt|;
name|int
name|secondByte
init|=
literal|0
decl_stmt|;
name|int
name|thirdByte
init|=
literal|0
decl_stmt|;
name|int
name|fourthByte
init|=
literal|0
decl_stmt|;
name|buildChar
label|:
block|{
name|firstByte
operator|=
name|it
operator|.
name|charValue
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstByte
operator|<
literal|0
condition|)
block|{
comment|// Ran off the end of the input data
name|it
operator|.
name|done
operator|=
literal|true
expr_stmt|;
break|break
name|buildChar
break|;
block|}
if|if
condition|(
name|firstByte
operator|<=
literal|0x80
condition|)
block|{
comment|// single byte char
break|break
name|buildChar
break|;
block|}
name|secondByte
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
name|it
operator|.
name|charValue
operator|=
operator|(
name|it
operator|.
name|charValue
operator|<<
literal|8
operator|)
operator||
name|secondByte
expr_stmt|;
if|if
condition|(
name|firstByte
operator|>=
literal|0x81
operator|&&
name|firstByte
operator|<=
literal|0xFE
condition|)
block|{
comment|// Two byte Char
if|if
condition|(
operator|(
name|secondByte
operator|>=
literal|0x40
operator|&&
name|secondByte
operator|<=
literal|0x7E
operator|)
operator|||
operator|(
name|secondByte
operator|>=
literal|80
operator|&&
name|secondByte
operator|<=
literal|0xFE
operator|)
condition|)
block|{
break|break
name|buildChar
break|;
block|}
comment|// Four byte char
if|if
condition|(
name|secondByte
operator|>=
literal|0x30
operator|&&
name|secondByte
operator|<=
literal|0x39
condition|)
block|{
name|thirdByte
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
if|if
condition|(
name|thirdByte
operator|>=
literal|0x81
operator|&&
name|thirdByte
operator|<=
literal|0xFE
condition|)
block|{
name|fourthByte
operator|=
name|it
operator|.
name|nextByte
argument_list|(
name|det
argument_list|)
expr_stmt|;
if|if
condition|(
name|fourthByte
operator|>=
literal|0x30
operator|&&
name|fourthByte
operator|<=
literal|0x39
condition|)
block|{
name|it
operator|.
name|charValue
operator|=
operator|(
name|it
operator|.
name|charValue
operator|<<
literal|16
operator|)
operator||
operator|(
name|thirdByte
operator|<<
literal|8
operator|)
operator||
name|fourthByte
expr_stmt|;
break|break
name|buildChar
break|;
block|}
block|}
block|}
name|it
operator|.
name|error
operator|=
literal|true
expr_stmt|;
break|break
name|buildChar
break|;
block|}
block|}
return|return
operator|(
name|it
operator|.
name|done
operator|==
literal|false
operator|)
return|;
block|}
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"GB18030"
return|;
block|}
name|CharsetMatch
name|match
parameter_list|(
name|CharsetDetector
name|det
parameter_list|)
block|{
name|int
name|confidence
init|=
name|match
argument_list|(
name|det
argument_list|,
name|commonChars
argument_list|)
decl_stmt|;
return|return
name|confidence
operator|==
literal|0
condition|?
literal|null
else|:
operator|new
name|CharsetMatch
argument_list|(
name|det
argument_list|,
name|this
argument_list|,
name|confidence
argument_list|)
return|;
block|}
specifier|public
name|String
name|getLanguage
parameter_list|()
block|{
return|return
literal|"zh"
return|;
block|}
block|}
block|}
end_class

end_unit

