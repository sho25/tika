begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|dbf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_comment
comment|/**  * This reads many dbase3 file variants (not DBASE 7, yet!).  * This parses the header on open.  The client  * should get a row and then iterate until next() returns null.  * Be careful to deepCopy the row (if caching) because the row  * is mutable and will change as the reader iterates over new rows.  *<p>  * This is based on:<a href="http://web.archive.org/web/20150323061445/http://ulisse.elettra.trieste.it/services/doc/dbase/DBFstruct.htm">  * http://ulisse.elettra.trieste.it/services/doc/dbase/DBFstruct.htm</a>  *<p>  * This is designed to separate out Tika-specific code so that it can  * be copied/pasted as a standalone if desired.  */
end_comment

begin_class
class|class
name|DBFReader
block|{
specifier|public
specifier|static
specifier|final
name|int
name|MAX_FIELD_LENGTH
init|=
literal|66000
decl_stmt|;
specifier|public
specifier|static
name|boolean
name|STRICT
init|=
literal|false
decl_stmt|;
enum|enum
name|Version
block|{
name|FOXBASE
argument_list|(
literal|0x02
argument_list|,
literal|"FoxBASE"
argument_list|,
literal|""
argument_list|)
block|,
name|FOXBASE_PLUS
argument_list|(
literal|0x03
argument_list|,
literal|"FoxBASE_plus"
argument_list|,
literal|""
argument_list|)
block|,
name|VISUAL_FOXPRO
argument_list|(
literal|0x30
argument_list|,
literal|"Visual_FoxPro"
argument_list|,
literal|""
argument_list|)
block|,
name|VISUAL_FOXPRO_AUTOINCREMENT
argument_list|(
literal|0x31
argument_list|,
literal|"Visual_FoxPro"
argument_list|,
literal|"autoincrement"
argument_list|)
block|,
name|VISUAL_FOXPRO_VAR
argument_list|(
literal|0x32
argument_list|,
literal|"Visual_FoxPro"
argument_list|,
literal|"Varchar_or_Varbinary"
argument_list|)
block|,
name|DBASE_IV_SQL_TABLE
argument_list|(
literal|0x43
argument_list|,
literal|"dBASE_IV_SQL"
argument_list|,
literal|"table"
argument_list|)
block|,
name|DBASE_IV_SQL_SYSTEM
argument_list|(
literal|0x63
argument_list|,
literal|"dBASE_IV_SQL"
argument_list|,
literal|"system"
argument_list|)
block|,
name|FOX_BASE_PLUS_WITH_MEMO
argument_list|(
literal|0x83
argument_list|,
literal|"FoxBASE_plus"
argument_list|,
literal|"memo"
argument_list|)
block|,
name|DBASE_IV_WITH_MEMO
argument_list|(
literal|0x8B
argument_list|,
literal|"dBASE_IV"
argument_list|,
literal|"memo"
argument_list|)
block|,
name|DBASE_IV_SQL_TABLE_WITH_MEMO
argument_list|(
literal|0xCB
argument_list|,
literal|"dBASE_IV_SQL"
argument_list|,
literal|"table_with_memo"
argument_list|)
block|,
name|FOXPRO_2x_WITH_MEMO
argument_list|(
literal|0xF5
argument_list|,
literal|"FoxPro_2.x"
argument_list|,
literal|"memo"
argument_list|)
block|,
name|HIPER_SIZ_WITH_SMT_MEMO
argument_list|(
literal|0xE5
argument_list|,
literal|"HiPer-Siz"
argument_list|,
literal|"SMT_memo"
argument_list|)
block|,
name|FOXBASE2
argument_list|(
literal|0xFB
argument_list|,
literal|"FoxBASE"
argument_list|,
literal|""
argument_list|)
block|;
specifier|private
specifier|final
name|int
name|id
decl_stmt|;
specifier|private
specifier|final
name|String
name|format
decl_stmt|;
specifier|private
specifier|final
name|String
name|type
decl_stmt|;
name|Version
parameter_list|(
name|int
name|id
parameter_list|,
name|String
name|format
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
name|int
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
name|String
name|getFormat
parameter_list|()
block|{
return|return
name|format
return|;
block|}
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
name|String
name|getFullMimeString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"application/x-dbf; "
argument_list|)
operator|.
name|append
argument_list|(
literal|"format="
argument_list|)
operator|.
name|append
argument_list|(
name|getFormat
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"; type="
argument_list|)
operator|.
name|append
argument_list|(
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
empty_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Version
argument_list|>
name|VERSION_MAP
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
for|for
control|(
name|Version
name|version
range|:
name|Version
operator|.
name|values
argument_list|()
control|)
block|{
name|VERSION_MAP
operator|.
name|put
argument_list|(
name|version
operator|.
name|id
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|DBFReader
name|open
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
throws|,
name|TikaException
block|{
return|return
operator|new
name|DBFReader
argument_list|(
name|is
argument_list|)
return|;
block|}
comment|//can return null!
specifier|static
name|Version
name|getVersion
parameter_list|(
name|int
name|b
parameter_list|)
block|{
return|return
name|VERSION_MAP
operator|.
name|get
argument_list|(
name|b
argument_list|)
return|;
block|}
specifier|private
specifier|final
name|DBFFileHeader
name|header
decl_stmt|;
specifier|private
specifier|final
name|InputStream
name|is
decl_stmt|;
specifier|private
name|DBFRow
name|currRow
init|=
literal|null
decl_stmt|;
specifier|private
name|Charset
name|charset
init|=
name|StandardCharsets
operator|.
name|US_ASCII
decl_stmt|;
specifier|private
name|DBFReader
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
throws|,
name|TikaException
block|{
name|header
operator|=
name|DBFFileHeader
operator|.
name|parse
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|this
operator|.
name|is
operator|=
name|is
expr_stmt|;
name|currRow
operator|=
operator|new
name|DBFRow
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
comment|/**      * Iterate through the rows with this.      *<p>      * Be careful: the reader reuses the row!  Make sure to call deep copy      * if you are buffering rows.      *      * @return      * @throws IOException      * @throws TikaException      */
name|DBFRow
name|next
parameter_list|()
throws|throws
name|IOException
throws|,
name|TikaException
block|{
if|if
condition|(
name|fillRow
argument_list|(
name|currRow
argument_list|)
condition|)
block|{
return|return
name|currRow
return|;
block|}
return|return
literal|null
return|;
block|}
comment|//returns whether or not some content was read.
comment|//it might not be complete!
specifier|private
name|boolean
name|fillRow
parameter_list|(
name|DBFRow
name|row
parameter_list|)
throws|throws
name|IOException
throws|,
name|TikaException
block|{
if|if
condition|(
name|row
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|DBFCell
index|[]
name|cells
init|=
name|row
operator|.
name|cells
decl_stmt|;
name|int
name|isDeletedByte
init|=
name|is
operator|.
name|read
argument_list|()
decl_stmt|;
name|boolean
name|isDeleted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|isDeletedByte
operator|==
literal|32
condition|)
block|{
comment|//all ok
block|}
elseif|else
if|if
condition|(
name|isDeletedByte
operator|==
literal|42
condition|)
block|{
comment|//asterisk
name|isDeleted
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDeletedByte
operator|==
literal|26
condition|)
block|{
comment|//marker for end of dbf file
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|isDeletedByte
operator|==
operator|-
literal|1
condition|)
block|{
comment|//truncated file
if|if
condition|(
name|DBFReader
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"EOF reached too early"
argument_list|)
throw|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"Expecting space or asterisk at beginning of record, not:"
operator|+
name|isDeletedByte
argument_list|)
throw|;
block|}
name|row
operator|.
name|setDeleted
argument_list|(
name|isDeleted
argument_list|)
expr_stmt|;
name|boolean
name|readSomeContent
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cells
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cells
index|[
name|i
index|]
operator|.
name|read
argument_list|(
name|is
argument_list|)
condition|)
block|{
name|readSomeContent
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|readSomeContent
return|;
block|}
specifier|public
name|DBFFileHeader
name|getHeader
parameter_list|()
block|{
return|return
name|header
return|;
block|}
specifier|public
name|Charset
name|getCharset
parameter_list|()
block|{
return|return
name|charset
return|;
block|}
comment|/**      * removes trailing 0 from byte array      *      * @param bytes      * @return      */
specifier|public
specifier|static
name|byte
index|[]
name|trim
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|int
name|end
init|=
name|bytes
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|end
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|bytes
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|end
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|end
operator|==
name|bytes
operator|.
name|length
operator|-
literal|1
condition|)
block|{
return|return
name|bytes
return|;
block|}
name|byte
index|[]
name|ret
init|=
operator|new
name|byte
index|[
name|end
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|0
argument_list|,
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_class

end_unit

