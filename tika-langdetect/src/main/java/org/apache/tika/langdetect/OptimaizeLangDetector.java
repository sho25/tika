begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|langdetect
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|CharArrayWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|language
operator|.
name|detect
operator|.
name|LanguageConfidence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|language
operator|.
name|detect
operator|.
name|LanguageDetector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|language
operator|.
name|detect
operator|.
name|LanguageNames
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|language
operator|.
name|detect
operator|.
name|LanguageResult
import|;
end_import

begin_import
import|import
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|DetectedLanguage
import|;
end_import

begin_import
import|import
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|LanguageDetectorBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|i18n
operator|.
name|LdLocale
import|;
end_import

begin_import
import|import
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|ngram
operator|.
name|NgramExtractors
import|;
end_import

begin_import
import|import
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|profiles
operator|.
name|BuiltInLanguages
import|;
end_import

begin_import
import|import
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|profiles
operator|.
name|LanguageProfile
import|;
end_import

begin_import
import|import
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|profiles
operator|.
name|LanguageProfileReader
import|;
end_import

begin_comment
comment|/**  * Implementation of the LanguageDetector API that uses  * https://github.com/optimaize/language-detector  */
end_comment

begin_class
specifier|public
class|class
name|OptimaizeLangDetector
extends|extends
name|LanguageDetector
block|{
specifier|private
specifier|static
specifier|final
name|int
name|MAX_CHARS_FOR_DETECTION
init|=
literal|20000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_CHARS_FOR_SHORT_DETECTION
init|=
literal|200
decl_stmt|;
specifier|private
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|LanguageDetector
name|detector
decl_stmt|;
specifier|private
name|CharArrayWriter
name|writer
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|languages
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|languageProbabilities
decl_stmt|;
specifier|public
name|OptimaizeLangDetector
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|writer
operator|=
operator|new
name|CharArrayWriter
argument_list|(
name|MAX_CHARS_FOR_DETECTION
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|LanguageDetector
name|loadModels
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|LanguageProfile
argument_list|>
name|languageProfiles
init|=
operator|new
name|LanguageProfileReader
argument_list|()
operator|.
name|readAllBuiltIn
argument_list|()
decl_stmt|;
comment|// FUTURE when the "language-detector" project supports short profiles, check if
comment|// isShortText() returns true and switch to those.
name|languages
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|LanguageProfile
name|profile
range|:
name|languageProfiles
control|)
block|{
name|languages
operator|.
name|add
argument_list|(
name|makeLanguageName
argument_list|(
name|profile
operator|.
name|getLocale
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|detector
operator|=
name|createDetector
argument_list|(
name|languageProfiles
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
name|String
name|makeLanguageName
parameter_list|(
name|LdLocale
name|locale
parameter_list|)
block|{
return|return
name|LanguageNames
operator|.
name|makeName
argument_list|(
name|locale
operator|.
name|getLanguage
argument_list|()
argument_list|,
name|locale
operator|.
name|getScript
argument_list|()
operator|.
name|orNull
argument_list|()
argument_list|,
name|locale
operator|.
name|getRegion
argument_list|()
operator|.
name|orNull
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|LanguageDetector
name|loadModels
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|languages
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Normalize languages.
name|this
operator|.
name|languages
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|languages
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|language
range|:
name|languages
control|)
block|{
name|this
operator|.
name|languages
operator|.
name|add
argument_list|(
name|LanguageNames
operator|.
name|normalizeName
argument_list|(
name|language
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO what happens if you request a language that has no profile?
name|Set
argument_list|<
name|LdLocale
argument_list|>
name|locales
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LdLocale
name|locale
range|:
name|BuiltInLanguages
operator|.
name|getLanguages
argument_list|()
control|)
block|{
name|String
name|languageName
init|=
name|makeLanguageName
argument_list|(
name|locale
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|languages
operator|.
name|contains
argument_list|(
name|languageName
argument_list|)
condition|)
block|{
name|locales
operator|.
name|add
argument_list|(
name|locale
argument_list|)
expr_stmt|;
block|}
block|}
name|detector
operator|=
name|createDetector
argument_list|(
operator|new
name|LanguageProfileReader
argument_list|()
operator|.
name|readBuiltIn
argument_list|(
name|locales
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
name|com
operator|.
name|optimaize
operator|.
name|langdetect
operator|.
name|LanguageDetector
name|createDetector
parameter_list|(
name|List
argument_list|<
name|LanguageProfile
argument_list|>
name|languageProfiles
parameter_list|)
block|{
comment|// FUTURE currently the short text algorithm doesn't normalize probabilities until the end, which
comment|// means you can often get 0 probabilities. So we pick a very short length for this limit.
name|LanguageDetectorBuilder
name|builder
init|=
name|LanguageDetectorBuilder
operator|.
name|create
argument_list|(
name|NgramExtractors
operator|.
name|standard
argument_list|()
argument_list|)
operator|.
name|shortTextAlgorithm
argument_list|(
literal|30
argument_list|)
operator|.
name|withProfiles
argument_list|(
name|languageProfiles
argument_list|)
decl_stmt|;
if|if
condition|(
name|languageProbabilities
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|LdLocale
argument_list|,
name|Double
argument_list|>
name|languageWeights
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|languageProbabilities
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|language
range|:
name|languageProbabilities
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Double
name|priority
init|=
operator|(
name|double
operator|)
name|languageProbabilities
operator|.
name|get
argument_list|(
name|language
argument_list|)
decl_stmt|;
name|languageWeights
operator|.
name|put
argument_list|(
name|LdLocale
operator|.
name|fromString
argument_list|(
name|language
argument_list|)
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|languagePriorities
argument_list|(
name|languageWeights
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasModel
parameter_list|(
name|String
name|language
parameter_list|)
block|{
return|return
name|languages
operator|.
name|contains
argument_list|(
name|language
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|LanguageDetector
name|setPriors
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|languageProbabilities
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|languageProbabilities
operator|=
name|languageProbabilities
expr_stmt|;
name|loadModels
argument_list|(
name|languageProbabilities
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|writer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addText
parameter_list|(
name|char
index|[]
name|cbuf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|hasEnoughText
argument_list|()
condition|)
block|{
return|return;
comment|// do nothing if we've already got enough text.
block|}
name|writer
operator|.
name|write
argument_list|(
name|cbuf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// FUTURE - use support to get padding char from NGramExtractors.standard().
comment|// We'd like to get the textPadding character from the NGramExtractor, but
comment|// that's not exposed. NGramExtractors.standard() returns extractor with ' '
comment|// as padding, so that's what we'll use here.
name|writer
operator|.
name|write
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/**          * {@inheritDoc}          *          * @throws IllegalStateException if no models have been loaded with          * {@link #loadModels() } or {@link #loadModels(java.util.Set) }          * @return the detected list of languages          */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|LanguageResult
argument_list|>
name|detectAll
parameter_list|()
block|{
if|if
condition|(
name|detector
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"models haven't been loaded yet (forgot to call loadModels?)"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|LanguageResult
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DetectedLanguage
argument_list|>
name|rawResults
init|=
name|detector
operator|.
name|getProbabilities
argument_list|(
name|writer
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|DetectedLanguage
name|rawResult
range|:
name|rawResults
control|)
block|{
comment|// TODO figure out right level for confidence brackets.
name|LanguageConfidence
name|confidence
init|=
name|rawResult
operator|.
name|getProbability
argument_list|()
operator|>
literal|0.9
condition|?
name|LanguageConfidence
operator|.
name|HIGH
else|:
name|LanguageConfidence
operator|.
name|MEDIUM
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
operator|new
name|LanguageResult
argument_list|(
name|makeLanguageName
argument_list|(
name|rawResult
operator|.
name|getLocale
argument_list|()
argument_list|)
argument_list|,
name|confidence
argument_list|,
operator|(
name|float
operator|)
name|rawResult
operator|.
name|getProbability
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|LanguageResult
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasEnoughText
parameter_list|()
block|{
return|return
name|writer
operator|.
name|size
argument_list|()
operator|>=
name|getTextLimit
argument_list|()
return|;
block|}
specifier|private
name|int
name|getTextLimit
parameter_list|()
block|{
name|int
name|limit
init|=
operator|(
name|shortText
condition|?
name|MAX_CHARS_FOR_SHORT_DETECTION
else|:
name|MAX_CHARS_FOR_DETECTION
operator|)
decl_stmt|;
comment|// We want more text if we're processing documents that have a mixture of languages.
comment|// FUTURE - figure out right amount to bump up the limit.
if|if
condition|(
name|mixedLanguages
condition|)
block|{
name|limit
operator|*=
literal|2
expr_stmt|;
block|}
return|return
name|limit
return|;
block|}
block|}
end_class

end_unit

