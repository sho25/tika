begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|batch
package|;
end_package

begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|extractor
operator|.
name|DocumentSelector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
specifier|abstract
class|class
name|FileResourceCrawler
implements|implements
name|Callable
argument_list|<
name|IFileProcessorFutureResult
argument_list|>
block|{
specifier|protected
specifier|final
specifier|static
name|int
name|SKIPPED
init|=
literal|0
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|int
name|ADDED
init|=
literal|1
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|int
name|STOP_NOW
init|=
literal|2
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|hasCompletedCrawling
init|=
literal|false
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|shutDownNoPoison
init|=
literal|false
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|isActive
init|=
literal|true
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|timedOut
init|=
literal|false
decl_stmt|;
comment|//how long to pause if can't add to queue
specifier|private
specifier|static
specifier|final
name|long
name|PAUSE_INCREMENT_MILLIS
init|=
literal|1000
decl_stmt|;
specifier|protected
specifier|static
name|Logger
name|logger
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FileResourceCrawler
operator|.
name|class
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|int
name|maxFilesToAdd
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|maxFilesToConsider
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|ArrayBlockingQueue
argument_list|<
name|FileResource
argument_list|>
name|queue
decl_stmt|;
specifier|private
specifier|final
name|int
name|numConsumers
decl_stmt|;
specifier|private
name|long
name|maxConsecWaitInMillis
init|=
literal|300000
decl_stmt|;
comment|//300,000ms = 5 minutes
specifier|private
name|DocumentSelector
name|documentSelector
init|=
literal|null
decl_stmt|;
comment|//number of files added to queue
specifier|private
name|int
name|added
init|=
literal|0
decl_stmt|;
comment|//number of files considered including those that were rejected by documentSelector
specifier|private
name|int
name|considered
init|=
literal|0
decl_stmt|;
comment|/**      * @param queue        shared queue      * @param numConsumers number of consumers (needs to know how many poisons to add when done)      */
specifier|public
name|FileResourceCrawler
parameter_list|(
name|ArrayBlockingQueue
argument_list|<
name|FileResource
argument_list|>
name|queue
parameter_list|,
name|int
name|numConsumers
parameter_list|)
block|{
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
name|this
operator|.
name|numConsumers
operator|=
name|numConsumers
expr_stmt|;
block|}
comment|/**      * Implement this to control the addition of FileResources.  Call {@link #tryToAdd}      * to add FileResources to the queue.      *      * @throws InterruptedException      */
specifier|public
specifier|abstract
name|void
name|start
parameter_list|()
throws|throws
name|InterruptedException
function_decl|;
specifier|public
name|FileResourceCrawlerFutureResult
name|call
parameter_list|()
block|{
try|try
block|{
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//this can be triggered by shutdownNow in BatchProcess
name|logger
operator|.
name|info
argument_list|(
literal|"InterruptedException in FileCrawler"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"Exception in FileResourceCrawler: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|isActive
operator|=
literal|false
expr_stmt|;
block|}
try|try
block|{
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//swallow
block|}
return|return
operator|new
name|FileResourceCrawlerFutureResult
argument_list|(
name|considered
argument_list|,
name|added
argument_list|)
return|;
block|}
comment|/**      *      * @param fileResource resource to add      * @return int status of the attempt (SKIPPED, ADDED, STOP_NOW) to add the resource to the queue.      * @throws InterruptedException      */
specifier|protected
name|int
name|tryToAdd
parameter_list|(
name|FileResource
name|fileResource
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|maxFilesToAdd
operator|>
operator|-
literal|1
operator|&&
name|added
operator|>=
name|maxFilesToAdd
condition|)
block|{
return|return
name|STOP_NOW
return|;
block|}
if|if
condition|(
name|maxFilesToConsider
operator|>
operator|-
literal|1
operator|&&
name|considered
operator|>
name|maxFilesToConsider
condition|)
block|{
return|return
name|STOP_NOW
return|;
block|}
name|boolean
name|isAdded
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|select
argument_list|(
name|fileResource
operator|.
name|getMetadata
argument_list|()
argument_list|)
condition|)
block|{
name|long
name|totalConsecutiveWait
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|queue
operator|.
name|offer
argument_list|(
name|fileResource
argument_list|,
literal|1L
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"FileResourceCrawler is pausing.  Queue is full: "
operator|+
name|queue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|PAUSE_INCREMENT_MILLIS
argument_list|)
expr_stmt|;
name|totalConsecutiveWait
operator|+=
name|PAUSE_INCREMENT_MILLIS
expr_stmt|;
if|if
condition|(
name|maxConsecWaitInMillis
operator|>
operator|-
literal|1
operator|&&
name|totalConsecutiveWait
operator|>
name|maxConsecWaitInMillis
condition|)
block|{
name|timedOut
operator|=
literal|true
expr_stmt|;
name|logger
operator|.
name|error
argument_list|(
literal|"Crawler had to wait longer than max consecutive wait time."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|(
literal|"FileResourceCrawler had to wait longer than max consecutive wait time."
argument_list|)
throw|;
block|}
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"FileResourceCrawler shutting down because of interrupted thread."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|(
literal|"FileResourceCrawler interrupted."
argument_list|)
throw|;
block|}
block|}
name|isAdded
operator|=
literal|true
expr_stmt|;
name|added
operator|++
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"crawler did not select: "
operator|+
name|fileResource
operator|.
name|getResourceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|considered
operator|++
expr_stmt|;
return|return
operator|(
name|isAdded
operator|)
condition|?
name|ADDED
else|:
name|SKIPPED
return|;
block|}
comment|//Warning! Depending on the value of maxConsecWaitInMillis
comment|//this could try forever in vain to add poison to the queue.
specifier|private
name|void
name|shutdown
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"FileResourceCrawler entering shutdown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasCompletedCrawling
operator|||
name|shutDownNoPoison
condition|)
block|{
return|return;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
name|long
name|start
init|=
operator|new
name|Date
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
while|while
condition|(
name|queue
operator|.
name|offer
argument_list|(
operator|new
name|PoisonFileResource
argument_list|()
argument_list|,
literal|1L
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
if|if
condition|(
name|shutDownNoPoison
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"quitting the poison loop because shutDownNoPoison is now true"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"thread interrupted while trying to add poison"
argument_list|)
expr_stmt|;
return|return;
block|}
name|long
name|elapsed
init|=
operator|new
name|Date
argument_list|()
operator|.
name|getTime
argument_list|()
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|maxConsecWaitInMillis
operator|>
operator|-
literal|1
operator|&&
name|elapsed
operator|>
name|maxConsecWaitInMillis
condition|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"Crawler timed out while trying to add poison"
argument_list|)
expr_stmt|;
return|return;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"added "
operator|+
name|i
operator|+
literal|" number of PoisonFileResource(s)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>=
name|numConsumers
condition|)
block|{
break|break;
block|}
block|}
name|hasCompletedCrawling
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * If the crawler stops for any reason, it is no longer active.      *      * @return whether crawler is active or not      */
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|isActive
return|;
block|}
specifier|public
name|void
name|setMaxConsecWaitInMillis
parameter_list|(
name|long
name|maxConsecWaitInMillis
parameter_list|)
block|{
name|this
operator|.
name|maxConsecWaitInMillis
operator|=
name|maxConsecWaitInMillis
expr_stmt|;
block|}
specifier|public
name|void
name|setDocumentSelector
parameter_list|(
name|DocumentSelector
name|documentSelector
parameter_list|)
block|{
name|this
operator|.
name|documentSelector
operator|=
name|documentSelector
expr_stmt|;
block|}
specifier|public
name|int
name|getConsidered
parameter_list|()
block|{
return|return
name|considered
return|;
block|}
specifier|protected
name|boolean
name|select
parameter_list|(
name|Metadata
name|m
parameter_list|)
block|{
return|return
name|documentSelector
operator|.
name|select
argument_list|(
name|m
argument_list|)
return|;
block|}
comment|/**      * Maximum number of files to add.  If {@link #maxFilesToAdd}< 0 (default),      * then this crawler will add all documents.      *      * @param maxFilesToAdd maximum number of files to add to the queue      */
specifier|public
name|void
name|setMaxFilesToAdd
parameter_list|(
name|int
name|maxFilesToAdd
parameter_list|)
block|{
name|this
operator|.
name|maxFilesToAdd
operator|=
name|maxFilesToAdd
expr_stmt|;
block|}
comment|/**      * Maximum number of files to consider.  A file is considered      * whether or not the DocumentSelector selects a document.      *<p/>      * If {@link #maxFilesToConsider}< 0 (default), then this crawler      * will add all documents.      *      * @param maxFilesToConsider maximum number of files to consider adding to the queue      */
specifier|public
name|void
name|setMaxFilesToConsider
parameter_list|(
name|int
name|maxFilesToConsider
parameter_list|)
block|{
name|this
operator|.
name|maxFilesToConsider
operator|=
name|maxFilesToConsider
expr_stmt|;
block|}
comment|/**      * Use sparingly.  This synchronizes on the queue!      * @return whether this queue contains any non-poison file resources      */
specifier|public
name|boolean
name|isQueueEmpty
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|queue
init|)
block|{
for|for
control|(
name|FileResource
name|aQueue
range|:
name|queue
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|aQueue
operator|instanceof
name|PoisonFileResource
operator|)
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|size
operator|==
literal|0
return|;
block|}
comment|/**      * Returns whether the crawler timed out while trying to add a resource      * to the queue.      *<p/>      * If the crawler timed out while trying to add poison, this is not      * set to true.      *      * @return whether this was timed out or not      */
specifier|public
name|boolean
name|wasTimedOut
parameter_list|()
block|{
return|return
name|timedOut
return|;
block|}
comment|/**      *      * @return number of files that this crawler added to the queue      */
specifier|public
name|int
name|getAdded
parameter_list|()
block|{
return|return
name|added
return|;
block|}
comment|/**      * Set to true to shut down the FileResourceCrawler without      * adding poison.  Do this only if you've already called another mechanism      * to request that consumers shut down.  This prevents a potential deadlock issue      * where the crawler is trying to add to the queue, but it is full.      *      * @return      */
specifier|public
name|void
name|shutDownNoPoison
parameter_list|()
block|{
name|this
operator|.
name|shutDownNoPoison
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_class

end_unit

