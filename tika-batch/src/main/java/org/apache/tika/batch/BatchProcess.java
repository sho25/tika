begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|batch
package|;
end_package

begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorCompletionService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This is the main processor class for a single process.  * This class can only be run once.  *<p/>  * It requires a {@link FileResourceCrawler} and {@link FileResourceConsumer}s, and it can also  * support a {@link StatusReporter} and an {@link Interrupter}.  *<p/>  * This is designed to shutdown if a parser has timed out or if there is  * an OutOfMemoryError. Consider using {@link BatchProcessDriverCLI}  * as a daemon/watchdog that monitors and can restart this batch process;  *<p>  * Note that this classs redirects stderr to stdout so that it can  * communicate without interference with the parent process on stderr.  */
end_comment

begin_class
specifier|public
class|class
name|BatchProcess
implements|implements
name|Callable
argument_list|<
name|ParallelFileProcessingResult
argument_list|>
block|{
specifier|public
enum|enum
name|BATCH_CONSTANTS
block|{
name|BATCH_PROCESS_EXCEEDED_MAX_ALIVE_TIME
block|,
name|BATCH_PROCESS_FATAL_MUST_RESTART
block|}
specifier|private
enum|enum
name|CAUSE_FOR_TERMINATION
block|{
name|COMPLETED_NORMALLY
block|,
name|MAIN_LOOP_EXCEPTION_NO_RESTART
block|,
name|CONSUMERS_MANAGER_DIDNT_INIT_IN_TIME_NO_RESTART
block|,
name|MAIN_LOOP_EXCEPTION
block|,
name|CRAWLER_TIMED_OUT
block|,
name|TIMED_OUT_CONSUMER
block|,
name|PARENT_SHUTDOWN
block|,
name|BATCH_PROCESS_ALIVE_TOO_LONG
block|,     }
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BatchProcess
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|PrintStream
name|outputStreamWriter
decl_stmt|;
comment|// If a file hasn't been processed in this amount of time,
comment|// report it to the console. When the directory crawler has stopped, the thread will
comment|// be terminated and the file name will be logged
specifier|private
name|long
name|timeoutThresholdMillis
init|=
literal|5
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 5 minutes
specifier|private
name|long
name|timeoutCheckPulseMillis
init|=
literal|2
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|//2 minutes
comment|//if there was an early termination via the Interrupter
comment|//or because of an uncaught runtime throwable, pause
comment|//this long before shutting down to allow parsers to finish
specifier|private
name|long
name|pauseOnEarlyTerminationMillis
init|=
literal|30
operator|*
literal|1000
decl_stmt|;
comment|//30 seconds
specifier|private
specifier|final
name|long
name|consumersManagerMaxMillis
decl_stmt|;
comment|//maximum time that this process should stay alive
comment|//to avoid potential memory leaks, not a bad idea to shutdown
comment|//every hour or so.
specifier|private
name|int
name|maxAliveTimeSeconds
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|FileResourceCrawler
name|fileResourceCrawler
decl_stmt|;
specifier|private
specifier|final
name|ConsumersManager
name|consumersManager
decl_stmt|;
specifier|private
specifier|final
name|StatusReporter
name|reporter
decl_stmt|;
specifier|private
specifier|final
name|Interrupter
name|interrupter
decl_stmt|;
specifier|private
specifier|final
name|ArrayBlockingQueue
argument_list|<
name|FileStarted
argument_list|>
name|timedOuts
decl_stmt|;
specifier|private
name|boolean
name|alreadyExecuted
init|=
literal|false
decl_stmt|;
specifier|public
name|BatchProcess
parameter_list|(
name|FileResourceCrawler
name|fileResourceCrawler
parameter_list|,
name|ConsumersManager
name|consumersManager
parameter_list|,
name|StatusReporter
name|reporter
parameter_list|,
name|Interrupter
name|interrupter
parameter_list|)
block|{
name|this
operator|.
name|fileResourceCrawler
operator|=
name|fileResourceCrawler
expr_stmt|;
name|this
operator|.
name|consumersManager
operator|=
name|consumersManager
expr_stmt|;
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
name|this
operator|.
name|interrupter
operator|=
name|interrupter
expr_stmt|;
name|timedOuts
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<>
argument_list|(
name|consumersManager
operator|.
name|getConsumers
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|consumersManagerMaxMillis
operator|=
name|consumersManager
operator|.
name|getConsumersManagerMaxMillis
argument_list|()
expr_stmt|;
block|}
comment|/**      * Runs main execution loop.      *<p>      * Redirects stdout to stderr to keep clean communications      * over stdout with parent process      * @return result of the processing      * @throws InterruptedException      */
specifier|public
name|ParallelFileProcessingResult
name|call
parameter_list|()
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|alreadyExecuted
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can only execute BatchRunner once."
argument_list|)
throw|;
block|}
comment|//redirect streams; all organic warnings should go to System.err;
comment|//System.err should be redirected to System.out
name|PrintStream
name|sysErr
init|=
name|System
operator|.
name|err
decl_stmt|;
try|try
block|{
name|outputStreamWriter
operator|=
operator|new
name|PrintStream
argument_list|(
name|sysErr
argument_list|,
literal|true
argument_list|,
name|UTF_8
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't redirect streams"
argument_list|)
throw|;
block|}
name|System
operator|.
name|setErr
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
name|ParallelFileProcessingResult
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|int
name|numConsumers
init|=
name|consumersManager
operator|.
name|getConsumers
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// fileResourceCrawler, statusReporter, the Interrupter, timeoutChecker
name|int
name|numNonConsumers
init|=
literal|4
decl_stmt|;
name|ExecutorService
name|ex
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|numConsumers
operator|+
name|numNonConsumers
argument_list|)
decl_stmt|;
name|CompletionService
argument_list|<
name|IFileProcessorFutureResult
argument_list|>
name|completionService
init|=
operator|new
name|ExecutorCompletionService
argument_list|<>
argument_list|(
name|ex
argument_list|)
decl_stmt|;
name|TimeoutChecker
name|timeoutChecker
init|=
operator|new
name|TimeoutChecker
argument_list|()
decl_stmt|;
try|try
block|{
name|startConsumersManager
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BatchNoRestartError
name|e
parameter_list|)
block|{
return|return
operator|new
name|ParallelFileProcessingResult
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BatchProcessDriverCLI
operator|.
name|PROCESS_NO_RESTART_EXIT_CODE
argument_list|,
name|CAUSE_FOR_TERMINATION
operator|.
name|CONSUMERS_MANAGER_DIDNT_INIT_IN_TIME_NO_RESTART
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
name|State
name|state
init|=
name|mainLoop
argument_list|(
name|completionService
argument_list|,
name|timeoutChecker
argument_list|)
decl_stmt|;
name|result
operator|=
name|shutdown
argument_list|(
name|ex
argument_list|,
name|completionService
argument_list|,
name|timeoutChecker
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|shutdownConsumersManager
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"finishing up"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|State
name|mainLoop
parameter_list|(
name|CompletionService
argument_list|<
name|IFileProcessorFutureResult
argument_list|>
name|completionService
parameter_list|,
name|TimeoutChecker
name|timeoutChecker
parameter_list|)
block|{
name|alreadyExecuted
operator|=
literal|true
expr_stmt|;
name|State
name|state
init|=
operator|new
name|State
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"BatchProcess starting up"
argument_list|)
expr_stmt|;
name|state
operator|.
name|start
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|completionService
operator|.
name|submit
argument_list|(
name|interrupter
argument_list|)
expr_stmt|;
name|completionService
operator|.
name|submit
argument_list|(
name|fileResourceCrawler
argument_list|)
expr_stmt|;
name|completionService
operator|.
name|submit
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
name|completionService
operator|.
name|submit
argument_list|(
name|timeoutChecker
argument_list|)
expr_stmt|;
for|for
control|(
name|FileResourceConsumer
name|consumer
range|:
name|consumersManager
operator|.
name|getConsumers
argument_list|()
control|)
block|{
name|completionService
operator|.
name|submit
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|numConsumers
operator|=
name|consumersManager
operator|.
name|getConsumers
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
name|CAUSE_FOR_TERMINATION
name|causeForTermination
init|=
literal|null
decl_stmt|;
comment|//main processing loop
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|Future
argument_list|<
name|IFileProcessorFutureResult
argument_list|>
name|futureResult
init|=
name|completionService
operator|.
name|poll
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|futureResult
operator|!=
literal|null
condition|)
block|{
name|state
operator|.
name|removed
operator|++
expr_stmt|;
name|IFileProcessorFutureResult
name|result
init|=
name|futureResult
operator|.
name|get
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"result: "
operator|+
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|instanceof
name|FileConsumerFutureResult
condition|)
block|{
name|state
operator|.
name|consumersRemoved
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|instanceof
name|FileResourceCrawlerFutureResult
condition|)
block|{
name|state
operator|.
name|crawlersRemoved
operator|++
expr_stmt|;
if|if
condition|(
name|fileResourceCrawler
operator|.
name|wasTimedOut
argument_list|()
condition|)
block|{
name|causeForTermination
operator|=
name|CAUSE_FOR_TERMINATION
operator|.
name|CRAWLER_TIMED_OUT
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|instanceof
name|InterrupterFutureResult
condition|)
block|{
name|causeForTermination
operator|=
name|CAUSE_FOR_TERMINATION
operator|.
name|PARENT_SHUTDOWN
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|instanceof
name|TimeoutFutureResult
condition|)
block|{
name|causeForTermination
operator|=
name|CAUSE_FOR_TERMINATION
operator|.
name|TIMED_OUT_CONSUMER
expr_stmt|;
break|break;
block|}
comment|//only thing left should be StatusReporterResult
block|}
if|if
condition|(
name|state
operator|.
name|consumersRemoved
operator|>=
name|state
operator|.
name|numConsumers
condition|)
block|{
name|causeForTermination
operator|=
name|CAUSE_FOR_TERMINATION
operator|.
name|COMPLETED_NORMALLY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|aliveTooLong
argument_list|(
name|state
operator|.
name|start
argument_list|)
condition|)
block|{
name|causeForTermination
operator|=
name|CAUSE_FOR_TERMINATION
operator|.
name|BATCH_PROCESS_ALIVE_TOO_LONG
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|isNonRestart
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|causeForTermination
operator|=
name|CAUSE_FOR_TERMINATION
operator|.
name|MAIN_LOOP_EXCEPTION_NO_RESTART
expr_stmt|;
block|}
else|else
block|{
name|causeForTermination
operator|=
name|CAUSE_FOR_TERMINATION
operator|.
name|MAIN_LOOP_EXCEPTION
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Main loop execution exception: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|state
operator|.
name|causeForTermination
operator|=
name|causeForTermination
expr_stmt|;
return|return
name|state
return|;
block|}
specifier|private
name|ParallelFileProcessingResult
name|shutdown
parameter_list|(
name|ExecutorService
name|ex
parameter_list|,
name|CompletionService
argument_list|<
name|IFileProcessorFutureResult
argument_list|>
name|completionService
parameter_list|,
name|TimeoutChecker
name|timeoutChecker
parameter_list|,
name|State
name|state
parameter_list|)
block|{
name|reporter
operator|.
name|setIsShuttingDown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|added
init|=
name|fileResourceCrawler
operator|.
name|getAdded
argument_list|()
decl_stmt|;
name|int
name|considered
init|=
name|fileResourceCrawler
operator|.
name|getConsidered
argument_list|()
decl_stmt|;
comment|//TODO: figure out safe way to shutdown resource crawler
comment|//if it isn't.  Does it need to add poison at this point?
comment|//fileResourceCrawler.pleaseShutdown();
name|LOG
operator|.
name|trace
argument_list|(
literal|"about to shutdown"
argument_list|)
expr_stmt|;
comment|//Step 1: prevent uncalled threads from being started
name|ex
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|//Step 2: ask consumers to shutdown politely.
comment|//Under normal circumstances, they should all have completed by now.
for|for
control|(
name|FileResourceConsumer
name|consumer
range|:
name|consumersManager
operator|.
name|getConsumers
argument_list|()
control|)
block|{
name|consumer
operator|.
name|pleaseShutdown
argument_list|()
expr_stmt|;
block|}
comment|//The resourceCrawler should shutdown now.  No need for poison.
name|fileResourceCrawler
operator|.
name|shutDownNoPoison
argument_list|()
expr_stmt|;
comment|//if there are any active/asked-to-shutdown consumers, wait
comment|//a bit for those parsers to finish.
comment|//This can happen if the parent process dies
comment|//of if the crawler stops early, or ...
name|politelyAwaitTermination
argument_list|(
name|state
operator|.
name|causeForTermination
argument_list|)
expr_stmt|;
comment|//Step 3: Gloves come off.  We've tried to ask kindly before.
comment|//Now it is time shut down. This will corrupt
comment|//nio channels via thread interrupts!  Hopefully, everything
comment|//has shut down by now.
name|LOG
operator|.
name|trace
argument_list|(
literal|"About to shutdownNow()"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Runnable
argument_list|>
name|neverCalled
init|=
name|ex
operator|.
name|shutdownNow
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"TERMINATED {} : {} : {}"
argument_list|,
name|ex
operator|.
name|isTerminated
argument_list|()
argument_list|,
name|state
operator|.
name|consumersRemoved
argument_list|,
name|state
operator|.
name|crawlersRemoved
argument_list|)
expr_stmt|;
name|int
name|end
init|=
name|state
operator|.
name|numConsumers
operator|+
name|state
operator|.
name|numNonConsumers
operator|-
name|state
operator|.
name|removed
operator|-
name|neverCalled
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|end
condition|;
name|t
operator|++
control|)
block|{
name|Future
argument_list|<
name|IFileProcessorFutureResult
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
try|try
block|{
name|future
operator|=
name|completionService
operator|.
name|poll
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"thread interrupt while polling in final shutdown loop"
argument_list|)
expr_stmt|;
break|break;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"In while future==null loop in final shutdown loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|future
operator|==
literal|null
condition|)
block|{
break|break;
block|}
try|try
block|{
name|IFileProcessorFutureResult
name|result
init|=
name|future
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|instanceof
name|FileConsumerFutureResult
condition|)
block|{
name|FileConsumerFutureResult
name|consumerResult
init|=
operator|(
name|FileConsumerFutureResult
operator|)
name|result
decl_stmt|;
name|FileStarted
name|fileStarted
init|=
name|consumerResult
operator|.
name|getFileStarted
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"file started "
operator|+
name|fileStarted
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileStarted
operator|!=
literal|null
operator|&&
name|fileStarted
operator|.
name|getElapsedMillis
argument_list|()
operator|>
name|timeoutThresholdMillis
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} caused a file processor to hang or crash. You may need to remove "
operator|+
literal|"this file from your input set and rerun."
argument_list|,
name|fileStarted
operator|.
name|getResourceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|instanceof
name|FileResourceCrawlerFutureResult
condition|)
block|{
name|FileResourceCrawlerFutureResult
name|crawlerResult
init|=
operator|(
name|FileResourceCrawlerFutureResult
operator|)
name|result
decl_stmt|;
name|considered
operator|+=
name|crawlerResult
operator|.
name|getConsidered
argument_list|()
expr_stmt|;
name|added
operator|+=
name|crawlerResult
operator|.
name|getAdded
argument_list|()
expr_stmt|;
block|}
comment|//else ...we don't care about anything else stopping at this point
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Execution exception trying to shutdown after shutdownNow"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Interrupted exception trying to shutdown after shutdownNow"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|//do we need to restart?
name|String
name|restartMsg
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|PARENT_SHUTDOWN
operator|||
name|state
operator|.
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|MAIN_LOOP_EXCEPTION_NO_RESTART
condition|)
block|{
comment|//do not restart!!!
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|MAIN_LOOP_EXCEPTION
condition|)
block|{
name|restartMsg
operator|=
literal|"Uncaught consumer throwable"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|TIMED_OUT_CONSUMER
condition|)
block|{
if|if
condition|(
name|areResourcesPotentiallyRemaining
argument_list|()
condition|)
block|{
name|restartMsg
operator|=
literal|"Consumer timed out with resources remaining"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|BATCH_PROCESS_ALIVE_TOO_LONG
condition|)
block|{
name|restartMsg
operator|=
name|BATCH_CONSTANTS
operator|.
name|BATCH_PROCESS_EXCEEDED_MAX_ALIVE_TIME
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|.
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|CRAWLER_TIMED_OUT
condition|)
block|{
name|restartMsg
operator|=
literal|"Crawler timed out."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileResourceCrawler
operator|.
name|wasTimedOut
argument_list|()
condition|)
block|{
name|restartMsg
operator|=
literal|"Crawler was timed out."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileResourceCrawler
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|restartMsg
operator|=
literal|"Crawler is still active."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fileResourceCrawler
operator|.
name|isQueueEmpty
argument_list|()
condition|)
block|{
name|restartMsg
operator|=
literal|"Resources still exist for processing"
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"restart msg: "
operator|+
name|restartMsg
argument_list|)
expr_stmt|;
name|int
name|exitStatus
init|=
name|getExitStatus
argument_list|(
name|state
operator|.
name|causeForTermination
argument_list|,
name|restartMsg
argument_list|)
decl_stmt|;
comment|//need to re-check, report, mark timed out consumers
name|timeoutChecker
operator|.
name|checkForTimedOutConsumers
argument_list|()
expr_stmt|;
for|for
control|(
name|FileStarted
name|fs
range|:
name|timedOuts
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"A parser was still working on>{}< for {} milliseconds after it started. This exceeds the maxTimeoutMillis parameter"
argument_list|,
name|fs
operator|.
name|getResourceId
argument_list|()
argument_list|,
name|fs
operator|.
name|getElapsedMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|double
name|elapsed
init|=
operator|(
operator|(
name|double
operator|)
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
operator|(
name|double
operator|)
name|state
operator|.
name|start
operator|)
operator|/
literal|1000.0
decl_stmt|;
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|int
name|numExceptions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileResourceConsumer
name|c
range|:
name|consumersManager
operator|.
name|getConsumers
argument_list|()
control|)
block|{
name|processed
operator|+=
name|c
operator|.
name|getNumResourcesConsumed
argument_list|()
expr_stmt|;
name|numExceptions
operator|+=
name|c
operator|.
name|getNumHandledExceptions
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"returning "
operator|+
name|state
operator|.
name|causeForTermination
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParallelFileProcessingResult
argument_list|(
name|considered
argument_list|,
name|added
argument_list|,
name|processed
argument_list|,
name|numExceptions
argument_list|,
name|elapsed
argument_list|,
name|exitStatus
argument_list|,
name|state
operator|.
name|causeForTermination
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|private
class|class
name|State
block|{
name|long
name|start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numConsumers
init|=
literal|0
decl_stmt|;
name|int
name|numNonConsumers
init|=
literal|0
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
name|int
name|consumersRemoved
init|=
literal|0
decl_stmt|;
name|int
name|crawlersRemoved
init|=
literal|0
decl_stmt|;
name|CAUSE_FOR_TERMINATION
name|causeForTermination
init|=
literal|null
decl_stmt|;
block|}
specifier|private
name|void
name|startConsumersManager
parameter_list|()
block|{
if|if
condition|(
name|consumersManagerMaxMillis
operator|<
literal|0
condition|)
block|{
name|consumersManager
operator|.
name|init
argument_list|()
expr_stmt|;
return|return;
block|}
name|Thread
name|timed
init|=
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"about to start consumers manager"
argument_list|)
expr_stmt|;
name|consumersManager
operator|.
name|init
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"finished starting consumers manager"
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|//don't allow this thread to keep process alive
name|timed
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|timed
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|timed
operator|.
name|join
argument_list|(
name|consumersManagerMaxMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"interruption exception during consumers manager shutdown"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timed
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ConsumersManager did not start within {}ms"
argument_list|,
name|consumersManagerMaxMillis
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BatchNoRestartError
argument_list|(
literal|"ConsumersManager did not start within "
operator|+
name|consumersManagerMaxMillis
operator|+
literal|"ms"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|shutdownConsumersManager
parameter_list|()
block|{
if|if
condition|(
name|consumersManagerMaxMillis
operator|<
literal|0
condition|)
block|{
name|consumersManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
return|return;
block|}
name|Thread
name|timed
init|=
operator|new
name|Thread
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"starting to shutdown consumers manager"
argument_list|)
expr_stmt|;
name|consumersManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"finished shutting down consumers manager"
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|timed
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|timed
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|timed
operator|.
name|join
argument_list|(
name|consumersManagerMaxMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"interruption exception during consumers manager shutdown"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timed
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ConsumersManager was still alive during shutdown!"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BatchNoRestartError
argument_list|(
literal|"ConsumersManager did not shutdown within: "
operator|+
name|consumersManagerMaxMillis
operator|+
literal|"ms"
argument_list|)
throw|;
block|}
block|}
comment|/**      * This is used instead of awaitTermination(), because that interrupts      * the thread and then waits for its termination.  This politely waits.      *      * @param causeForTermination reason for termination.      */
specifier|private
name|void
name|politelyAwaitTermination
parameter_list|(
name|CAUSE_FOR_TERMINATION
name|causeForTermination
parameter_list|)
block|{
if|if
condition|(
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|COMPLETED_NORMALLY
condition|)
block|{
return|return;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
while|while
condition|(
name|countActiveConsumers
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Thread interrupted while trying to politelyAwaitTermination"
argument_list|)
expr_stmt|;
return|return;
block|}
name|long
name|elapsed
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|pauseOnEarlyTerminationMillis
operator|>
operator|-
literal|1
operator|&&
name|elapsed
operator|>
name|pauseOnEarlyTerminationMillis
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Waited after an early termination for {}ms, but there was at least one active consumer"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
specifier|private
name|boolean
name|isNonRestart
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|BatchNoRestartError
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
return|return
name|cause
operator|!=
literal|null
operator|&&
name|isNonRestart
argument_list|(
name|cause
argument_list|)
return|;
block|}
specifier|private
name|int
name|getExitStatus
parameter_list|(
name|CAUSE_FOR_TERMINATION
name|causeForTermination
parameter_list|,
name|String
name|restartMsg
parameter_list|)
block|{
if|if
condition|(
name|causeForTermination
operator|==
name|CAUSE_FOR_TERMINATION
operator|.
name|MAIN_LOOP_EXCEPTION_NO_RESTART
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|CAUSE_FOR_TERMINATION
operator|.
name|MAIN_LOOP_EXCEPTION_NO_RESTART
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|BatchProcessDriverCLI
operator|.
name|PROCESS_NO_RESTART_EXIT_CODE
return|;
block|}
if|if
condition|(
name|restartMsg
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|restartMsg
operator|.
name|equals
argument_list|(
name|BATCH_CONSTANTS
operator|.
name|BATCH_PROCESS_EXCEEDED_MAX_ALIVE_TIME
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|restartMsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
name|restartMsg
argument_list|)
expr_stmt|;
block|}
comment|//send over stdout wrapped in outputStreamWriter
name|outputStreamWriter
operator|.
name|println
argument_list|(
name|BATCH_CONSTANTS
operator|.
name|BATCH_PROCESS_FATAL_MUST_RESTART
operator|.
name|toString
argument_list|()
operator|+
literal|">> "
operator|+
name|restartMsg
argument_list|)
expr_stmt|;
name|outputStreamWriter
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|BatchProcessDriverCLI
operator|.
name|PROCESS_RESTART_EXIT_CODE
return|;
block|}
return|return
literal|0
return|;
block|}
comment|//could new FileResources be consumed from the Queue?
comment|//Because of race conditions, this can return a true
comment|//when the real answer is false.
comment|//This should never return false, though, if the answer is true!
specifier|private
name|boolean
name|areResourcesPotentiallyRemaining
parameter_list|()
block|{
if|if
condition|(
name|fileResourceCrawler
operator|.
name|isActive
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
operator|!
name|fileResourceCrawler
operator|.
name|isQueueEmpty
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|aliveTooLong
parameter_list|(
name|long
name|started
parameter_list|)
block|{
if|if
condition|(
name|maxAliveTimeSeconds
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
name|double
name|elapsedSeconds
init|=
call|(
name|double
call|)
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|started
argument_list|)
operator|/
operator|(
name|double
operator|)
literal|1000
decl_stmt|;
return|return
name|elapsedSeconds
operator|>
operator|(
name|double
operator|)
name|maxAliveTimeSeconds
return|;
block|}
comment|//snapshot of non-retired consumers; actual number may be smaller by the time
comment|//this returns a value!
specifier|private
name|int
name|countActiveConsumers
parameter_list|()
block|{
name|int
name|active
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FileResourceConsumer
name|consumer
range|:
name|consumersManager
operator|.
name|getConsumers
argument_list|()
control|)
block|{
if|if
condition|(
name|consumer
operator|.
name|isStillActive
argument_list|()
condition|)
block|{
name|active
operator|++
expr_stmt|;
block|}
block|}
return|return
name|active
return|;
block|}
comment|/**      * If there is an early termination via an interrupt or too many timed out consumers      * or because a consumer or other Runnable threw a Throwable, pause this long      * before killing the consumers and other threads.      *      * Typically makes sense for this to be the same or slightly larger than      * timeoutThresholdMillis      *      * @param pauseOnEarlyTerminationMillis how long to pause if there is an early termination      */
specifier|public
name|void
name|setPauseOnEarlyTerminationMillis
parameter_list|(
name|long
name|pauseOnEarlyTerminationMillis
parameter_list|)
block|{
name|this
operator|.
name|pauseOnEarlyTerminationMillis
operator|=
name|pauseOnEarlyTerminationMillis
expr_stmt|;
block|}
comment|/**      * The amount of time allowed before a consumer should be timed out.      *      * @param timeoutThresholdMillis threshold in milliseconds before declaring a consumer timed out      */
specifier|public
name|void
name|setTimeoutThresholdMillis
parameter_list|(
name|long
name|timeoutThresholdMillis
parameter_list|)
block|{
name|this
operator|.
name|timeoutThresholdMillis
operator|=
name|timeoutThresholdMillis
expr_stmt|;
block|}
specifier|public
name|void
name|setTimeoutCheckPulseMillis
parameter_list|(
name|long
name|timeoutCheckPulseMillis
parameter_list|)
block|{
name|this
operator|.
name|timeoutCheckPulseMillis
operator|=
name|timeoutCheckPulseMillis
expr_stmt|;
block|}
comment|/**      * The maximum amount of time that this process can be alive.  To avoid      * memory leaks, it is sometimes beneficial to shutdown (and restart) the      * process periodically.      *<p/>      * If the value is&lt; 0, the process will run until completion, interruption or exception.      *      * @param maxAliveTimeSeconds maximum amount of time in seconds to remain alive      */
specifier|public
name|void
name|setMaxAliveTimeSeconds
parameter_list|(
name|int
name|maxAliveTimeSeconds
parameter_list|)
block|{
name|this
operator|.
name|maxAliveTimeSeconds
operator|=
name|maxAliveTimeSeconds
expr_stmt|;
block|}
specifier|private
class|class
name|TimeoutChecker
implements|implements
name|Callable
argument_list|<
name|IFileProcessorFutureResult
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|TimeoutFutureResult
name|call
parameter_list|()
throws|throws
name|Exception
block|{
while|while
condition|(
name|timedOuts
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|timeoutCheckPulseMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Thread interrupted exception in TimeoutChecker"
argument_list|)
expr_stmt|;
break|break;
comment|//just stop.
block|}
name|checkForTimedOutConsumers
argument_list|()
expr_stmt|;
if|if
condition|(
name|countActiveConsumers
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No activeConsumers in TimeoutChecker"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"TimeoutChecker quitting: {}"
argument_list|,
name|timedOuts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|TimeoutFutureResult
argument_list|(
name|timedOuts
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|checkForTimedOutConsumers
parameter_list|()
block|{
for|for
control|(
name|FileResourceConsumer
name|consumer
range|:
name|consumersManager
operator|.
name|getConsumers
argument_list|()
control|)
block|{
name|FileStarted
name|fs
init|=
name|consumer
operator|.
name|checkForTimedOutMillis
argument_list|(
name|timeoutThresholdMillis
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
name|timedOuts
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
class|class
name|TimeoutFutureResult
implements|implements
name|IFileProcessorFutureResult
block|{
comment|//used to be used when more than one timeout was allowed
comment|//TODO: get rid of this?
specifier|private
specifier|final
name|int
name|timedOutCount
decl_stmt|;
specifier|private
name|TimeoutFutureResult
parameter_list|(
specifier|final
name|int
name|timedOutCount
parameter_list|)
block|{
name|this
operator|.
name|timedOutCount
operator|=
name|timedOutCount
expr_stmt|;
block|}
specifier|protected
name|int
name|getTimedOutCount
parameter_list|()
block|{
return|return
name|timedOutCount
return|;
block|}
block|}
block|}
end_class

end_unit

