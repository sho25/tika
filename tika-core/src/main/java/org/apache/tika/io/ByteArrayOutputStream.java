begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|SequenceInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * This class implements an output stream in which the data is   * written into a byte array. The buffer automatically grows as data   * is written to it.  *<p>   * The data can be retrieved using<code>toByteArray()</code> and  *<code>toString()</code>.  *<p>  * Closing a<tt>ByteArrayOutputStream</tt> has no effect. The methods in  * this class can be called after the stream has been closed without  * generating an<tt>IOException</tt>.  *<p>  * This is an alternative implementation of the java.io.ByteArrayOutputStream  * class. The original implementation only allocates 32 bytes at the beginning.  * As this class is designed for heavy duty it starts at 1024 bytes. In contrast  * to the original it doesn't reallocate the whole memory block but allocates  * additional buffers. This way no buffers need to be garbage collected and  * the contents don't have to be copied to the new buffer. This class is  * designed to behave exactly like the original. The only exception is the  * deprecated toString(int) method that has been ignored.  *   * @author<a href="mailto:jeremias@apache.org">Jeremias Maerki</a>  * @author Holger Hoffstatte  * @since Apache Tika 0.4, copied from Commons IO 1.4  */
end_comment

begin_class
specifier|public
class|class
name|ByteArrayOutputStream
extends|extends
name|OutputStream
block|{
comment|/** A singleton empty byte array. */
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_BYTE_ARRAY
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
comment|/** The list of buffers, which grows and never reduces. */
specifier|private
specifier|final
name|List
argument_list|<
name|byte
index|[]
argument_list|>
name|buffers
init|=
operator|new
name|ArrayList
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|/** The index of the current buffer. */
specifier|private
name|int
name|currentBufferIndex
decl_stmt|;
comment|/** The total count of bytes in all the filled buffers. */
specifier|private
name|int
name|filledBufferSum
decl_stmt|;
comment|/** The current buffer. */
specifier|private
name|byte
index|[]
name|currentBuffer
decl_stmt|;
comment|/** The total count of bytes written. */
specifier|private
name|int
name|count
decl_stmt|;
comment|/**      * Creates a new byte array output stream. The buffer capacity is       * initially 1024 bytes, though its size increases if necessary.       */
specifier|public
name|ByteArrayOutputStream
parameter_list|()
block|{
name|this
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new byte array output stream, with a buffer capacity of       * the specified size, in bytes.       *      * @param size  the initial size      * @throws IllegalArgumentException if size is negative      */
specifier|public
name|ByteArrayOutputStream
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Negative initial size: "
operator|+
name|size
argument_list|)
throw|;
block|}
name|needNewBuffer
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
comment|/**      * Makes a new buffer available either by allocating      * a new one or re-cycling an existing one.      *      * @param newcount  the size of the buffer if one is created      */
specifier|private
name|void
name|needNewBuffer
parameter_list|(
name|int
name|newcount
parameter_list|)
block|{
if|if
condition|(
name|currentBufferIndex
operator|<
name|buffers
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|//Recycling old buffer
name|filledBufferSum
operator|+=
name|currentBuffer
operator|.
name|length
expr_stmt|;
name|currentBufferIndex
operator|++
expr_stmt|;
name|currentBuffer
operator|=
name|buffers
operator|.
name|get
argument_list|(
name|currentBufferIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Creating new buffer
name|int
name|newBufferSize
decl_stmt|;
if|if
condition|(
name|currentBuffer
operator|==
literal|null
condition|)
block|{
name|newBufferSize
operator|=
name|newcount
expr_stmt|;
name|filledBufferSum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newBufferSize
operator|=
name|Math
operator|.
name|max
argument_list|(
name|currentBuffer
operator|.
name|length
operator|<<
literal|1
argument_list|,
name|newcount
operator|-
name|filledBufferSum
argument_list|)
expr_stmt|;
name|filledBufferSum
operator|+=
name|currentBuffer
operator|.
name|length
expr_stmt|;
block|}
name|currentBufferIndex
operator|++
expr_stmt|;
name|currentBuffer
operator|=
operator|new
name|byte
index|[
name|newBufferSize
index|]
expr_stmt|;
name|buffers
operator|.
name|add
argument_list|(
name|currentBuffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Write the bytes to byte array.      * @param b the bytes to write      * @param off The start offset      * @param len The number of bytes to write      */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|(
name|off
operator|<
literal|0
operator|)
operator|||
operator|(
name|off
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
name|len
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|>
name|b
operator|.
name|length
operator|)
operator|||
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|int
name|newcount
init|=
name|count
operator|+
name|len
decl_stmt|;
name|int
name|remaining
init|=
name|len
decl_stmt|;
name|int
name|inBufferPos
init|=
name|count
operator|-
name|filledBufferSum
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|int
name|part
init|=
name|Math
operator|.
name|min
argument_list|(
name|remaining
argument_list|,
name|currentBuffer
operator|.
name|length
operator|-
name|inBufferPos
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|len
operator|-
name|remaining
argument_list|,
name|currentBuffer
argument_list|,
name|inBufferPos
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|part
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|needNewBuffer
argument_list|(
name|newcount
argument_list|)
expr_stmt|;
name|inBufferPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|count
operator|=
name|newcount
expr_stmt|;
block|}
block|}
comment|/**      * Write a byte to byte array.      * @param b the byte to write      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
block|{
name|int
name|inBufferPos
init|=
name|count
operator|-
name|filledBufferSum
decl_stmt|;
if|if
condition|(
name|inBufferPos
operator|==
name|currentBuffer
operator|.
name|length
condition|)
block|{
name|needNewBuffer
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|inBufferPos
operator|=
literal|0
expr_stmt|;
block|}
name|currentBuffer
index|[
name|inBufferPos
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/**      * Writes the entire contents of the specified input stream to this      * byte stream. Bytes from the input stream are read directly into the      * internal buffers of this streams.      *      * @param in the input stream to read from      * @return total number of bytes read from the input stream      *         (and written to this stream)      * @throws IOException if an I/O error occurs while reading the input stream      * @since Commons IO 1.4      */
specifier|public
specifier|synchronized
name|int
name|write
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|readCount
init|=
literal|0
decl_stmt|;
name|int
name|inBufferPos
init|=
name|count
operator|-
name|filledBufferSum
decl_stmt|;
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|currentBuffer
argument_list|,
name|inBufferPos
argument_list|,
name|currentBuffer
operator|.
name|length
operator|-
name|inBufferPos
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
block|{
name|readCount
operator|+=
name|n
expr_stmt|;
name|inBufferPos
operator|+=
name|n
expr_stmt|;
name|count
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|inBufferPos
operator|==
name|currentBuffer
operator|.
name|length
condition|)
block|{
name|needNewBuffer
argument_list|(
name|currentBuffer
operator|.
name|length
argument_list|)
expr_stmt|;
name|inBufferPos
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|=
name|in
operator|.
name|read
argument_list|(
name|currentBuffer
argument_list|,
name|inBufferPos
argument_list|,
name|currentBuffer
operator|.
name|length
operator|-
name|inBufferPos
argument_list|)
expr_stmt|;
block|}
return|return
name|readCount
return|;
block|}
comment|/**      * Return the current size of the byte array.      * @return the current size of the byte array      */
specifier|public
specifier|synchronized
name|int
name|size
parameter_list|()
block|{
return|return
name|count
return|;
block|}
comment|/**      * Closing a<tt>ByteArrayOutputStream</tt> has no effect. The methods in      * this class can be called after the stream has been closed without      * generating an<tt>IOException</tt>.      *      * @throws IOException never (this method should not declare this exception      * but it has to now due to backwards compatability)      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|//nop
block|}
comment|/**      * @see java.io.ByteArrayOutputStream#reset()      */
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|filledBufferSum
operator|=
literal|0
expr_stmt|;
name|currentBufferIndex
operator|=
literal|0
expr_stmt|;
name|currentBuffer
operator|=
name|buffers
operator|.
name|get
argument_list|(
name|currentBufferIndex
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the entire contents of this byte stream to the      * specified output stream.      *      * @param out  the output stream to write to      * @throws IOException if an I/O error occurs, such as if the stream is closed      * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)      */
specifier|public
specifier|synchronized
name|void
name|writeTo
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|remaining
init|=
name|count
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|buf
range|:
name|buffers
control|)
block|{
name|int
name|c
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|length
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|c
expr_stmt|;
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/**      * Fetches entire contents of an<code>InputStream</code> and represent      * same data as result InputStream.      *<p>      * This method is useful where,      *<ul>      *<li>Source InputStream is slow.</li>      *<li>It has network resources associated, so we cannot keep it open for      * long time.</li>      *<li>It has network timeout associated.</li>      *</ul>      * It can be used in favor of {@link #toByteArray()}, since it      * avoids unnecessary allocation and copy of byte[].<br>      * This method buffers the input internally, so there is no need to use a      *<code>BufferedInputStream</code>.      *       * @param input Stream to be fully buffered.      * @return A fully buffered stream.      * @throws IOException if an I/O error occurs      */
specifier|public
specifier|static
name|InputStream
name|toBufferedInputStream
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|output
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|input
argument_list|)
expr_stmt|;
return|return
name|output
operator|.
name|toBufferedInputStream
argument_list|()
return|;
block|}
comment|/**      * Gets the current contents of this byte stream as a Input Stream. The      * returned stream is backed by buffers of<code>this</code> stream,      * avoiding memory allocation and copy, thus saving space and time.<br>      *       * @return the current contents of this output stream.      * @see java.io.ByteArrayOutputStream#toByteArray()      * @see #reset()      * @since Commons IO 2.0      */
specifier|private
name|InputStream
name|toBufferedInputStream
parameter_list|()
block|{
name|int
name|remaining
init|=
name|count
decl_stmt|;
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|ClosedInputStream
argument_list|()
return|;
block|}
name|List
argument_list|<
name|ByteArrayInputStream
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|ByteArrayInputStream
argument_list|>
argument_list|(
name|buffers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|buf
range|:
name|buffers
control|)
block|{
name|int
name|c
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|length
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|c
expr_stmt|;
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|new
name|SequenceInputStream
argument_list|(
name|Collections
operator|.
name|enumeration
argument_list|(
name|list
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Gets the curent contents of this byte stream as a byte array.      * The result is independent of this stream.      *      * @return the current contents of this output stream, as a byte array      * @see java.io.ByteArrayOutputStream#toByteArray()      */
specifier|public
specifier|synchronized
name|byte
index|[]
name|toByteArray
parameter_list|()
block|{
name|int
name|remaining
init|=
name|count
decl_stmt|;
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_BYTE_ARRAY
return|;
block|}
name|byte
name|newbuf
index|[]
init|=
operator|new
name|byte
index|[
name|remaining
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|buf
range|:
name|buffers
control|)
block|{
name|int
name|c
init|=
name|Math
operator|.
name|min
argument_list|(
name|buf
operator|.
name|length
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|newbuf
argument_list|,
name|pos
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|c
expr_stmt|;
name|remaining
operator|-=
name|c
expr_stmt|;
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
name|newbuf
return|;
block|}
comment|/**      * Gets the curent contents of this byte stream as a string.      * @return the contents of the byte array as a String      * @see java.io.ByteArrayOutputStream#toString()      */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|new
name|String
argument_list|(
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Gets the curent contents of this byte stream as a string      * using the specified encoding.      *      * @param enc  the name of the character encoding      * @return the string converted from the byte array      * @throws UnsupportedEncodingException if the encoding is not supported      * @see java.io.ByteArrayOutputStream#toString(String)      */
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|enc
parameter_list|)
throws|throws
name|UnsupportedEncodingException
block|{
return|return
operator|new
name|String
argument_list|(
name|toByteArray
argument_list|()
argument_list|,
name|enc
argument_list|)
return|;
block|}
block|}
end_class

end_unit

