begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|language
package|;
end_package

begin_comment
comment|// JDK imports
end_comment

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_comment
comment|/**  * This class runs a ngram analysis over submitted text, results might be used  * for automatic language identification.  *   * The similarity calculation is at experimental level. You have been warned.  *   * Methods are provided to build new NGramProfiles profiles.  *   * @author Sami Siren  * @author Jerome Charron - http://frutch.free.fr/  */
end_comment

begin_class
specifier|public
class|class
name|LanguageProfilerBuilder
block|{
comment|// public static final Log LOG =
comment|// LogFactory.getLog(LanguageProfilerBuilder.class);
comment|/** The minimum length allowed for a ngram. */
specifier|final
specifier|static
name|int
name|ABSOLUTE_MIN_NGRAM_LENGTH
init|=
literal|3
decl_stmt|;
comment|/* was 1 */
comment|/** The maximum length allowed for a ngram. */
specifier|final
specifier|static
name|int
name|ABSOLUTE_MAX_NGRAM_LENGTH
init|=
literal|3
decl_stmt|;
comment|/* was 4 */
comment|/** The default min length of ngram */
specifier|final
specifier|static
name|int
name|DEFAULT_MIN_NGRAM_LENGTH
init|=
literal|3
decl_stmt|;
comment|/** The default max length of ngram */
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_NGRAM_LENGTH
init|=
literal|3
decl_stmt|;
comment|/** The ngram profile file extension */
specifier|final
specifier|static
name|String
name|FILE_EXTENSION
init|=
literal|"ngp"
decl_stmt|;
comment|/** The profile max size (number of ngrams of the same size) */
specifier|final
specifier|static
name|int
name|MAX_SIZE
init|=
literal|1000
decl_stmt|;
comment|/** separator char */
specifier|final
specifier|static
name|char
name|SEPARATOR
init|=
literal|'_'
decl_stmt|;
comment|/** The String form of the separator char */
specifier|private
specifier|final
specifier|static
name|String
name|SEP_CHARSEQ
init|=
operator|new
name|String
argument_list|(
operator|new
name|char
index|[]
block|{
name|SEPARATOR
block|}
argument_list|)
decl_stmt|;
comment|/** The profile's name */
specifier|private
name|String
name|name
init|=
literal|null
decl_stmt|;
comment|/** The NGrams of this profile sorted on the number of occurrences */
specifier|private
name|List
argument_list|<
name|NGramEntry
argument_list|>
name|sorted
init|=
literal|null
decl_stmt|;
comment|/** The min length of ngram */
specifier|private
name|int
name|minLength
init|=
name|DEFAULT_MIN_NGRAM_LENGTH
decl_stmt|;
comment|/** The max length of ngram */
specifier|private
name|int
name|maxLength
init|=
name|DEFAULT_MAX_NGRAM_LENGTH
decl_stmt|;
comment|/** The total number of ngrams occurences */
specifier|private
name|int
index|[]
name|ngramcounts
init|=
literal|null
decl_stmt|;
comment|/** An index of the ngrams of the profile */
specifier|private
name|Map
argument_list|<
name|CharSequence
argument_list|,
name|NGramEntry
argument_list|>
name|ngrams
init|=
literal|null
decl_stmt|;
comment|/** A StringBuffer used during analysis */
specifier|private
name|QuickStringBuffer
name|word
init|=
operator|new
name|QuickStringBuffer
argument_list|()
decl_stmt|;
comment|/**      * Constructs a new ngram profile      *       * @param name is the name of the profile      * @param minlen is the min length of ngram sequences      * @param maxlen is the max length of ngram sequences      */
specifier|public
name|LanguageProfilerBuilder
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|minlen
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
comment|// TODO: Compute the initial capacity using minlen and maxlen.
name|this
operator|.
name|ngrams
operator|=
operator|new
name|HashMap
argument_list|<
name|CharSequence
argument_list|,
name|NGramEntry
argument_list|>
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|this
operator|.
name|minLength
operator|=
name|minlen
expr_stmt|;
name|this
operator|.
name|maxLength
operator|=
name|maxlen
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/**      * Constructs a new ngram profile where minlen=3, maxlen=3      *       * @param name is a name of profile, usually two length string      * @since Tika 1.0      */
specifier|public
name|LanguageProfilerBuilder
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|ngrams
operator|=
operator|new
name|HashMap
argument_list|<
name|CharSequence
argument_list|,
name|NGramEntry
argument_list|>
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|this
operator|.
name|minLength
operator|=
name|ABSOLUTE_MIN_NGRAM_LENGTH
expr_stmt|;
name|this
operator|.
name|maxLength
operator|=
name|ABSOLUTE_MAX_NGRAM_LENGTH
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/**      * @return Returns the name.      */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|// This method was commented because it depends on org.apache.lucene.analysis.Token
comment|// that is not a part of the Tika
comment|// /**
comment|// * Adds ngrams from a token to this profile
comment|// *
comment|// * @param t is the Token to be added
comment|// */
comment|// public void add(Token t) {
comment|// add(new StringBuffer().append(SEPARATOR)
comment|// .append(t.term())
comment|// .append(SEPARATOR));
comment|// }
comment|/**      * Adds ngrams from a single word to this profile      *       * @param word is the word to add      */
specifier|public
name|void
name|add
parameter_list|(
name|StringBuffer
name|word
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|minLength
init|;
operator|(
name|i
operator|<=
name|maxLength
operator|)
operator|&&
operator|(
name|i
operator|<
name|word
operator|.
name|length
argument_list|()
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|add
argument_list|(
name|word
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds the last NGrams from the specified word.      */
specifier|private
name|void
name|add
parameter_list|(
name|QuickStringBuffer
name|word
parameter_list|)
block|{
name|int
name|wlen
init|=
name|word
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|wlen
operator|>=
name|minLength
condition|)
block|{
name|int
name|max
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxLength
argument_list|,
name|wlen
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|minLength
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|add
argument_list|(
name|word
operator|.
name|subSequence
argument_list|(
name|wlen
operator|-
name|i
argument_list|,
name|wlen
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Adds ngrams from a single word in this profile      *       * @param word is the word to add      * @param n is the ngram size      */
specifier|private
name|void
name|add
parameter_list|(
name|CharSequence
name|cs
parameter_list|)
block|{
if|if
condition|(
name|cs
operator|.
name|equals
argument_list|(
name|SEP_CHARSEQ
argument_list|)
condition|)
block|{
return|return;
block|}
name|NGramEntry
name|nge
init|=
name|ngrams
operator|.
name|get
argument_list|(
name|cs
argument_list|)
decl_stmt|;
if|if
condition|(
name|nge
operator|==
literal|null
condition|)
block|{
name|nge
operator|=
operator|new
name|NGramEntry
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|ngrams
operator|.
name|put
argument_list|(
name|cs
argument_list|,
name|nge
argument_list|)
expr_stmt|;
block|}
name|nge
operator|.
name|inc
argument_list|()
expr_stmt|;
block|}
comment|/**      * Analyzes a piece of text      *       * @param text      *            the text to be analyzed      */
specifier|public
name|void
name|analyze
parameter_list|(
name|StringBuilder
name|text
parameter_list|)
block|{
if|if
condition|(
name|ngrams
operator|!=
literal|null
condition|)
block|{
name|ngrams
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sorted
operator|=
literal|null
expr_stmt|;
name|ngramcounts
operator|=
literal|null
expr_stmt|;
block|}
name|word
operator|.
name|clear
argument_list|()
operator|.
name|append
argument_list|(
name|SEPARATOR
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|Character
operator|.
name|toLowerCase
argument_list|(
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|add
argument_list|(
name|word
operator|.
name|append
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// found word boundary
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// we have a word!
name|add
argument_list|(
name|word
operator|.
name|append
argument_list|(
name|SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
name|word
operator|.
name|clear
argument_list|()
operator|.
name|append
argument_list|(
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|word
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// we have a word!
name|add
argument_list|(
name|word
operator|.
name|append
argument_list|(
name|SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|normalize
argument_list|()
expr_stmt|;
block|}
comment|/**      * @param word      * @param n sequence length      */
specifier|private
name|void
name|add
parameter_list|(
name|StringBuffer
name|word
parameter_list|,
name|int
name|n
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|word
operator|.
name|length
argument_list|()
operator|-
name|n
condition|;
name|i
operator|++
control|)
block|{
name|add
argument_list|(
name|word
operator|.
name|subSequence
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Normalizes the profile (calculates the ngrams frequencies)      */
specifier|protected
name|void
name|normalize
parameter_list|()
block|{
name|NGramEntry
name|e
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|NGramEntry
argument_list|>
name|i
init|=
name|ngrams
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// Calculates ngram count if not already done
if|if
condition|(
name|ngramcounts
operator|==
literal|null
condition|)
block|{
name|ngramcounts
operator|=
operator|new
name|int
index|[
name|maxLength
operator|+
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|e
operator|=
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|ngramcounts
index|[
name|e
operator|.
name|size
argument_list|()
index|]
operator|+=
name|e
operator|.
name|count
expr_stmt|;
block|}
block|}
name|i
operator|=
name|ngrams
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|e
operator|=
name|i
operator|.
name|next
argument_list|()
expr_stmt|;
name|e
operator|.
name|frequency
operator|=
operator|(
name|float
operator|)
name|e
operator|.
name|count
operator|/
operator|(
name|float
operator|)
name|ngramcounts
index|[
name|e
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
block|}
comment|/**      * Returns a sorted list of ngrams (sort done by 1. frequency 2. sequence)      *       * @return sorted vector of ngrams      */
specifier|public
name|List
argument_list|<
name|NGramEntry
argument_list|>
name|getSorted
parameter_list|()
block|{
comment|// make sure sorting is done only once
if|if
condition|(
name|sorted
operator|==
literal|null
condition|)
block|{
name|sorted
operator|=
operator|new
name|ArrayList
argument_list|<
name|NGramEntry
argument_list|>
argument_list|(
name|ngrams
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sorted
argument_list|)
expr_stmt|;
comment|// trim at NGRAM_LENGTH entries
if|if
condition|(
name|sorted
operator|.
name|size
argument_list|()
operator|>
name|MAX_SIZE
condition|)
block|{
name|sorted
operator|=
name|sorted
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|MAX_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sorted
return|;
block|}
comment|// Inherited JavaDoc
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
operator|.
name|append
argument_list|(
literal|"NGramProfile: "
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|NGramEntry
argument_list|>
name|i
init|=
name|getSorted
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|NGramEntry
name|entry
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|seq
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|count
argument_list|)
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|frequency
argument_list|)
operator|.
name|append
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Calculates a score how well NGramProfiles match each other      *       * @param another      *            ngram profile to compare against      * @return similarity 0=exact match      * @throws TikaException      *             if could not calculate a score      */
specifier|public
name|float
name|getSimilarity
parameter_list|(
name|LanguageProfilerBuilder
name|another
parameter_list|)
throws|throws
name|TikaException
block|{
name|float
name|sum
init|=
literal|0
decl_stmt|;
try|try
block|{
name|Iterator
argument_list|<
name|NGramEntry
argument_list|>
name|i
init|=
name|another
operator|.
name|getSorted
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|NGramEntry
name|other
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|ngrams
operator|.
name|containsKey
argument_list|(
name|other
operator|.
name|seq
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|Math
operator|.
name|abs
argument_list|(
operator|(
name|other
operator|.
name|frequency
operator|-
name|ngrams
operator|.
name|get
argument_list|(
name|other
operator|.
name|seq
argument_list|)
operator|.
name|frequency
operator|)
argument_list|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|sum
operator|+=
name|other
operator|.
name|frequency
expr_stmt|;
block|}
block|}
name|i
operator|=
name|getSorted
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|NGramEntry
name|other
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|another
operator|.
name|ngrams
operator|.
name|containsKey
argument_list|(
name|other
operator|.
name|seq
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|Math
operator|.
name|abs
argument_list|(
operator|(
name|other
operator|.
name|frequency
operator|-
name|another
operator|.
name|ngrams
operator|.
name|get
argument_list|(
name|other
operator|.
name|seq
argument_list|)
operator|.
name|frequency
operator|)
argument_list|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|sum
operator|+=
name|other
operator|.
name|frequency
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"Could not calculate a score how well NGramProfiles match each other"
argument_list|)
throw|;
block|}
return|return
name|sum
return|;
block|}
comment|/**      * Loads a ngram profile from an InputStream (assumes UTF-8 encoded content)      *       * @param is the InputStream to read      */
specifier|public
name|void
name|load
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
name|ngrams
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ngramcounts
operator|=
operator|new
name|int
index|[
name|maxLength
operator|+
literal|1
index|]
expr_stmt|;
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|line
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// # starts a comment line
if|if
condition|(
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'#'
condition|)
block|{
name|int
name|spacepos
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
decl_stmt|;
name|String
name|ngramsequence
init|=
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|spacepos
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|ngramsequence
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|>=
name|minLength
operator|)
operator|&&
operator|(
name|len
operator|<=
name|maxLength
operator|)
condition|)
block|{
name|int
name|ngramcount
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|spacepos
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|NGramEntry
name|en
init|=
operator|new
name|NGramEntry
argument_list|(
name|ngramsequence
argument_list|,
name|ngramcount
argument_list|)
decl_stmt|;
name|ngrams
operator|.
name|put
argument_list|(
name|en
operator|.
name|getSeq
argument_list|()
argument_list|,
name|en
argument_list|)
expr_stmt|;
name|ngramcounts
index|[
name|len
index|]
operator|+=
name|ngramcount
expr_stmt|;
block|}
block|}
block|}
name|normalize
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a new Language profile from (preferably quite large - 5-10k of      * lines) text file      *       * @param name to be given for the profile      * @param is a stream to be read      * @param encoding is the encoding of stream      *       * @throws TikaException if could not create a language profile      *        */
specifier|public
specifier|static
name|LanguageProfilerBuilder
name|create
parameter_list|(
name|String
name|name
parameter_list|,
name|InputStream
name|is
parameter_list|,
name|String
name|encoding
parameter_list|)
throws|throws
name|TikaException
block|{
name|LanguageProfilerBuilder
name|newProfile
init|=
operator|new
name|LanguageProfilerBuilder
argument_list|(
name|name
argument_list|,
name|ABSOLUTE_MIN_NGRAM_LENGTH
argument_list|,
name|ABSOLUTE_MAX_NGRAM_LENGTH
argument_list|)
decl_stmt|;
name|BufferedInputStream
name|bis
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|byte
name|buffer
index|[]
init|=
operator|new
name|byte
index|[
literal|4096
index|]
decl_stmt|;
name|StringBuilder
name|text
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|len
decl_stmt|;
try|try
block|{
while|while
condition|(
operator|(
name|len
operator|=
name|bis
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|text
operator|.
name|append
argument_list|(
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|TikaException
argument_list|(
literal|"Could not create profile, "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|newProfile
operator|.
name|analyze
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return
name|newProfile
return|;
block|}
comment|/**      * Writes NGramProfile content into OutputStream, content is outputted with      * UTF-8 encoding      *       * @param os the Stream to output to      *       * @throws IOException      */
specifier|public
name|void
name|save
parameter_list|(
name|OutputStream
name|os
parameter_list|)
throws|throws
name|IOException
block|{
name|os
operator|.
name|write
argument_list|(
operator|(
literal|"# NgramProfile generated at "
operator|+
operator|new
name|Date
argument_list|()
operator|+
literal|" for Apache Tika Language Identification\n"
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
comment|// And then each ngram
comment|// First dispatch ngrams in many lists depending on their size
comment|// (one list for each size, in order to store MAX_SIZE ngrams for each
comment|// size of ngram)
name|List
argument_list|<
name|NGramEntry
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|NGramEntry
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|NGramEntry
argument_list|>
name|sublist
init|=
operator|new
name|ArrayList
argument_list|<
name|NGramEntry
argument_list|>
argument_list|()
decl_stmt|;
name|NGramEntry
index|[]
name|entries
init|=
name|ngrams
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|NGramEntry
index|[
name|ngrams
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|minLength
init|;
name|i
operator|<=
name|maxLength
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|entries
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|entries
index|[
name|j
index|]
operator|.
name|getSeq
argument_list|()
operator|.
name|length
argument_list|()
operator|==
name|i
condition|)
block|{
name|sublist
operator|.
name|add
argument_list|(
name|entries
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|sublist
argument_list|)
expr_stmt|;
if|if
condition|(
name|sublist
operator|.
name|size
argument_list|()
operator|>
name|MAX_SIZE
condition|)
block|{
name|sublist
operator|=
name|sublist
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|MAX_SIZE
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|addAll
argument_list|(
name|sublist
argument_list|)
expr_stmt|;
name|sublist
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|NGramEntry
name|e
init|=
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|line
init|=
name|e
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|e
operator|.
name|getCount
argument_list|()
operator|+
literal|"\n"
decl_stmt|;
name|os
operator|.
name|write
argument_list|(
name|line
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|os
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * main method used for testing only      *       * @param args      */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
block|{
comment|// -create he sample_he.txt utf-8
name|String
name|usage
init|=
literal|"Usage: NGramProfile "
operator|+
literal|"[-create profilename filename encoding] "
operator|+
literal|"[-similarity file1 file2] "
operator|+
literal|"[-score profile-name filename encoding]"
decl_stmt|;
name|int
name|command
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|CREATE
init|=
literal|1
decl_stmt|;
specifier|final
name|int
name|SIMILARITY
init|=
literal|2
decl_stmt|;
specifier|final
name|int
name|SCORE
init|=
literal|3
decl_stmt|;
name|String
name|profilename
init|=
literal|""
decl_stmt|;
name|String
name|filename
init|=
literal|""
decl_stmt|;
name|String
name|filename2
init|=
literal|""
decl_stmt|;
name|String
name|encoding
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|usage
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// parse command line
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-create"
argument_list|)
condition|)
block|{
comment|// found -create option
name|command
operator|=
name|CREATE
expr_stmt|;
name|profilename
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
name|filename
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
name|encoding
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-similarity"
argument_list|)
condition|)
block|{
comment|// found -similarity option
name|command
operator|=
name|SIMILARITY
expr_stmt|;
name|filename
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
name|filename2
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
name|encoding
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-score"
argument_list|)
condition|)
block|{
comment|// found -Score option
name|command
operator|=
name|SCORE
expr_stmt|;
name|profilename
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
name|filename
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
name|encoding
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
try|try
block|{
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|CREATE
case|:
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|FileInputStream
name|fis
init|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|LanguageProfilerBuilder
name|newProfile
init|=
name|LanguageProfilerBuilder
operator|.
name|create
argument_list|(
name|profilename
argument_list|,
name|fis
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
name|fis
operator|.
name|close
argument_list|()
expr_stmt|;
name|f
operator|=
operator|new
name|File
argument_list|(
name|profilename
operator|+
literal|"."
operator|+
name|FILE_EXTENSION
argument_list|)
expr_stmt|;
name|FileOutputStream
name|fos
init|=
operator|new
name|FileOutputStream
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|newProfile
operator|.
name|save
argument_list|(
name|fos
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"new profile "
operator|+
name|profilename
operator|+
literal|"."
operator|+
name|FILE_EXTENSION
operator|+
literal|" was created."
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIMILARITY
case|:
name|f
operator|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fis
operator|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|newProfile
operator|=
name|LanguageProfilerBuilder
operator|.
name|create
argument_list|(
name|filename
argument_list|,
name|fis
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|newProfile
operator|.
name|normalize
argument_list|()
expr_stmt|;
name|f
operator|=
operator|new
name|File
argument_list|(
name|filename2
argument_list|)
expr_stmt|;
name|fis
operator|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|LanguageProfilerBuilder
name|newProfile2
init|=
name|LanguageProfilerBuilder
operator|.
name|create
argument_list|(
name|filename2
argument_list|,
name|fis
argument_list|,
name|encoding
argument_list|)
decl_stmt|;
name|newProfile2
operator|.
name|normalize
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Similarity is "
operator|+
name|newProfile
operator|.
name|getSimilarity
argument_list|(
name|newProfile2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCORE
case|:
name|f
operator|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fis
operator|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|newProfile
operator|=
name|LanguageProfilerBuilder
operator|.
name|create
argument_list|(
name|filename
argument_list|,
name|fis
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
name|f
operator|=
operator|new
name|File
argument_list|(
name|profilename
operator|+
literal|"."
operator|+
name|FILE_EXTENSION
argument_list|)
expr_stmt|;
name|fis
operator|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|LanguageProfilerBuilder
name|compare
init|=
operator|new
name|LanguageProfilerBuilder
argument_list|(
name|profilename
argument_list|,
name|DEFAULT_MIN_NGRAM_LENGTH
argument_list|,
name|DEFAULT_MAX_NGRAM_LENGTH
argument_list|)
decl_stmt|;
name|compare
operator|.
name|load
argument_list|(
name|fis
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Score is "
operator|+
name|compare
operator|.
name|getSimilarity
argument_list|(
name|newProfile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
comment|// throw new TikaException("");
block|}
block|}
comment|/**      * Inner class that describes a NGram      */
specifier|static
class|class
name|NGramEntry
implements|implements
name|Comparable
argument_list|<
name|NGramEntry
argument_list|>
block|{
comment|/** The NGRamProfile this NGram is related to */
specifier|private
name|LanguageProfilerBuilder
name|profile
init|=
literal|null
decl_stmt|;
comment|/** The sequence of characters of the ngram */
name|CharSequence
name|seq
init|=
literal|null
decl_stmt|;
comment|/** The number of occurences of this ngram in its profile */
specifier|private
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/** The frequency of this ngram in its profile */
specifier|private
name|float
name|frequency
init|=
literal|0.0F
decl_stmt|;
comment|/**          * Constructs a new NGramEntry          *           * @param seq is the sequence of characters of the ngram          */
specifier|public
name|NGramEntry
parameter_list|(
name|CharSequence
name|seq
parameter_list|)
block|{
name|this
operator|.
name|seq
operator|=
name|seq
expr_stmt|;
block|}
comment|/**          * Constructs a new NGramEntry          *           * @param seq is the sequence of characters of the ngram          * @param count is the number of occurrences of this ngram          */
specifier|public
name|NGramEntry
parameter_list|(
name|String
name|seq
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|this
operator|.
name|seq
operator|=
operator|new
name|StringBuffer
argument_list|(
name|seq
argument_list|)
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
name|seq
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
comment|/**          * Returns the number of occurrences of this ngram in its profile          *           * @return the number of occurrences of this ngram in its profile          */
specifier|public
name|int
name|getCount
parameter_list|()
block|{
return|return
name|count
return|;
block|}
comment|/**          * Returns the frequency of this ngram in its profile          *           * @return the frequency of this ngram in its profile          */
specifier|public
name|float
name|getFrequency
parameter_list|()
block|{
return|return
name|frequency
return|;
block|}
comment|/**          * Returns the sequence of characters of this ngram          *           * @return the sequence of characters of this ngram          */
specifier|public
name|CharSequence
name|getSeq
parameter_list|()
block|{
return|return
name|seq
return|;
block|}
comment|/**          * Returns the size of this ngram          *           * @return the size of this ngram          */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|seq
operator|.
name|length
argument_list|()
return|;
block|}
comment|// Inherited JavaDoc
specifier|public
name|int
name|compareTo
parameter_list|(
name|NGramEntry
name|ngram
parameter_list|)
block|{
name|int
name|diff
init|=
name|Float
operator|.
name|compare
argument_list|(
name|ngram
operator|.
name|getFrequency
argument_list|()
argument_list|,
name|frequency
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
return|return
name|diff
return|;
block|}
else|else
block|{
return|return
operator|(
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|ngram
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
return|;
block|}
block|}
comment|/**          * Increments the number of occurrences of this ngram.          */
specifier|public
name|void
name|inc
parameter_list|()
block|{
name|count
operator|++
expr_stmt|;
block|}
comment|/**          * Associated a profile to this ngram          *           * @param profile          *            is the profile associated to this ngram          */
specifier|public
name|void
name|setProfile
parameter_list|(
name|LanguageProfilerBuilder
name|profile
parameter_list|)
block|{
name|this
operator|.
name|profile
operator|=
name|profile
expr_stmt|;
block|}
comment|/**          * Returns the profile associated to this ngram          *           * @return the profile associated to this ngram          */
specifier|public
name|LanguageProfilerBuilder
name|getProfile
parameter_list|()
block|{
return|return
name|profile
return|;
block|}
comment|// Inherited JavaDoc
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|seq
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Inherited JavaDoc
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|seq
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|// Inherited JavaDoc
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
name|NGramEntry
name|ngram
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ngram
operator|=
operator|(
name|NGramEntry
operator|)
name|obj
expr_stmt|;
return|return
name|ngram
operator|.
name|seq
operator|.
name|equals
argument_list|(
name|seq
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|QuickStringBuffer
implements|implements
name|CharSequence
block|{
specifier|private
name|char
name|value
index|[]
decl_stmt|;
specifier|private
name|int
name|count
decl_stmt|;
name|QuickStringBuffer
parameter_list|()
block|{
name|this
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
name|QuickStringBuffer
parameter_list|(
name|char
index|[]
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|count
operator|=
name|value
operator|.
name|length
expr_stmt|;
block|}
name|QuickStringBuffer
parameter_list|(
name|int
name|length
parameter_list|)
block|{
name|value
operator|=
operator|new
name|char
index|[
name|length
index|]
expr_stmt|;
block|}
name|QuickStringBuffer
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|this
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|+
literal|16
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|length
parameter_list|()
block|{
return|return
name|count
return|;
block|}
specifier|private
name|void
name|expandCapacity
parameter_list|(
name|int
name|minimumCapacity
parameter_list|)
block|{
name|int
name|newCapacity
init|=
operator|(
name|value
operator|.
name|length
operator|+
literal|1
operator|)
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|newCapacity
operator|<
literal|0
condition|)
block|{
name|newCapacity
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minimumCapacity
operator|>
name|newCapacity
condition|)
block|{
name|newCapacity
operator|=
name|minimumCapacity
expr_stmt|;
block|}
name|char
name|newValue
index|[]
init|=
operator|new
name|char
index|[
name|newCapacity
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|newValue
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|value
operator|=
name|newValue
expr_stmt|;
block|}
name|QuickStringBuffer
name|clear
parameter_list|()
block|{
name|count
operator|=
literal|0
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|char
name|charAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|value
index|[
name|index
index|]
return|;
block|}
name|QuickStringBuffer
name|append
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
name|str
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|int
name|len
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|newcount
init|=
name|count
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|newcount
operator|>
name|value
operator|.
name|length
condition|)
block|{
name|expandCapacity
argument_list|(
name|newcount
argument_list|)
expr_stmt|;
block|}
name|str
operator|.
name|getChars
argument_list|(
literal|0
argument_list|,
name|len
argument_list|,
name|value
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
name|newcount
expr_stmt|;
return|return
name|this
return|;
block|}
name|QuickStringBuffer
name|append
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|int
name|newcount
init|=
name|count
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|newcount
operator|>
name|value
operator|.
name|length
condition|)
block|{
name|expandCapacity
argument_list|(
name|newcount
argument_list|)
expr_stmt|;
block|}
name|value
index|[
name|count
operator|++
index|]
operator|=
name|c
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|CharSequence
name|subSequence
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|value
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
operator|new
name|String
argument_list|(
name|this
operator|.
name|value
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

