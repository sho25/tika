begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|xmp
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|NotSerializableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Property
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|PropertyTypeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|xmp
operator|.
name|convert
operator|.
name|TikaToXMP
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|XMPDateTime
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|XMPException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|XMPIterator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|XMPMeta
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|XMPMetaFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|XMPSchemaRegistry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|XMPUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|options
operator|.
name|IteratorOptions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|options
operator|.
name|PropertyOptions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|options
operator|.
name|SerializeOptions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|adobe
operator|.
name|xmp
operator|.
name|properties
operator|.
name|XMPProperty
import|;
end_import

begin_comment
comment|/**  * Provides a conversion of the Metadata map from Tika to the XMP data model by also providing the  * Metadata API for clients to ease transition. But clients can also work directly on the XMP data  * model, by getting the XMPMeta reference from this class. Usually the instance would be  * initialized by providing the Metadata object that had been returned from Tika-core which  * populates the XMP data model with all properties that can be converted.  *  * This class is not serializable!  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|public
class|class
name|XMPMetadata
extends|extends
name|Metadata
block|{
comment|/** The XMP data */
specifier|private
name|XMPMeta
name|xmpData
decl_stmt|;
comment|/** Use the XMP namespace registry implementation */
specifier|private
specifier|static
specifier|final
name|XMPSchemaRegistry
name|registry
init|=
name|XMPMetaFactory
operator|.
name|getSchemaRegistry
argument_list|()
decl_stmt|;
comment|/**      * Initializes with an empty XMP packet      */
specifier|public
name|XMPMetadata
parameter_list|()
block|{
name|xmpData
operator|=
name|XMPMetaFactory
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata(org.apache.tika.metadata.Metadata, java.lang.String)      * But the mimetype is retrieved from the metadata map.      */
specifier|public
name|XMPMetadata
parameter_list|(
name|Metadata
name|meta
parameter_list|)
throws|throws
name|TikaException
block|{
name|this
operator|.
name|xmpData
operator|=
name|TikaToXMP
operator|.
name|convert
argument_list|(
name|meta
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initializes the data by converting the Metadata information to XMP. If a mimetype is      * provided, a specific converter can be used, that converts all available metadata. If there is      * no mimetype provided or no specific converter available a generic conversion is done which      * will convert only those properties that are in known namespaces and are using the correct      * prefixes      *      * @param meta      *            the Metadata information from Tika-core      * @param mimetype      *            mimetype information      * @throws In      *             case an error occured during conversion      */
specifier|public
name|XMPMetadata
parameter_list|(
name|Metadata
name|meta
parameter_list|,
name|String
name|mimetype
parameter_list|)
throws|throws
name|TikaException
block|{
name|this
operator|.
name|xmpData
operator|=
name|TikaToXMP
operator|.
name|convert
argument_list|(
name|meta
argument_list|,
name|mimetype
argument_list|)
expr_stmt|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#process(org.apache.tika.metadata.Metadata,      *      java.lang.String)      *  But the mimetype is retrieved from the metadata map.      */
specifier|public
name|void
name|process
parameter_list|(
name|Metadata
name|meta
parameter_list|)
throws|throws
name|TikaException
block|{
name|this
operator|.
name|xmpData
operator|=
name|TikaToXMP
operator|.
name|convert
argument_list|(
name|meta
argument_list|)
expr_stmt|;
block|}
comment|/**      * Converts the Metadata information to XMP. If a mimetype is provided, a specific converter can      * be used, that converts all available metadata. If there is no mimetype provided or no      * specific converter available a generic conversion is done which will convert only those      * properties that are in known namespaces and are using the correct prefixes      *      * @param meta      *            the Metadata information from Tika-core      * @param mimetype      *            mimetype information      * @throws In      *             case an error occured during conversion      */
specifier|public
name|void
name|process
parameter_list|(
name|Metadata
name|meta
parameter_list|,
name|String
name|mimetype
parameter_list|)
throws|throws
name|TikaException
block|{
name|this
operator|.
name|xmpData
operator|=
name|TikaToXMP
operator|.
name|convert
argument_list|(
name|meta
argument_list|,
name|mimetype
argument_list|)
expr_stmt|;
block|}
comment|/**      * Provides direct access to the XMP data model, in case a client prefers to work directly on it      * instead of using the Metadata API      *      * @return the "internal" XMP data object      */
specifier|public
name|XMPMeta
name|getXMPData
parameter_list|()
block|{
return|return
name|xmpData
return|;
block|}
comment|// === Namespace Registry API === //
comment|/**      * Register a namespace URI with a suggested prefix. It is not an error if the URI is already      * registered, no matter what the prefix is. If the URI is not registered but the suggested      * prefix is in use, a unique prefix is created from the suggested one. The actual registeed      * prefix is always returned. The function result tells if the registered prefix is the      * suggested one.      * Note: No checking is presently done on either the URI or the prefix.      *      * @param namespaceURI      *            The URI for the namespace. Must be a valid XML URI.      * @param suggestedPrefix      *            The suggested prefix to be used if the URI is not yet registered. Must be a valid      *            XML name.      * @return Returns the registered prefix for this URI, is equal to the suggestedPrefix if the      *         namespace hasn't been registered before, otherwise the existing prefix.      * @throws XMPException      *             If the parameters are not accordingly set      */
specifier|public
specifier|static
name|String
name|registerNamespace
parameter_list|(
name|String
name|namespaceURI
parameter_list|,
name|String
name|suggestedPrefix
parameter_list|)
throws|throws
name|XMPException
block|{
return|return
name|registry
operator|.
name|registerNamespace
argument_list|(
name|namespaceURI
argument_list|,
name|suggestedPrefix
argument_list|)
return|;
block|}
comment|/**      * Obtain the prefix for a registered namespace URI.      * It is not an error if the namespace URI is not registered.      *      * @param namespaceURI      *            The URI for the namespace. Must not be null or the empty string.      * @return Returns the prefix registered for this namespace URI or null.      */
specifier|public
specifier|static
name|String
name|getNamespacePrefix
parameter_list|(
name|String
name|namespaceURI
parameter_list|)
block|{
return|return
name|registry
operator|.
name|getNamespacePrefix
argument_list|(
name|namespaceURI
argument_list|)
return|;
block|}
comment|/**      * Obtain the URI for a registered namespace prefix.      * It is not an error if the namespace prefix is not registered.      *      * @param namespacePrefix      *            The prefix for the namespace. Must not be null or the empty string.      * @return Returns the URI registered for this prefix or null.      */
specifier|public
specifier|static
name|String
name|getNamespaceURI
parameter_list|(
name|String
name|namespacePrefix
parameter_list|)
block|{
return|return
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|namespacePrefix
argument_list|)
return|;
block|}
comment|/**      * @return Returns the registered prefix/namespace-pairs as map, where the keys are the      *         namespaces and the values are the prefixes.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getNamespaces
parameter_list|()
block|{
return|return
name|registry
operator|.
name|getNamespaces
argument_list|()
return|;
block|}
comment|/**      * @return Returns the registered namespace/prefix-pairs as map, where the keys are the prefixes      *         and the values are the namespaces.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPrefixes
parameter_list|()
block|{
return|return
name|registry
operator|.
name|getPrefixes
argument_list|()
return|;
block|}
comment|/**      * Deletes a namespace from the registry.      *<p>      * Does nothing if the URI is not registered, or if the namespaceURI parameter is null or the      * empty string.      *<p>      * Note: Not yet implemented.      *      * @param namespaceURI      *            The URI for the namespace.      */
specifier|public
specifier|static
name|void
name|deleteNamespace
parameter_list|(
name|String
name|namespaceURI
parameter_list|)
block|{
name|registry
operator|.
name|deleteNamespace
argument_list|(
name|namespaceURI
argument_list|)
expr_stmt|;
block|}
comment|// === Metadata API === //
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#isMultiValued(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|boolean
name|isMultiValued
parameter_list|(
name|Property
name|property
parameter_list|)
block|{
return|return
name|this
operator|.
name|isMultiValued
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Checks if the named property is an array.      *      * @see org.apache.tika.metadata.Metadata#isMultiValued(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|boolean
name|isMultiValued
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|checkKey
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|String
index|[]
name|keyParts
init|=
name|splitKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|ns
init|=
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|keyParts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|XMPProperty
name|prop
init|=
name|xmpData
operator|.
name|getProperty
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
name|prop
operator|.
name|getOptions
argument_list|()
operator|.
name|isArray
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * For XMP it is not clear what that API should return, therefor not implemented      */
annotation|@
name|Override
specifier|public
name|String
index|[]
name|names
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not implemented"
argument_list|)
throw|;
block|}
comment|/**      * Returns the value of a simple property or the first one of an array. The given name must      * contain a namespace prefix of a registered namespace.      *      * @see org.apache.tika.metadata.Metadata#get(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|checkKey
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|keyParts
init|=
name|splitKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|ns
init|=
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|keyParts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|XMPProperty
name|prop
init|=
name|xmpData
operator|.
name|getProperty
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
operator|&&
name|prop
operator|.
name|getOptions
argument_list|()
operator|.
name|isSimple
argument_list|()
condition|)
block|{
name|value
operator|=
name|prop
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|!=
literal|null
operator|&&
name|prop
operator|.
name|getOptions
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|prop
operator|=
name|xmpData
operator|.
name|getArrayItem
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|prop
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
comment|// in all other cases, null is returned
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
block|}
return|return
name|value
return|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#get(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|String
name|get
parameter_list|(
name|Property
name|property
parameter_list|)
block|{
return|return
name|this
operator|.
name|get
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#get(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|Integer
name|getInt
parameter_list|(
name|Property
name|property
parameter_list|)
block|{
name|Integer
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|result
operator|=
operator|new
name|Integer
argument_list|(
name|XMPUtils
operator|.
name|convertToInteger
argument_list|(
name|this
operator|.
name|get
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
return|return
name|result
return|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#get(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|Date
name|getDate
parameter_list|(
name|Property
name|property
parameter_list|)
block|{
name|Date
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|XMPDateTime
name|xmpDate
init|=
name|XMPUtils
operator|.
name|convertToDate
argument_list|(
name|this
operator|.
name|get
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|xmpDate
operator|!=
literal|null
condition|)
block|{
name|Calendar
name|cal
init|=
name|xmpDate
operator|.
name|getCalendar
argument_list|()
decl_stmt|;
comment|// TODO Timezone is currently lost
comment|// need another solution that preserves the timezone
name|result
operator|=
name|cal
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
return|return
name|result
return|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#getValues(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getValues
parameter_list|(
name|Property
name|property
parameter_list|)
block|{
return|return
name|this
operator|.
name|getValues
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the value of a simple property or all if the property is an array and the elements      * are of simple type. The given name must contain a namespace prefix of a registered namespace.      *      * @see org.apache.tika.metadata.Metadata#getValues(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getValues
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|checkKey
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|String
index|[]
name|value
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|keyParts
init|=
name|splitKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|ns
init|=
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|keyParts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|XMPProperty
name|prop
init|=
name|xmpData
operator|.
name|getProperty
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
operator|&&
name|prop
operator|.
name|getOptions
argument_list|()
operator|.
name|isSimple
argument_list|()
condition|)
block|{
name|value
operator|=
operator|new
name|String
index|[
literal|1
index|]
expr_stmt|;
name|value
index|[
literal|0
index|]
operator|=
name|prop
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|!=
literal|null
operator|&&
name|prop
operator|.
name|getOptions
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|int
name|size
init|=
name|xmpData
operator|.
name|countArrayItems
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|value
operator|=
operator|new
name|String
index|[
name|size
index|]
expr_stmt|;
name|boolean
name|onlySimpleChildren
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
operator|&&
name|onlySimpleChildren
condition|;
name|i
operator|++
control|)
block|{
name|prop
operator|=
name|xmpData
operator|.
name|getArrayItem
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|.
name|getOptions
argument_list|()
operator|.
name|isSimple
argument_list|()
condition|)
block|{
name|value
index|[
name|i
index|]
operator|=
name|prop
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|onlySimpleChildren
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|onlySimpleChildren
condition|)
block|{
name|value
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// in all other cases, null is returned
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
block|}
return|return
name|value
return|;
block|}
comment|/**      * As this API could only possibly work for simple properties in XMP, it just calls the set      * method, which replaces any existing value      *      * @see org.apache.tika.metadata.Metadata#add(java.lang.String, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the given property. If the property already exists, it is overwritten. Only simple      * properties that use a registered prefix are stored in the XMP.      *      * @see org.apache.tika.metadata.Metadata#set(java.lang.String, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|checkKey
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|String
index|[]
name|keyParts
init|=
name|splitKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|ns
init|=
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|keyParts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|xmpData
operator|.
name|setProperty
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
block|}
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#set(java.lang.String, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|Property
name|property
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|this
operator|.
name|set
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#set(java.lang.String, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|Property
name|property
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|// Can reuse the checks from the base class implementation which will call
comment|// the set(String, String) method in the end
name|super
operator|.
name|set
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#set(java.lang.String, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|Property
name|property
parameter_list|,
name|double
name|value
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#set(java.lang.String, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|Property
name|property
parameter_list|,
name|Date
name|date
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|property
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets array properties. If the property already exists, it is overwritten. Only array      * properties that use a registered prefix are stored in the XMP.      *      * @see org.apache.tika.metadata.Metadata#set(org.apache.tika.metadata.Property,      *      java.lang.String[])      */
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|Property
name|property
parameter_list|,
name|String
index|[]
name|values
parameter_list|)
block|{
name|checkKey
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|property
operator|.
name|isMultiValuePermitted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|PropertyTypeException
argument_list|(
literal|"Property is not of an array type"
argument_list|)
throw|;
block|}
name|String
index|[]
name|keyParts
init|=
name|splitKey
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|ns
init|=
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|keyParts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|int
name|arrayType
init|=
name|tikaToXMPArrayType
argument_list|(
name|property
operator|.
name|getPrimaryProperty
argument_list|()
operator|.
name|getPropertyType
argument_list|()
argument_list|)
decl_stmt|;
name|xmpData
operator|.
name|setProperty
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|,
literal|null
argument_list|,
operator|new
name|PropertyOptions
argument_list|(
name|arrayType
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|value
range|:
name|values
control|)
block|{
name|xmpData
operator|.
name|appendArrayItem
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// Ignore
block|}
block|}
block|}
comment|/**      * It will set all simple and array properties that have QName keys in registered namespaces.      *      * @see org.apache.tika.metadata.Metadata#setAll(java.util.Properties)      */
annotation|@
name|Override
specifier|public
name|void
name|setAll
parameter_list|(
name|Properties
name|properties
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Enumeration
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|(
name|Enumeration
argument_list|<
name|String
argument_list|>
operator|)
name|properties
operator|.
name|propertyNames
argument_list|()
decl_stmt|;
while|while
condition|(
name|names
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|names
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Property
name|property
init|=
name|Property
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PropertyTypeException
argument_list|(
literal|"Unknown property: "
operator|+
name|name
argument_list|)
throw|;
block|}
name|String
name|value
init|=
name|properties
operator|.
name|getProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|.
name|isMultiValuePermitted
argument_list|()
condition|)
block|{
name|this
operator|.
name|set
argument_list|(
name|property
argument_list|,
operator|new
name|String
index|[]
block|{
name|value
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|set
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @see org.apache.tika.xmp.XMPMetadata#remove(java.lang.String)      */
specifier|public
name|void
name|remove
parameter_list|(
name|Property
name|property
parameter_list|)
block|{
name|this
operator|.
name|remove
argument_list|(
name|property
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the given property from the XMP data. If it is a complex property the whole subtree      * is removed      *      * @see org.apache.tika.metadata.Metadata#remove(java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|checkKey
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|String
index|[]
name|keyParts
init|=
name|splitKey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|ns
init|=
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|keyParts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
name|xmpData
operator|.
name|deleteProperty
argument_list|(
name|ns
argument_list|,
name|keyParts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the number of top-level namespaces      */
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
try|try
block|{
comment|// Get an iterator for the XMP packet, starting at the top level schema nodes
name|XMPIterator
name|nsIter
init|=
name|xmpData
operator|.
name|iterator
argument_list|(
operator|new
name|IteratorOptions
argument_list|()
operator|.
name|setJustChildren
argument_list|(
literal|true
argument_list|)
operator|.
name|setOmitQualifiers
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// iterate all top level namespaces
while|while
condition|(
name|nsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|nsIter
operator|.
name|next
argument_list|()
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
return|return
name|size
return|;
block|}
comment|/**      * This method is not implemented, yet. It is very tedious to check for semantic equality of XMP      * packets      */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not implemented"
argument_list|)
throw|;
block|}
comment|/**      * Serializes the XMP data in compact form without packet wrapper      *      * @see org.apache.tika.metadata.Metadata#toString()      */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|result
operator|=
name|XMPMetaFactory
operator|.
name|serializeToString
argument_list|(
name|xmpData
argument_list|,
operator|new
name|SerializeOptions
argument_list|()
operator|.
name|setOmitPacketWrapper
argument_list|(
literal|true
argument_list|)
operator|.
name|setUseCompactFormat
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|XMPException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
return|return
name|result
return|;
block|}
comment|// The XMP object is not serializable!
specifier|private
name|void
name|readObject
parameter_list|(
name|ObjectInputStream
name|ois
parameter_list|)
throws|throws
name|ClassNotFoundException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|NotSerializableException
argument_list|()
throw|;
block|}
comment|// The XMP object is not serializable!
specifier|private
name|void
name|writeObject
parameter_list|(
name|ObjectOutputStream
name|ois
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|NotSerializableException
argument_list|()
throw|;
block|}
comment|/**      * Checks if the given key is a valid QName with a known standard namespace prefix      *      * @param key      *            the key to check      * @return true if the key is valid otherwise false      */
specifier|private
name|void
name|checkKey
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|PropertyTypeException
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|key
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|PropertyTypeException
argument_list|(
literal|"Key must not be null"
argument_list|)
throw|;
block|}
name|String
index|[]
name|keyParts
init|=
name|splitKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyParts
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PropertyTypeException
argument_list|(
literal|"Key must be a QName in the form prefix:localName"
argument_list|)
throw|;
block|}
if|if
condition|(
name|registry
operator|.
name|getNamespaceURI
argument_list|(
name|keyParts
index|[
literal|0
index|]
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PropertyTypeException
argument_list|(
literal|"Key does not use a registered Namespace prefix"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Split the given key at the namespace prefix delimiter      *      * @param key      *            the key to split      * @return prefix and local name of the property or null if the key did not contain a delimiter      *         or too much of them      */
specifier|private
name|String
index|[]
name|splitKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|String
index|[]
name|keyParts
init|=
name|key
operator|.
name|split
argument_list|(
name|Metadata
operator|.
name|NAMESPACE_PREFIX_DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyParts
operator|.
name|length
operator|>
literal|0
operator|&&
name|keyParts
operator|.
name|length
operator|<=
literal|2
condition|)
block|{
return|return
name|keyParts
return|;
block|}
return|return
literal|null
return|;
block|}
comment|// checkKeyPrefix
comment|/**      * Convert Tika array types to XMP array types      *      * @param type      * @return      */
specifier|private
name|int
name|tikaToXMPArrayType
parameter_list|(
name|PropertyType
name|type
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BAG
case|:
name|result
operator|=
name|PropertyOptions
operator|.
name|ARRAY
expr_stmt|;
break|break;
case|case
name|SEQ
case|:
name|result
operator|=
name|PropertyOptions
operator|.
name|ARRAY_ORDERED
expr_stmt|;
break|break;
case|case
name|ALT
case|:
name|result
operator|=
name|PropertyOptions
operator|.
name|ARRAY_ALTERNATE
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

