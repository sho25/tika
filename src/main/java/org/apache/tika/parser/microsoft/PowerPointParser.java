begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|microsoft
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hdf
operator|.
name|extractor
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|POIFSFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|util
operator|.
name|LittleEndian
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|util
operator|.
name|StringUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|sax
operator|.
name|XHTMLContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|ContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  * Power point parser  */
end_comment

begin_class
specifier|public
class|class
name|PowerPointParser
extends|extends
name|OfficeParser
block|{
comment|/**      *  Name of a PowerPoint document within a POIFS file system      */
specifier|private
specifier|static
specifier|final
name|String
name|POWERPOINT
init|=
literal|"PowerPoint Document"
decl_stmt|;
comment|/**      * Logger instance.      */
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|PowerPointParser
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|String
name|getContentType
parameter_list|()
block|{
return|return
literal|"application/vnd.ms-powerpoint"
return|;
block|}
specifier|protected
name|void
name|parse
parameter_list|(
name|POIFSFileSystem
name|poifs
parameter_list|,
name|ContentHandler
name|handler
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
name|XHTMLContentHandler
name|xhtml
init|=
operator|new
name|XHTMLContentHandler
argument_list|(
name|handler
argument_list|,
name|metadata
argument_list|)
decl_stmt|;
name|InputStream
name|stream
init|=
name|poifs
operator|.
name|createDocumentInputStream
argument_list|(
name|POWERPOINT
argument_list|)
decl_stmt|;
try|try
block|{
name|xhtml
operator|.
name|startDocument
argument_list|()
expr_stmt|;
name|xhtml
operator|.
name|startElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
name|parse
argument_list|(
name|stream
argument_list|,
name|xhtml
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|endElement
argument_list|(
literal|"p"
argument_list|)
expr_stmt|;
name|xhtml
operator|.
name|endDocument
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Reads the internal PowerPoint document stream.      */
specifier|private
name|void
name|parse
parameter_list|(
name|InputStream
name|dis
parameter_list|,
name|XHTMLContentHandler
name|xhtml
parameter_list|)
block|{
try|try
block|{
specifier|final
name|byte
name|pptdata
index|[]
init|=
operator|new
name|byte
index|[
name|dis
operator|.
name|available
argument_list|()
index|]
decl_stmt|;
name|dis
operator|.
name|read
argument_list|(
name|pptdata
argument_list|,
literal|0
argument_list|,
name|dis
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|long
name|offsetPD
init|=
literal|0
decl_stmt|;
comment|/*              * Traverse Bytearray to get CurrentUserEditAtom Call to extract the              * Text in all PlaceHolders to hold PPTClientTextBox objects for              * mapping into Slide Objects              */
name|Map
argument_list|<
name|Long
argument_list|,
name|TextBox
argument_list|>
name|containerTextBox
init|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|TextBox
argument_list|>
argument_list|()
decl_stmt|;
comment|// Traverse ByteArray to identiy edit paths of ClientTextBoxes
name|long
name|n
init|=
name|pptdata
operator|.
name|length
operator|-
literal|20
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|type
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// final long size = LittleEndian.getUInt(pptdata, (int) i + 4);
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_USEREDIT
operator|==
name|type
condition|)
block|{
comment|/*                      * Checking the Record Header (UserEditAtom)                      */
comment|// final long lastSlideID = LittleEndian.getInt(pptdata,
comment|// (int) i + 8);
comment|// final long version = LittleEndian.getUInt(pptdata, (int)
comment|// i + 12);
name|offset
operator|=
operator|(
name|int
operator|)
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|16
argument_list|)
expr_stmt|;
name|offsetPD
operator|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|20
argument_list|)
expr_stmt|;
comment|/*                      * Call to extract ClientTextBox text in each UserEditAtom                      */
name|extractTextBoxes
argument_list|(
name|containerTextBox
argument_list|,
name|offset
argument_list|,
name|pptdata
argument_list|,
name|offsetPD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
operator|==
name|type
condition|)
block|{
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("PPT_DRAWINGGROUP_ATOM ignored: " + type);
comment|// }
block|}
elseif|else
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTBYTE
operator|==
name|type
condition|)
block|{
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("PPT_TEXTBYTE_ATOM ignored: " + type);
comment|// }
block|}
elseif|else
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTCHAR
operator|==
name|type
condition|)
block|{
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("PPT_TEXTCHAR_ATOM ignored: " + type);
comment|// }
block|}
else|else
block|{
comment|// no action
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("type not handled: " + type);
comment|// }
block|}
block|}
name|List
argument_list|<
name|Slide
argument_list|>
name|slides
init|=
name|extractSlides
argument_list|(
name|offset
argument_list|,
name|pptdata
argument_list|,
name|offsetPD
argument_list|)
decl_stmt|;
if|if
condition|(
name|slides
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No slides extracted!"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Slide
name|slide
init|=
operator|(
name|Slide
operator|)
name|slides
operator|.
name|get
argument_list|(
name|slides
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|TextBox
name|textBox
range|:
name|containerTextBox
operator|.
name|values
argument_list|()
control|)
block|{
name|slide
operator|.
name|addContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*                  * Merging TextBox data with Slide Data Printing the text from                  * Slides vector object.                  */
for|for
control|(
name|Slide
name|s
range|:
name|slides
control|)
block|{
name|List
name|scontent
init|=
name|s
operator|.
name|getContent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|scontent
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|String
name|contentText
init|=
name|scontent
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|xhtml
operator|.
name|characters
argument_list|(
name|contentText
argument_list|)
expr_stmt|;
comment|// to avoid concatinated words we add a blank additional
if|if
condition|(
name|contentText
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
operator|!
operator|(
name|contentText
operator|.
name|endsWith
argument_list|(
literal|"\r"
argument_list|)
operator|||
name|contentText
operator|.
name|endsWith
argument_list|(
literal|"\n"
argument_list|)
operator|)
condition|)
block|{
name|xhtml
operator|.
name|characters
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// because of not killing complete crawling all Throwables are
comment|// catched.
name|LOG
operator|.
name|error
argument_list|(
literal|"processPOIFSReaderEvent"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Extracts the client text boxes of a slide.      *       * @param containerTextBox      * @param offset      * @param pptdata      * @param offsetPD      * @see TextBox      */
specifier|private
name|void
name|extractTextBoxes
parameter_list|(
name|Map
argument_list|<
name|Long
argument_list|,
name|TextBox
argument_list|>
name|containerTextBox
parameter_list|,
name|int
name|offset
parameter_list|,
name|byte
index|[]
name|pptdata
parameter_list|,
name|long
name|offsetPD
parameter_list|)
block|{
comment|// To hold temporary data
name|FilteredStringWriter
name|outStream
init|=
operator|new
name|FilteredStringWriter
argument_list|()
decl_stmt|;
name|TextBox
name|textBox
decl_stmt|;
comment|// Traversing the bytearray up to Presist directory position
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|offsetPD
operator|-
literal|20
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
comment|// Record info
comment|// final long rinfo = LittleEndian.getUShort(pptdata, (int) i);
comment|// Record Type
specifier|final
name|long
name|recordType
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// Record Size
specifier|final
name|long
name|recordSize
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
name|i
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|recordType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
condition|)
block|{
comment|/*                      * Record type is of Drawing Group                      */
comment|// Total number of objects
comment|// final long objectCount = LittleEndian.getUInt(pptdata,
comment|// (int) i +
comment|// 8);
comment|// currentID = Group ID+number of objects
name|long
name|currentID
init|=
name|LittleEndian
operator|.
name|getInt
argument_list|(
name|pptdata
argument_list|,
name|i
operator|+
literal|12
argument_list|)
decl_stmt|;
name|currentID
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|currentID
operator|/
literal|1024
argument_list|)
operator|)
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|currentID
operator|==
name|PPTConstants
operator|.
name|PPT_MASTERSLIDE
condition|)
block|{
comment|// Ignore Master Slide objects
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Ignore master slide."
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// Check for the ClientTextBox GroupID existence
if|if
condition|(
name|containerTextBox
operator|.
name|containsKey
argument_list|(
operator|new
name|Long
argument_list|(
name|currentID
argument_list|)
argument_list|)
condition|)
block|{
comment|// If exists get Client Textbox Group
name|textBox
operator|=
operator|(
name|TextBox
operator|)
name|containerTextBox
operator|.
name|get
argument_list|(
operator|new
name|Long
argument_list|(
name|currentID
argument_list|)
argument_list|)
expr_stmt|;
name|textBox
operator|.
name|setContent
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|textBox
operator|=
operator|new
name|TextBox
argument_list|(
name|currentID
argument_list|)
expr_stmt|;
name|containerTextBox
operator|.
name|put
argument_list|(
operator|new
name|Long
argument_list|(
name|currentID
argument_list|)
argument_list|,
name|textBox
argument_list|)
expr_stmt|;
block|}
comment|/*                      * Iterating the bytearray for TextCharAtoms and                      * TextBytesAtom                      */
if|if
condition|(
operator|(
name|offsetPD
operator|-
literal|20
operator|)
operator|!=
name|recordSize
condition|)
block|{
comment|// TODO something wrong? Probably an OLE-Object, which
comment|// we ignore.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"offsetPD - 20="
operator|+
operator|(
name|offsetPD
operator|-
literal|20
operator|)
operator|+
literal|" recordsize="
operator|+
name|recordSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|startPos
init|=
name|i
operator|+
literal|8
init|;
name|startPos
operator|<
name|offsetPD
operator|-
literal|20
operator|&&
name|startPos
operator|<
name|recordSize
condition|;
name|startPos
operator|++
control|)
block|{
comment|//&&
comment|// startPos
comment|//<
comment|// recordSize??
try|try
block|{
comment|// Record info
comment|// final long nrinfo =
comment|// LittleEndian.getUShort(pptdata, (int) j);
comment|// Record Type
specifier|final
name|long
name|ntype
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
name|startPos
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// Record size
comment|// Note that the size doesn't include the 8 byte
comment|// atom header
specifier|final
name|long
name|nsize
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
name|startPos
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|ntype
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
condition|)
block|{
comment|/*                                      * Break the loop if next GroupID found                                      */
name|i
operator|=
name|startPos
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ntype
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTBYTE
condition|)
block|{
comment|// TextByteAtom record
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
name|long
name|ii
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ii
operator|=
name|startPos
operator|+
literal|6
init|;
name|ii
operator|<=
name|startPos
operator|+
literal|6
operator|+
name|nsize
condition|;
name|ii
operator|++
control|)
block|{
comment|// For loop to changed to a function
comment|// if ((ii + 2)>= pptdata.length)
comment|// break; // FIXME
name|outStream
operator|.
name|write
argument_list|(
call|(
name|char
call|)
argument_list|(
name|pptdata
index|[
operator|(
name|int
operator|)
name|ii
operator|+
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Setting the identified text for Current
comment|// groupID
name|textBox
operator|.
name|setContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
operator|+
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ntype
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTCHAR
condition|)
block|{
comment|// TextCharAtom record
specifier|final
name|String
name|strTempContent
init|=
operator|new
name|String
argument_list|(
name|pptdata
argument_list|,
name|startPos
operator|+
literal|6
argument_list|,
call|(
name|int
call|)
argument_list|(
name|nsize
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|bytes
index|[]
init|=
name|strTempContent
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
literal|true
condition|)
block|{
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|bytes
operator|.
name|length
operator|-
literal|1
condition|;
name|ii
operator|+=
literal|2
control|)
block|{
comment|// For loop to changed to a function
name|outStream
operator|.
name|write
argument_list|(
call|(
name|char
call|)
argument_list|(
name|pptdata
index|[
name|ii
operator|+
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|textBox
operator|.
name|setContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
operator|+
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this version is used within POI
name|String
name|text
init|=
name|StringUtil
operator|.
name|getFromCompressedUnicode
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
decl_stmt|;
name|textBox
operator|.
name|setContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
operator|+
name|text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// ignored
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("Ignored atom type: " + type);
comment|// }
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"extractTextBoxes"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Record type is ignored
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("Ignored record type: " + type);
comment|// }
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ee
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"extractClientTextBoxes"
argument_list|,
name|ee
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns the Powerpoint<code>Slide</code> s of document as vector.      *       * @param offset      * @param pptdata      * @param offsetPD      * @return Vector of the powerpoint slides. Contains      *<code>{@link Slide Slide}</code>      * @see Slide      */
specifier|private
name|List
argument_list|<
name|Slide
argument_list|>
name|extractSlides
parameter_list|(
name|long
name|offset
parameter_list|,
name|byte
index|[]
name|pptdata
parameter_list|,
name|long
name|offsetPD
parameter_list|)
block|{
name|int
name|sNum
init|=
literal|0
decl_stmt|;
comment|// List of all slides found
name|List
argument_list|<
name|Slide
argument_list|>
name|slides
init|=
operator|new
name|ArrayList
argument_list|<
name|Slide
argument_list|>
argument_list|()
decl_stmt|;
comment|// current slide data
name|Slide
name|currentSlide
init|=
literal|null
decl_stmt|;
comment|// To store data found in TextCharAtoms and TextBytesAtoms
name|FilteredStringWriter
name|outStream
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
name|offset
init|;
name|i
operator|<
name|pptdata
operator|.
name|length
operator|-
literal|20
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|atomType
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|long
name|atomSize
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTBYTE
condition|)
block|{
comment|/*                  * TextByteAtom record                  */
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
for|for
control|(
name|long
name|ii
init|=
name|i
operator|+
literal|6
init|;
operator|(
name|ii
operator|<=
name|i
operator|+
literal|6
operator|+
name|atomSize
operator|)
operator|&&
operator|(
name|ii
operator|+
literal|2
operator|<
name|pptdata
operator|.
name|length
operator|)
condition|;
name|ii
operator|++
control|)
block|{
try|try
block|{
comment|// if(ii+2>= pptdata.length) break; //FIXME
name|byte
name|value
init|=
name|pptdata
index|[
operator|(
name|int
operator|)
name|ii
operator|+
literal|2
index|]
decl_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"size="
operator|+
name|pptdata
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"extractSlides"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Setting the identified text for Current Slide
if|if
condition|(
name|currentSlide
operator|!=
literal|null
condition|)
block|{
name|currentSlide
operator|.
name|addContent
argument_list|(
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTCHAR
condition|)
block|{
comment|/*                  * TextCharAtom record                  */
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
specifier|final
name|String
name|strTempContent
init|=
operator|new
name|String
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|6
argument_list|,
call|(
name|int
call|)
argument_list|(
name|atomSize
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|bytes
index|[]
init|=
name|strTempContent
operator|.
name|getBytes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|bytes
operator|.
name|length
operator|-
literal|1
condition|;
name|ii
operator|+=
literal|2
control|)
block|{
name|outStream
operator|.
name|write
argument_list|(
name|Utils
operator|.
name|getUnicodeCharacter
argument_list|(
name|bytes
argument_list|,
name|ii
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Setting the identified text for Current Slide
if|if
condition|(
name|currentSlide
operator|!=
literal|null
condition|)
block|{
name|currentSlide
operator|.
name|addContent
argument_list|(
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_SLIDEPERSISTANT
condition|)
block|{
comment|/*                  * SlidePresistAtom Record                  */
if|if
condition|(
name|sNum
operator|!=
literal|0
condition|)
block|{
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
specifier|final
name|long
name|slideID
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|20
argument_list|)
decl_stmt|;
name|currentSlide
operator|=
operator|new
name|Slide
argument_list|(
name|slideID
argument_list|)
expr_stmt|;
comment|// currentSlide.addContent(outStream.toString());
name|slides
operator|.
name|add
argument_list|(
name|currentSlide
argument_list|)
expr_stmt|;
block|}
name|sNum
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
condition|)
block|{
comment|/*                  * Diagram records are ignored                  */
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Drawing Groups are ignored."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|// ignored
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("Unhandled atomType: " + atomType);
comment|// }
block|}
block|}
return|return
name|slides
return|;
block|}
block|}
end_class

end_unit

