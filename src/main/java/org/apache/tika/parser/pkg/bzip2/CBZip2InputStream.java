begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_comment
comment|/*  * This package is based on the work done by Keiron Liddle, Aftex Software  *<keiron@aftexsw.com> to whom the Ant project is very grateful for his  * great code.  *  * This package has since been copied from Apache Ant to Apache Tika.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|pkg
operator|.
name|bzip2
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_comment
comment|/**  * An input stream that decompresses from the BZip2 format (without the file  * header chars) to be read as any other stream.  *  *<p>The decompression requires large amounts of memory. Thus you  * should call the {@link #close() close()} method as soon as  * possible, to force<tt>CBZip2InputStream</tt> to release the  * allocated memory.  See {@link CBZip2OutputStream  * CBZip2OutputStream} for information about memory usage.</p>  *  *<p><tt>CBZip2InputStream</tt> reads bytes from the compressed  * source stream via the single byte {@link java.io.InputStream#read()  * read()} method exclusively. Thus you should consider to use a  * buffered source stream.</p>  *   *<p>Instances of this class are not threadsafe.</p>  */
end_comment

begin_class
specifier|public
class|class
name|CBZip2InputStream
extends|extends
name|InputStream
implements|implements
name|BZip2Constants
block|{
specifier|private
specifier|static
name|void
name|reportCRCError
parameter_list|()
throws|throws
name|IOException
block|{
comment|// The clean way would be to throw an exception.
comment|//throw new IOException("crc error");
comment|// Just print a message, like the previous versions of this class did
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"BZip2 CRC error"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|makeMaps
parameter_list|()
block|{
specifier|final
name|boolean
index|[]
name|inUse
init|=
name|this
operator|.
name|data
operator|.
name|inUse
decl_stmt|;
specifier|final
name|byte
index|[]
name|seqToUnseq
init|=
name|this
operator|.
name|data
operator|.
name|seqToUnseq
decl_stmt|;
name|int
name|nInUseShadow
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inUse
index|[
name|i
index|]
condition|)
name|seqToUnseq
index|[
name|nInUseShadow
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
block|}
name|this
operator|.
name|nInUse
operator|=
name|nInUseShadow
expr_stmt|;
block|}
comment|/**      * Index of the last char in the block, so the block size == last + 1.      */
specifier|private
name|int
name|last
decl_stmt|;
comment|/**      * Index in zptr[] of original string after sorting.      */
specifier|private
name|int
name|origPtr
decl_stmt|;
comment|/**      * always: in the range 0 .. 9.      * The current block size is 100000 * this number.      */
specifier|private
name|int
name|blockSize100k
decl_stmt|;
specifier|private
name|boolean
name|blockRandomised
decl_stmt|;
specifier|private
name|int
name|bsBuff
decl_stmt|;
specifier|private
name|int
name|bsLive
decl_stmt|;
specifier|private
specifier|final
name|CRC
name|crc
init|=
operator|new
name|CRC
argument_list|()
decl_stmt|;
specifier|private
name|int
name|nInUse
decl_stmt|;
specifier|private
name|InputStream
name|in
decl_stmt|;
specifier|private
name|int
name|currentChar
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|EOF
init|=
literal|0
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|START_BLOCK_STATE
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|RAND_PART_A_STATE
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|RAND_PART_B_STATE
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|RAND_PART_C_STATE
init|=
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NO_RAND_PART_A_STATE
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NO_RAND_PART_B_STATE
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NO_RAND_PART_C_STATE
init|=
literal|7
decl_stmt|;
specifier|private
name|int
name|currentState
init|=
name|START_BLOCK_STATE
decl_stmt|;
specifier|private
name|int
name|storedBlockCRC
decl_stmt|,
name|storedCombinedCRC
decl_stmt|;
specifier|private
name|int
name|computedBlockCRC
decl_stmt|,
name|computedCombinedCRC
decl_stmt|;
comment|// Variables used by setup* methods exclusively
specifier|private
name|int
name|su_count
decl_stmt|;
specifier|private
name|int
name|su_ch2
decl_stmt|;
specifier|private
name|int
name|su_chPrev
decl_stmt|;
specifier|private
name|int
name|su_i2
decl_stmt|;
specifier|private
name|int
name|su_j2
decl_stmt|;
specifier|private
name|int
name|su_rNToGo
decl_stmt|;
specifier|private
name|int
name|su_rTPos
decl_stmt|;
specifier|private
name|int
name|su_tPos
decl_stmt|;
specifier|private
name|char
name|su_z
decl_stmt|;
comment|/**      * All memory intensive stuff.      * This field is initialized by initBlock().      */
specifier|private
name|CBZip2InputStream
operator|.
name|Data
name|data
decl_stmt|;
comment|/**      * Constructs a new CBZip2InputStream which decompresses bytes read from      * the specified stream.      *      *<p>Although BZip2 headers are marked with the magic      *<tt>"Bz"</tt> this constructor expects the next byte in the      * stream to be the first one after the magic.  Thus callers have      * to skip the first two bytes. Otherwise this constructor will      * throw an exception.</p>      *      * @throws IOException      *  if the stream content is malformed or an I/O error occurs.      * @throws NullPointerException      *  if<tt>in == null</tt>      */
specifier|public
name|CBZip2InputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|in
operator|!=
literal|null
condition|)
block|{
return|return
name|read0
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream closed"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|dest
parameter_list|,
specifier|final
name|int
name|offs
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offs
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"offs("
operator|+
name|offs
operator|+
literal|")< 0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"len("
operator|+
name|len
operator|+
literal|")< 0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|offs
operator|+
name|len
operator|>
name|dest
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"offs("
operator|+
name|offs
operator|+
literal|") + len("
operator|+
name|len
operator|+
literal|")> dest.length("
operator|+
name|dest
operator|.
name|length
operator|+
literal|")."
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream closed"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|hi
init|=
name|offs
operator|+
name|len
decl_stmt|;
name|int
name|destOffs
init|=
name|offs
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|destOffs
operator|<
name|hi
operator|)
operator|&&
operator|(
operator|(
name|b
operator|=
name|read0
argument_list|()
operator|)
operator|>=
literal|0
operator|)
condition|;
control|)
block|{
name|dest
index|[
name|destOffs
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
return|return
operator|(
name|destOffs
operator|==
name|offs
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|destOffs
operator|-
name|offs
operator|)
return|;
block|}
specifier|private
name|int
name|read0
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|retChar
init|=
name|this
operator|.
name|currentChar
decl_stmt|;
switch|switch
condition|(
name|this
operator|.
name|currentState
condition|)
block|{
case|case
name|EOF
case|:
return|return
operator|-
literal|1
return|;
case|case
name|START_BLOCK_STATE
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
case|case
name|RAND_PART_A_STATE
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
case|case
name|RAND_PART_B_STATE
case|:
name|setupRandPartB
argument_list|()
expr_stmt|;
break|break;
case|case
name|RAND_PART_C_STATE
case|:
name|setupRandPartC
argument_list|()
expr_stmt|;
break|break;
case|case
name|NO_RAND_PART_A_STATE
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
case|case
name|NO_RAND_PART_B_STATE
case|:
name|setupNoRandPartB
argument_list|()
expr_stmt|;
break|break;
case|case
name|NO_RAND_PART_C_STATE
case|:
name|setupNoRandPartC
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
return|return
name|retChar
return|;
block|}
specifier|private
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
literal|null
operator|==
name|in
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No InputStream"
argument_list|)
throw|;
block|}
if|if
condition|(
name|in
operator|.
name|available
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Empty InputStream"
argument_list|)
throw|;
block|}
name|int
name|magic2
init|=
name|this
operator|.
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|magic2
operator|!=
literal|'h'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream is not BZip2 formatted: expected 'h'"
operator|+
literal|" as first byte but got '"
operator|+
operator|(
name|char
operator|)
name|magic2
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|int
name|blockSize
init|=
name|this
operator|.
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|blockSize
operator|<
literal|'1'
operator|)
operator|||
operator|(
name|blockSize
operator|>
literal|'9'
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream is not BZip2 formatted: illegal "
operator|+
literal|"blocksize "
operator|+
operator|(
name|char
operator|)
name|blockSize
argument_list|)
throw|;
block|}
name|this
operator|.
name|blockSize100k
operator|=
name|blockSize
operator|-
literal|'0'
expr_stmt|;
name|initBlock
argument_list|()
expr_stmt|;
name|setupBlock
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|initBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|char
name|magic0
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic1
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic2
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic3
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic4
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic5
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|magic0
operator|==
literal|0x17
operator|&&
name|magic1
operator|==
literal|0x72
operator|&&
name|magic2
operator|==
literal|0x45
operator|&&
name|magic3
operator|==
literal|0x38
operator|&&
name|magic4
operator|==
literal|0x50
operator|&&
name|magic5
operator|==
literal|0x90
condition|)
block|{
name|complete
argument_list|()
expr_stmt|;
comment|// end of file
block|}
elseif|else
if|if
condition|(
name|magic0
operator|!=
literal|0x31
operator|||
comment|// '1'
name|magic1
operator|!=
literal|0x41
operator|||
comment|// ')'
name|magic2
operator|!=
literal|0x59
operator|||
comment|// 'Y'
name|magic3
operator|!=
literal|0x26
operator|||
comment|// '&'
name|magic4
operator|!=
literal|0x53
operator|||
comment|// 'S'
name|magic5
operator|!=
literal|0x59
comment|// 'Y'
condition|)
block|{
name|this
operator|.
name|currentState
operator|=
name|EOF
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"bad block header"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|storedBlockCRC
operator|=
name|bsGetInt
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockRandomised
operator|=
name|bsR
argument_list|(
literal|1
argument_list|)
operator|==
literal|1
expr_stmt|;
comment|/**              * Allocate data here instead in constructor, so we do not              * allocate it if the input file is empty.              */
if|if
condition|(
name|this
operator|.
name|data
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|data
operator|=
operator|new
name|Data
argument_list|(
name|this
operator|.
name|blockSize100k
argument_list|)
expr_stmt|;
block|}
comment|// currBlockNo++;
name|getAndMoveToFrontDecode
argument_list|()
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|initialiseCRC
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|START_BLOCK_STATE
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|endBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|computedBlockCRC
operator|=
name|this
operator|.
name|crc
operator|.
name|getFinalCRC
argument_list|()
expr_stmt|;
comment|// A bad CRC is considered a fatal error.
if|if
condition|(
name|this
operator|.
name|storedBlockCRC
operator|!=
name|this
operator|.
name|computedBlockCRC
condition|)
block|{
comment|// make next blocks readable without error
comment|// (repair feature, not yet documented, not tested)
name|this
operator|.
name|computedCombinedCRC
operator|=
operator|(
name|this
operator|.
name|storedCombinedCRC
operator|<<
literal|1
operator|)
operator||
operator|(
name|this
operator|.
name|storedCombinedCRC
operator|>>>
literal|31
operator|)
expr_stmt|;
name|this
operator|.
name|computedCombinedCRC
operator|^=
name|this
operator|.
name|storedBlockCRC
expr_stmt|;
name|reportCRCError
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|computedCombinedCRC
operator|=
operator|(
name|this
operator|.
name|computedCombinedCRC
operator|<<
literal|1
operator|)
operator||
operator|(
name|this
operator|.
name|computedCombinedCRC
operator|>>>
literal|31
operator|)
expr_stmt|;
name|this
operator|.
name|computedCombinedCRC
operator|^=
name|this
operator|.
name|computedBlockCRC
expr_stmt|;
block|}
specifier|private
name|void
name|complete
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|storedCombinedCRC
operator|=
name|bsGetInt
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|EOF
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|storedCombinedCRC
operator|!=
name|this
operator|.
name|computedCombinedCRC
condition|)
block|{
name|reportCRCError
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
if|if
condition|(
name|inShadow
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|inShadow
operator|!=
name|System
operator|.
name|in
condition|)
block|{
name|inShadow
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|in
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|int
name|bsR
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
if|if
condition|(
name|bsLiveShadow
operator|<
name|n
condition|)
block|{
specifier|final
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
do|do
block|{
name|int
name|thech
init|=
name|inShadow
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|thech
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|bsLiveShadow
operator|<
name|n
condition|)
do|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
block|}
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
operator|-
name|n
expr_stmt|;
return|return
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
name|n
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|n
operator|)
operator|-
literal|1
operator|)
return|;
block|}
specifier|private
name|boolean
name|bsGetBit
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
if|if
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
name|int
name|thech
init|=
name|this
operator|.
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|thech
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
block|}
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
return|;
block|}
specifier|private
name|char
name|bsGetUByte
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|char
operator|)
name|bsR
argument_list|(
literal|8
argument_list|)
return|;
block|}
specifier|private
name|int
name|bsGetInt
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
operator|(
operator|(
operator|(
operator|(
name|bsR
argument_list|(
literal|8
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|bsR
argument_list|(
literal|8
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
name|bsR
argument_list|(
literal|8
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
name|bsR
argument_list|(
literal|8
argument_list|)
return|;
block|}
comment|/**      * Called by createHuffmanDecodingTables() exclusively.      */
specifier|private
specifier|static
name|void
name|hbCreateDecodeTables
parameter_list|(
specifier|final
name|int
index|[]
name|limit
parameter_list|,
specifier|final
name|int
index|[]
name|base
parameter_list|,
specifier|final
name|int
index|[]
name|perm
parameter_list|,
specifier|final
name|char
index|[]
name|length
parameter_list|,
specifier|final
name|int
name|minLen
parameter_list|,
specifier|final
name|int
name|maxLen
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|minLen
init|,
name|pp
init|=
literal|0
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|alphaSize
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|length
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|perm
index|[
name|pp
operator|++
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
name|MAX_CODE_LEN
init|;
operator|--
name|i
operator|>
literal|0
condition|;
control|)
block|{
name|base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|limit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|base
index|[
name|length
index|[
name|i
index|]
operator|+
literal|1
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|,
name|b
init|=
name|base
index|[
literal|0
index|]
init|;
name|i
operator|<
name|MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|+=
name|base
index|[
name|i
index|]
expr_stmt|;
name|base
index|[
name|i
index|]
operator|=
name|b
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|minLen
init|,
name|vec
init|=
literal|0
init|,
name|b
init|=
name|base
index|[
name|i
index|]
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|nb
init|=
name|base
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|vec
operator|+=
name|nb
operator|-
name|b
expr_stmt|;
name|b
operator|=
name|nb
expr_stmt|;
name|limit
index|[
name|i
index|]
operator|=
name|vec
operator|-
literal|1
expr_stmt|;
name|vec
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|minLen
operator|+
literal|1
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
name|base
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|limit
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
name|base
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|recvDecodingTables
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|boolean
index|[]
name|inUse
init|=
name|dataShadow
operator|.
name|inUse
decl_stmt|;
specifier|final
name|byte
index|[]
name|pos
init|=
name|dataShadow
operator|.
name|recvDecodingTables_pos
decl_stmt|;
specifier|final
name|byte
index|[]
name|selector
init|=
name|dataShadow
operator|.
name|selector
decl_stmt|;
specifier|final
name|byte
index|[]
name|selectorMtf
init|=
name|dataShadow
operator|.
name|selectorMtf
decl_stmt|;
name|int
name|inUse16
init|=
literal|0
decl_stmt|;
comment|/* Receive the mapping table */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|inUse16
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|256
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|inUse
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inUse16
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|i16
init|=
name|i
operator|<<
literal|4
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|inUse
index|[
name|i16
operator|+
name|j
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
name|makeMaps
argument_list|()
expr_stmt|;
specifier|final
name|int
name|alphaSize
init|=
name|this
operator|.
name|nInUse
operator|+
literal|2
decl_stmt|;
comment|/* Now the selectors */
specifier|final
name|int
name|nGroups
init|=
name|bsR
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nSelectors
init|=
name|bsR
argument_list|(
literal|15
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
name|selectorMtf
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|j
expr_stmt|;
block|}
comment|/* Undo the MTF values for the selectors. */
for|for
control|(
name|int
name|v
init|=
name|nGroups
init|;
operator|--
name|v
operator|>=
literal|0
condition|;
control|)
block|{
name|pos
index|[
name|v
index|]
operator|=
operator|(
name|byte
operator|)
name|v
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|int
name|v
init|=
name|selectorMtf
index|[
name|i
index|]
operator|&
literal|0xff
decl_stmt|;
specifier|final
name|byte
name|tmp
init|=
name|pos
index|[
name|v
index|]
decl_stmt|;
while|while
condition|(
name|v
operator|>
literal|0
condition|)
block|{
comment|// nearly all times v is zero, 4 in most other cases
name|pos
index|[
name|v
index|]
operator|=
name|pos
index|[
name|v
operator|-
literal|1
index|]
expr_stmt|;
name|v
operator|--
expr_stmt|;
block|}
name|pos
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|selector
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
specifier|final
name|char
index|[]
index|[]
name|len
init|=
name|dataShadow
operator|.
name|temp_charArray2d
decl_stmt|;
comment|/* Now the coding tables */
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|int
name|curr
init|=
name|bsR
argument_list|(
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|char
index|[]
name|len_t
init|=
name|len
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|curr
operator|+=
name|bsGetBit
argument_list|()
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
name|len_t
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|curr
expr_stmt|;
block|}
block|}
comment|// finally create the Huffman tables
name|createHuffmanDecodingTables
argument_list|(
name|alphaSize
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
block|}
comment|/**      * Called by recvDecodingTables() exclusively.      */
specifier|private
name|void
name|createHuffmanDecodingTables
parameter_list|(
specifier|final
name|int
name|alphaSize
parameter_list|,
specifier|final
name|int
name|nGroups
parameter_list|)
block|{
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|char
index|[]
index|[]
name|len
init|=
name|dataShadow
operator|.
name|temp_charArray2d
decl_stmt|;
specifier|final
name|int
index|[]
name|minLens
init|=
name|dataShadow
operator|.
name|minLens
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|limit
init|=
name|dataShadow
operator|.
name|limit
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|base
init|=
name|dataShadow
operator|.
name|base
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|perm
init|=
name|dataShadow
operator|.
name|perm
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|int
name|minLen
init|=
literal|32
decl_stmt|;
name|int
name|maxLen
init|=
literal|0
decl_stmt|;
specifier|final
name|char
index|[]
name|len_t
init|=
name|len
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|alphaSize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
specifier|final
name|char
name|lent
init|=
name|len_t
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|lent
operator|>
name|maxLen
condition|)
block|{
name|maxLen
operator|=
name|lent
expr_stmt|;
block|}
if|if
condition|(
name|lent
operator|<
name|minLen
condition|)
block|{
name|minLen
operator|=
name|lent
expr_stmt|;
block|}
block|}
name|hbCreateDecodeTables
argument_list|(
name|limit
index|[
name|t
index|]
argument_list|,
name|base
index|[
name|t
index|]
argument_list|,
name|perm
index|[
name|t
index|]
argument_list|,
name|len
index|[
name|t
index|]
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
name|minLens
index|[
name|t
index|]
operator|=
name|minLen
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|getAndMoveToFrontDecode
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|origPtr
operator|=
name|bsR
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|recvDecodingTables
argument_list|()
expr_stmt|;
specifier|final
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|byte
index|[]
name|ll8
init|=
name|dataShadow
operator|.
name|ll8
decl_stmt|;
specifier|final
name|int
index|[]
name|unzftab
init|=
name|dataShadow
operator|.
name|unzftab
decl_stmt|;
specifier|final
name|byte
index|[]
name|selector
init|=
name|dataShadow
operator|.
name|selector
decl_stmt|;
specifier|final
name|byte
index|[]
name|seqToUnseq
init|=
name|dataShadow
operator|.
name|seqToUnseq
decl_stmt|;
specifier|final
name|char
index|[]
name|yy
init|=
name|dataShadow
operator|.
name|getAndMoveToFrontDecode_yy
decl_stmt|;
specifier|final
name|int
index|[]
name|minLens
init|=
name|dataShadow
operator|.
name|minLens
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|limit
init|=
name|dataShadow
operator|.
name|limit
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|base
init|=
name|dataShadow
operator|.
name|base
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|perm
init|=
name|dataShadow
operator|.
name|perm
decl_stmt|;
specifier|final
name|int
name|limitLast
init|=
name|this
operator|.
name|blockSize100k
operator|*
literal|100000
decl_stmt|;
comment|/*           Setting up the unzftab entries here is not strictly           necessary, but it does save having to do it later           in a separate pass, and so saves a block's worth of           cache misses.         */
for|for
control|(
name|int
name|i
init|=
literal|256
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|yy
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
name|unzftab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|groupNo
init|=
literal|0
decl_stmt|;
name|int
name|groupPos
init|=
name|G_SIZE
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|eob
init|=
name|this
operator|.
name|nInUse
operator|+
literal|1
decl_stmt|;
name|int
name|nextSym
init|=
name|getAndMoveToFrontDecode0
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|lastShadow
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|zt
init|=
name|selector
index|[
name|groupNo
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
index|[]
name|base_zt
init|=
name|base
index|[
name|zt
index|]
decl_stmt|;
name|int
index|[]
name|limit_zt
init|=
name|limit
index|[
name|zt
index|]
decl_stmt|;
name|int
index|[]
name|perm_zt
init|=
name|perm
index|[
name|zt
index|]
decl_stmt|;
name|int
name|minLens_zt
init|=
name|minLens
index|[
name|zt
index|]
decl_stmt|;
while|while
condition|(
name|nextSym
operator|!=
name|eob
condition|)
block|{
if|if
condition|(
operator|(
name|nextSym
operator|==
name|RUNA
operator|)
operator|||
operator|(
name|nextSym
operator|==
name|RUNB
operator|)
condition|)
block|{
name|int
name|s
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|1
init|;
literal|true
condition|;
name|n
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|nextSym
operator|==
name|RUNA
condition|)
block|{
name|s
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextSym
operator|==
name|RUNB
condition|)
block|{
name|s
operator|+=
name|n
operator|<<
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|groupPos
operator|==
literal|0
condition|)
block|{
name|groupPos
operator|=
name|G_SIZE
operator|-
literal|1
expr_stmt|;
name|zt
operator|=
name|selector
index|[
operator|++
name|groupNo
index|]
operator|&
literal|0xff
expr_stmt|;
name|base_zt
operator|=
name|base
index|[
name|zt
index|]
expr_stmt|;
name|limit_zt
operator|=
name|limit
index|[
name|zt
index|]
expr_stmt|;
name|perm_zt
operator|=
name|perm
index|[
name|zt
index|]
expr_stmt|;
name|minLens_zt
operator|=
name|minLens
index|[
name|zt
index|]
expr_stmt|;
block|}
else|else
block|{
name|groupPos
operator|--
expr_stmt|;
block|}
name|int
name|zn
init|=
name|minLens_zt
decl_stmt|;
comment|// Inlined:
comment|// int zvec = bsR(zn);
while|while
condition|(
name|bsLiveShadow
operator|<
name|zn
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|inShadow
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|int
name|zvec
init|=
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
name|zn
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|zn
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|bsLiveShadow
operator|-=
name|zn
expr_stmt|;
while|while
condition|(
name|zvec
operator|>
name|limit_zt
index|[
name|zn
index|]
condition|)
block|{
name|zn
operator|++
expr_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|inShadow
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|bsLiveShadow
operator|--
expr_stmt|;
name|zvec
operator|=
operator|(
name|zvec
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|bsBuffShadow
operator|>>
name|bsLiveShadow
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|nextSym
operator|=
name|perm_zt
index|[
name|zvec
operator|-
name|base_zt
index|[
name|zn
index|]
index|]
expr_stmt|;
block|}
specifier|final
name|byte
name|ch
init|=
name|seqToUnseq
index|[
name|yy
index|[
literal|0
index|]
index|]
decl_stmt|;
name|unzftab
index|[
name|ch
operator|&
literal|0xff
index|]
operator|+=
name|s
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|--
operator|>=
literal|0
condition|)
block|{
name|ll8
index|[
operator|++
name|lastShadow
index|]
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|lastShadow
operator|>=
name|limitLast
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block overrun"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|++
name|lastShadow
operator|>=
name|limitLast
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block overrun"
argument_list|)
throw|;
block|}
specifier|final
name|char
name|tmp
init|=
name|yy
index|[
name|nextSym
operator|-
literal|1
index|]
decl_stmt|;
name|unzftab
index|[
name|seqToUnseq
index|[
name|tmp
index|]
operator|&
literal|0xff
index|]
operator|++
expr_stmt|;
name|ll8
index|[
name|lastShadow
index|]
operator|=
name|seqToUnseq
index|[
name|tmp
index|]
expr_stmt|;
comment|/*                   This loop is hammered during decompression,                   hence avoid native method call overhead of                   System.arraycopy for very small ranges to copy.                 */
if|if
condition|(
name|nextSym
operator|<=
literal|16
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|nextSym
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
control|)
block|{
name|yy
index|[
name|j
index|]
operator|=
name|yy
index|[
operator|--
name|j
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|yy
argument_list|,
literal|0
argument_list|,
name|yy
argument_list|,
literal|1
argument_list|,
name|nextSym
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|yy
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|groupPos
operator|==
literal|0
condition|)
block|{
name|groupPos
operator|=
name|G_SIZE
operator|-
literal|1
expr_stmt|;
name|zt
operator|=
name|selector
index|[
operator|++
name|groupNo
index|]
operator|&
literal|0xff
expr_stmt|;
name|base_zt
operator|=
name|base
index|[
name|zt
index|]
expr_stmt|;
name|limit_zt
operator|=
name|limit
index|[
name|zt
index|]
expr_stmt|;
name|perm_zt
operator|=
name|perm
index|[
name|zt
index|]
expr_stmt|;
name|minLens_zt
operator|=
name|minLens
index|[
name|zt
index|]
expr_stmt|;
block|}
else|else
block|{
name|groupPos
operator|--
expr_stmt|;
block|}
name|int
name|zn
init|=
name|minLens_zt
decl_stmt|;
comment|// Inlined:
comment|// int zvec = bsR(zn);
while|while
condition|(
name|bsLiveShadow
operator|<
name|zn
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|inShadow
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|int
name|zvec
init|=
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
name|zn
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|zn
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|bsLiveShadow
operator|-=
name|zn
expr_stmt|;
while|while
condition|(
name|zvec
operator|>
name|limit_zt
index|[
name|zn
index|]
condition|)
block|{
name|zn
operator|++
expr_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|inShadow
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|bsLiveShadow
operator|--
expr_stmt|;
name|zvec
operator|=
operator|(
name|zvec
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|bsBuffShadow
operator|>>
name|bsLiveShadow
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|nextSym
operator|=
name|perm_zt
index|[
name|zvec
operator|-
name|base_zt
index|[
name|zn
index|]
index|]
expr_stmt|;
block|}
block|}
name|this
operator|.
name|last
operator|=
name|lastShadow
expr_stmt|;
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
block|}
specifier|private
name|int
name|getAndMoveToFrontDecode0
parameter_list|(
specifier|final
name|int
name|groupNo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|int
name|zt
init|=
name|dataShadow
operator|.
name|selector
index|[
name|groupNo
index|]
operator|&
literal|0xff
decl_stmt|;
specifier|final
name|int
index|[]
name|limit_zt
init|=
name|dataShadow
operator|.
name|limit
index|[
name|zt
index|]
decl_stmt|;
name|int
name|zn
init|=
name|dataShadow
operator|.
name|minLens
index|[
name|zt
index|]
decl_stmt|;
name|int
name|zvec
init|=
name|bsR
argument_list|(
name|zn
argument_list|)
decl_stmt|;
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
while|while
condition|(
name|zvec
operator|>
name|limit_zt
index|[
name|zn
index|]
condition|)
block|{
name|zn
operator|++
expr_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|inShadow
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|bsLiveShadow
operator|--
expr_stmt|;
name|zvec
operator|=
operator|(
name|zvec
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|bsBuffShadow
operator|>>
name|bsLiveShadow
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
return|return
name|dataShadow
operator|.
name|perm
index|[
name|zt
index|]
index|[
name|zvec
operator|-
name|dataShadow
operator|.
name|base
index|[
name|zt
index|]
index|[
name|zn
index|]
index|]
return|;
block|}
specifier|private
name|void
name|setupBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|data
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|int
index|[]
name|cftab
init|=
name|this
operator|.
name|data
operator|.
name|cftab
decl_stmt|;
specifier|final
name|int
index|[]
name|tt
init|=
name|this
operator|.
name|data
operator|.
name|initTT
argument_list|(
name|this
operator|.
name|last
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|ll8
init|=
name|this
operator|.
name|data
operator|.
name|ll8
decl_stmt|;
name|cftab
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|data
operator|.
name|unzftab
argument_list|,
literal|0
argument_list|,
name|cftab
argument_list|,
literal|1
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|,
name|c
init|=
name|cftab
index|[
literal|0
index|]
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|+=
name|cftab
index|[
name|i
index|]
expr_stmt|;
name|cftab
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|lastShadow
init|=
name|this
operator|.
name|last
init|;
name|i
operator|<=
name|lastShadow
condition|;
name|i
operator|++
control|)
block|{
name|tt
index|[
name|cftab
index|[
name|ll8
index|[
name|i
index|]
operator|&
literal|0xff
index|]
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|this
operator|.
name|origPtr
operator|<
literal|0
operator|)
operator|||
operator|(
name|this
operator|.
name|origPtr
operator|>=
name|tt
operator|.
name|length
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream corrupted"
argument_list|)
throw|;
block|}
name|this
operator|.
name|su_tPos
operator|=
name|tt
index|[
name|this
operator|.
name|origPtr
index|]
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|su_i2
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|su_ch2
operator|=
literal|256
expr_stmt|;
comment|/* not a char and not EOF */
if|if
condition|(
name|this
operator|.
name|blockRandomised
condition|)
block|{
name|this
operator|.
name|su_rNToGo
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|su_rTPos
operator|=
literal|0
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupRandPartA
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_i2
operator|<=
name|this
operator|.
name|last
condition|)
block|{
name|this
operator|.
name|su_chPrev
operator|=
name|this
operator|.
name|su_ch2
expr_stmt|;
name|int
name|su_ch2Shadow
init|=
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
decl_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|su_rNToGo
operator|=
name|BZip2Constants
operator|.
name|rNums
index|[
name|this
operator|.
name|su_rTPos
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|this
operator|.
name|su_rTPos
operator|==
literal|512
condition|)
block|{
name|this
operator|.
name|su_rTPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|su_rNToGo
operator|--
expr_stmt|;
block|}
name|this
operator|.
name|su_ch2
operator|=
name|su_ch2Shadow
operator|^=
operator|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|currentChar
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|RAND_PART_B_STATE
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|su_ch2Shadow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endBlock
argument_list|()
expr_stmt|;
name|initBlock
argument_list|()
expr_stmt|;
name|setupBlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupNoRandPartA
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_i2
operator|<=
name|this
operator|.
name|last
condition|)
block|{
name|this
operator|.
name|su_chPrev
operator|=
name|this
operator|.
name|su_ch2
expr_stmt|;
name|int
name|su_ch2Shadow
init|=
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
decl_stmt|;
name|this
operator|.
name|su_ch2
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|currentChar
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|NO_RAND_PART_B_STATE
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|su_ch2Shadow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currentState
operator|=
name|NO_RAND_PART_A_STATE
expr_stmt|;
name|endBlock
argument_list|()
expr_stmt|;
name|initBlock
argument_list|()
expr_stmt|;
name|setupBlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupRandPartB
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_ch2
operator|!=
name|this
operator|.
name|su_chPrev
condition|)
block|{
name|this
operator|.
name|currentState
operator|=
name|RAND_PART_A_STATE
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|1
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|this
operator|.
name|su_count
operator|>=
literal|4
condition|)
block|{
name|this
operator|.
name|su_z
operator|=
call|(
name|char
call|)
argument_list|(
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|su_rNToGo
operator|=
name|BZip2Constants
operator|.
name|rNums
index|[
name|this
operator|.
name|su_rTPos
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|this
operator|.
name|su_rTPos
operator|==
literal|512
condition|)
block|{
name|this
operator|.
name|su_rTPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|su_rNToGo
operator|--
expr_stmt|;
block|}
name|this
operator|.
name|su_j2
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|RAND_PART_C_STATE
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|1
condition|)
block|{
name|this
operator|.
name|su_z
operator|^=
literal|1
expr_stmt|;
block|}
name|setupRandPartC
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currentState
operator|=
name|RAND_PART_A_STATE
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupRandPartC
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_j2
operator|<
name|this
operator|.
name|su_z
condition|)
block|{
name|this
operator|.
name|currentChar
operator|=
name|this
operator|.
name|su_ch2
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|this
operator|.
name|su_ch2
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_j2
operator|++
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currentState
operator|=
name|RAND_PART_A_STATE
expr_stmt|;
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|0
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupNoRandPartB
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_ch2
operator|!=
name|this
operator|.
name|su_chPrev
condition|)
block|{
name|this
operator|.
name|su_count
operator|=
literal|1
expr_stmt|;
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|this
operator|.
name|su_count
operator|>=
literal|4
condition|)
block|{
name|this
operator|.
name|su_z
operator|=
call|(
name|char
call|)
argument_list|(
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
name|this
operator|.
name|su_j2
operator|=
literal|0
expr_stmt|;
name|setupNoRandPartC
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setupNoRandPartC
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_j2
operator|<
name|this
operator|.
name|su_z
condition|)
block|{
name|int
name|su_ch2Shadow
init|=
name|this
operator|.
name|su_ch2
decl_stmt|;
name|this
operator|.
name|currentChar
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|su_ch2Shadow
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_j2
operator|++
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|NO_RAND_PART_C_STATE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|0
expr_stmt|;
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|Data
extends|extends
name|Object
block|{
comment|// (with blockSize 900k)
specifier|final
name|boolean
index|[]
name|inUse
init|=
operator|new
name|boolean
index|[
literal|256
index|]
decl_stmt|;
comment|//      256 byte
specifier|final
name|byte
index|[]
name|seqToUnseq
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
comment|//      256 byte
specifier|final
name|byte
index|[]
name|selector
init|=
operator|new
name|byte
index|[
name|MAX_SELECTORS
index|]
decl_stmt|;
comment|//    18002 byte
specifier|final
name|byte
index|[]
name|selectorMtf
init|=
operator|new
name|byte
index|[
name|MAX_SELECTORS
index|]
decl_stmt|;
comment|//    18002 byte
comment|/**          * Freq table collected to save a pass over the data during          * decompression.          */
specifier|final
name|int
index|[]
name|unzftab
init|=
operator|new
name|int
index|[
literal|256
index|]
decl_stmt|;
comment|//     1024 byte
specifier|final
name|int
index|[]
index|[]
name|limit
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|//     6192 byte
specifier|final
name|int
index|[]
index|[]
name|base
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|//     6192 byte
specifier|final
name|int
index|[]
index|[]
name|perm
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|//     6192 byte
specifier|final
name|int
index|[]
name|minLens
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
decl_stmt|;
comment|//       24 byte
specifier|final
name|int
index|[]
name|cftab
init|=
operator|new
name|int
index|[
literal|257
index|]
decl_stmt|;
comment|//     1028 byte
specifier|final
name|char
index|[]
name|getAndMoveToFrontDecode_yy
init|=
operator|new
name|char
index|[
literal|256
index|]
decl_stmt|;
comment|//      512 byte
specifier|final
name|char
index|[]
index|[]
name|temp_charArray2d
init|=
operator|new
name|char
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|//     3096 byte
specifier|final
name|byte
index|[]
name|recvDecodingTables_pos
init|=
operator|new
name|byte
index|[
name|N_GROUPS
index|]
decl_stmt|;
comment|//        6 byte
comment|//---------------
comment|//    60798 byte
name|int
index|[]
name|tt
decl_stmt|;
comment|//  3600000 byte
name|byte
index|[]
name|ll8
decl_stmt|;
comment|//   900000 byte
comment|//---------------
comment|//  4560782 byte
comment|//===============
name|Data
parameter_list|(
name|int
name|blockSize100k
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|ll8
operator|=
operator|new
name|byte
index|[
name|blockSize100k
operator|*
name|BZip2Constants
operator|.
name|baseBlockSize
index|]
expr_stmt|;
block|}
comment|/**          * Initializes the {@link #tt} array.          *          * This method is called when the required length of the array          * is known.  I don't initialize it at construction time to          * avoid unneccessary memory allocation when compressing small          * files.          */
specifier|final
name|int
index|[]
name|initTT
parameter_list|(
name|int
name|length
parameter_list|)
block|{
name|int
index|[]
name|ttShadow
init|=
name|this
operator|.
name|tt
decl_stmt|;
comment|// tt.length should always be>= length, but theoretically
comment|// it can happen, if the compressor mixed small and large
comment|// blocks.  Normally only the last block will be smaller
comment|// than others.
if|if
condition|(
operator|(
name|ttShadow
operator|==
literal|null
operator|)
operator|||
operator|(
name|ttShadow
operator|.
name|length
operator|<
name|length
operator|)
condition|)
block|{
name|this
operator|.
name|tt
operator|=
name|ttShadow
operator|=
operator|new
name|int
index|[
name|length
index|]
expr_stmt|;
block|}
return|return
name|ttShadow
return|;
block|}
block|}
block|}
end_class

end_unit

