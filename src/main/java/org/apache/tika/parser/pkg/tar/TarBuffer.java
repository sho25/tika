begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_comment
comment|/*  * This package is based on the work done by Timothy Gerard Endres  * (time@ice.com) to whom the Ant project is very grateful for his great code.  *  * This package has since been copied from Apache Ant to Apache Tika.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|pkg
operator|.
name|tar
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * The TarBuffer class implements the tar archive concept  * of a buffered input stream. This concept goes back to the  * days of blocked tape drives and special io devices. In the  * Java universe, the only real function that this class  * performs is to ensure that files have the correct "block"  * size, or other tars will complain.  *<p>  * You should never have a need to access this class directly.  * TarBuffers are created by Tar IO Streams.  *  */
end_comment

begin_class
specifier|public
class|class
name|TarBuffer
block|{
comment|/** Default record size */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_RCDSIZE
init|=
operator|(
literal|512
operator|)
decl_stmt|;
comment|/** Default block size */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_BLKSIZE
init|=
operator|(
name|DEFAULT_RCDSIZE
operator|*
literal|20
operator|)
decl_stmt|;
specifier|private
name|InputStream
name|inStream
decl_stmt|;
specifier|private
name|OutputStream
name|outStream
decl_stmt|;
specifier|private
name|byte
index|[]
name|blockBuffer
decl_stmt|;
specifier|private
name|int
name|currBlkIdx
decl_stmt|;
specifier|private
name|int
name|currRecIdx
decl_stmt|;
specifier|private
name|int
name|blockSize
decl_stmt|;
specifier|private
name|int
name|recordSize
decl_stmt|;
specifier|private
name|int
name|recsPerBlock
decl_stmt|;
specifier|private
name|boolean
name|debug
decl_stmt|;
comment|/**      * Constructor for a TarBuffer on an input stream.      * @param inStream the input stream to use      */
specifier|public
name|TarBuffer
parameter_list|(
name|InputStream
name|inStream
parameter_list|)
block|{
name|this
argument_list|(
name|inStream
argument_list|,
name|TarBuffer
operator|.
name|DEFAULT_BLKSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor for a TarBuffer on an input stream.      * @param inStream the input stream to use      * @param blockSize the block size to use      */
specifier|public
name|TarBuffer
parameter_list|(
name|InputStream
name|inStream
parameter_list|,
name|int
name|blockSize
parameter_list|)
block|{
name|this
argument_list|(
name|inStream
argument_list|,
name|blockSize
argument_list|,
name|TarBuffer
operator|.
name|DEFAULT_RCDSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor for a TarBuffer on an input stream.      * @param inStream the input stream to use      * @param blockSize the block size to use      * @param recordSize the record size to use      */
specifier|public
name|TarBuffer
parameter_list|(
name|InputStream
name|inStream
parameter_list|,
name|int
name|blockSize
parameter_list|,
name|int
name|recordSize
parameter_list|)
block|{
name|this
operator|.
name|inStream
operator|=
name|inStream
expr_stmt|;
name|this
operator|.
name|outStream
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|initialize
argument_list|(
name|blockSize
argument_list|,
name|recordSize
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor for a TarBuffer on an output stream.      * @param outStream the output stream to use      */
specifier|public
name|TarBuffer
parameter_list|(
name|OutputStream
name|outStream
parameter_list|)
block|{
name|this
argument_list|(
name|outStream
argument_list|,
name|TarBuffer
operator|.
name|DEFAULT_BLKSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor for a TarBuffer on an output stream.      * @param outStream the output stream to use      * @param blockSize the block size to use      */
specifier|public
name|TarBuffer
parameter_list|(
name|OutputStream
name|outStream
parameter_list|,
name|int
name|blockSize
parameter_list|)
block|{
name|this
argument_list|(
name|outStream
argument_list|,
name|blockSize
argument_list|,
name|TarBuffer
operator|.
name|DEFAULT_RCDSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor for a TarBuffer on an output stream.      * @param outStream the output stream to use      * @param blockSize the block size to use      * @param recordSize the record size to use      */
specifier|public
name|TarBuffer
parameter_list|(
name|OutputStream
name|outStream
parameter_list|,
name|int
name|blockSize
parameter_list|,
name|int
name|recordSize
parameter_list|)
block|{
name|this
operator|.
name|inStream
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|outStream
operator|=
name|outStream
expr_stmt|;
name|this
operator|.
name|initialize
argument_list|(
name|blockSize
argument_list|,
name|recordSize
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initialization common to all constructors.      */
specifier|private
name|void
name|initialize
parameter_list|(
name|int
name|blockSize
parameter_list|,
name|int
name|recordSize
parameter_list|)
block|{
name|this
operator|.
name|debug
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|blockSize
operator|=
name|blockSize
expr_stmt|;
name|this
operator|.
name|recordSize
operator|=
name|recordSize
expr_stmt|;
name|this
operator|.
name|recsPerBlock
operator|=
operator|(
name|this
operator|.
name|blockSize
operator|/
name|this
operator|.
name|recordSize
operator|)
expr_stmt|;
name|this
operator|.
name|blockBuffer
operator|=
operator|new
name|byte
index|[
name|this
operator|.
name|blockSize
index|]
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|inStream
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|currBlkIdx
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|currRecIdx
operator|=
name|this
operator|.
name|recsPerBlock
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currBlkIdx
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|currRecIdx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**      * Get the TAR Buffer's block size. Blocks consist of multiple records.      * @return the block size      */
specifier|public
name|int
name|getBlockSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|blockSize
return|;
block|}
comment|/**      * Get the TAR Buffer's record size.      * @return the record size      */
specifier|public
name|int
name|getRecordSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|recordSize
return|;
block|}
comment|/**      * Set the debugging flag for the buffer.      *      * @param debug If true, print debugging output.      */
specifier|public
name|void
name|setDebug
parameter_list|(
name|boolean
name|debug
parameter_list|)
block|{
name|this
operator|.
name|debug
operator|=
name|debug
expr_stmt|;
block|}
comment|/**      * Determine if an archive record indicate End of Archive. End of      * archive is indicated by a record that consists entirely of null bytes.      *      * @param record The record data to check.      * @return true if the record data is an End of Archive      */
specifier|public
name|boolean
name|isEOFRecord
parameter_list|(
name|byte
index|[]
name|record
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|sz
init|=
name|getRecordSize
argument_list|()
init|;
name|i
operator|<
name|sz
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|record
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Skip over a record on the input stream.      * @throws IOException on error      */
specifier|public
name|void
name|skipRecord
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"SkipRecord: recIdx = "
operator|+
name|currRecIdx
operator|+
literal|" blkIdx = "
operator|+
name|currBlkIdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"reading (via skip) from an output buffer"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currRecIdx
operator|>=
name|recsPerBlock
condition|)
block|{
if|if
condition|(
operator|!
name|readBlock
argument_list|()
condition|)
block|{
return|return;
comment|// UNDONE
block|}
block|}
name|currRecIdx
operator|++
expr_stmt|;
block|}
comment|/**      * Read a record from the input stream and return the data.      *      * @return The record data.      * @throws IOException on error      */
specifier|public
name|byte
index|[]
name|readRecord
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ReadRecord: recIdx = "
operator|+
name|currRecIdx
operator|+
literal|" blkIdx = "
operator|+
name|currBlkIdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"reading from an output buffer"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currRecIdx
operator|>=
name|recsPerBlock
condition|)
block|{
if|if
condition|(
operator|!
name|readBlock
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|recordSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|blockBuffer
argument_list|,
operator|(
name|currRecIdx
operator|*
name|recordSize
operator|)
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|recordSize
argument_list|)
expr_stmt|;
name|currRecIdx
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**      * @return false if End-Of-File, else true      */
specifier|private
name|boolean
name|readBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ReadBlock: blkIdx = "
operator|+
name|currBlkIdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"reading from an output buffer"
argument_list|)
throw|;
block|}
name|currRecIdx
operator|=
literal|0
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|bytesNeeded
init|=
name|blockSize
decl_stmt|;
while|while
condition|(
name|bytesNeeded
operator|>
literal|0
condition|)
block|{
name|long
name|numBytes
init|=
name|inStream
operator|.
name|read
argument_list|(
name|blockBuffer
argument_list|,
name|offset
argument_list|,
name|bytesNeeded
argument_list|)
decl_stmt|;
comment|//
comment|// NOTE
comment|// We have fit EOF, and the block is not full!
comment|//
comment|// This is a broken archive. It does not follow the standard
comment|// blocking algorithm. However, because we are generous, and
comment|// it requires little effort, we will simply ignore the error
comment|// and continue as if the entire block were read. This does
comment|// not appear to break anything upstream. We used to return
comment|// false in this case.
comment|//
comment|// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.
comment|//
if|if
condition|(
name|numBytes
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
comment|// Ensure that we do not read gigabytes of zeros
comment|// for a corrupt tar file.
comment|// See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924
return|return
literal|false
return|;
block|}
comment|// However, just leaving the unread portion of the buffer dirty does
comment|// cause problems in some cases.  This problem is described in
comment|// http://issues.apache.org/bugzilla/show_bug.cgi?id=29877
comment|//
comment|// The solution is to fill the unused portion of the buffer with zeros.
name|Arrays
operator|.
name|fill
argument_list|(
name|blockBuffer
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|bytesNeeded
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|offset
operator|+=
name|numBytes
expr_stmt|;
name|bytesNeeded
operator|-=
name|numBytes
expr_stmt|;
if|if
condition|(
name|numBytes
operator|!=
name|blockSize
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"ReadBlock: INCOMPLETE READ "
operator|+
name|numBytes
operator|+
literal|" of "
operator|+
name|blockSize
operator|+
literal|" bytes read."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|currBlkIdx
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Get the current block number, zero based.      *      * @return The current zero based block number.      */
specifier|public
name|int
name|getCurrentBlockNum
parameter_list|()
block|{
return|return
name|currBlkIdx
return|;
block|}
comment|/**      * Get the current record number, within the current block, zero based.      * Thus, current offset = (currentBlockNum * recsPerBlk) + currentRecNum.      *      * @return The current zero based record number.      */
specifier|public
name|int
name|getCurrentRecordNum
parameter_list|()
block|{
return|return
name|currRecIdx
operator|-
literal|1
return|;
block|}
comment|/**      * Write an archive record to the archive.      *      * @param record The record data to write to the archive.      * @throws IOException on error      */
specifier|public
name|void
name|writeRecord
parameter_list|(
name|byte
index|[]
name|record
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"WriteRecord: recIdx = "
operator|+
name|currRecIdx
operator|+
literal|" blkIdx = "
operator|+
name|currBlkIdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"writing to an input buffer"
argument_list|)
throw|;
block|}
if|if
condition|(
name|record
operator|.
name|length
operator|!=
name|recordSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"record to write has length '"
operator|+
name|record
operator|.
name|length
operator|+
literal|"' which is not the record size of '"
operator|+
name|recordSize
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currRecIdx
operator|>=
name|recsPerBlock
condition|)
block|{
name|writeBlock
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|record
argument_list|,
literal|0
argument_list|,
name|blockBuffer
argument_list|,
operator|(
name|currRecIdx
operator|*
name|recordSize
operator|)
argument_list|,
name|recordSize
argument_list|)
expr_stmt|;
name|currRecIdx
operator|++
expr_stmt|;
block|}
comment|/**      * Write an archive record to the archive, where the record may be      * inside of a larger array buffer. The buffer must be "offset plus      * record size" long.      *      * @param buf The buffer containing the record data to write.      * @param offset The offset of the record data within buf.      * @throws IOException on error      */
specifier|public
name|void
name|writeRecord
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"WriteRecord: recIdx = "
operator|+
name|currRecIdx
operator|+
literal|" blkIdx = "
operator|+
name|currBlkIdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"writing to an input buffer"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|offset
operator|+
name|recordSize
operator|)
operator|>
name|buf
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"record has length '"
operator|+
name|buf
operator|.
name|length
operator|+
literal|"' with offset '"
operator|+
name|offset
operator|+
literal|"' which is less than the record size of '"
operator|+
name|recordSize
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currRecIdx
operator|>=
name|recsPerBlock
condition|)
block|{
name|writeBlock
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|blockBuffer
argument_list|,
operator|(
name|currRecIdx
operator|*
name|recordSize
operator|)
argument_list|,
name|recordSize
argument_list|)
expr_stmt|;
name|currRecIdx
operator|++
expr_stmt|;
block|}
comment|/**      * Write a TarBuffer block to the archive.      */
specifier|private
name|void
name|writeBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"WriteBlock: blkIdx = "
operator|+
name|currBlkIdx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"writing to an input buffer"
argument_list|)
throw|;
block|}
name|outStream
operator|.
name|write
argument_list|(
name|blockBuffer
argument_list|,
literal|0
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|flush
argument_list|()
expr_stmt|;
name|currRecIdx
operator|=
literal|0
expr_stmt|;
name|currBlkIdx
operator|++
expr_stmt|;
block|}
comment|/**      * Flush the current data block if it has any data in it.      */
specifier|private
name|void
name|flushBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TarBuffer.flushBlock() called."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"writing to an input buffer"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currRecIdx
operator|>
literal|0
condition|)
block|{
name|writeBlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Close the TarBuffer. If this is an output buffer, also flush the      * current block before closing.      * @throws IOException on error      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"TarBuffer.closeBuffer()."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outStream
operator|!=
literal|null
condition|)
block|{
name|flushBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|outStream
operator|!=
name|System
operator|.
name|out
operator|&&
name|outStream
operator|!=
name|System
operator|.
name|err
condition|)
block|{
name|outStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|outStream
operator|=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inStream
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|inStream
operator|!=
name|System
operator|.
name|in
condition|)
block|{
name|inStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|inStream
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

