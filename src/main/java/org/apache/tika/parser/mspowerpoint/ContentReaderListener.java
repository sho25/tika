begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|mspowerpoint
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|hdf
operator|.
name|extractor
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|eventfilesystem
operator|.
name|POIFSReaderEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|eventfilesystem
operator|.
name|POIFSReaderListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|poifs
operator|.
name|filesystem
operator|.
name|DocumentInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|util
operator|.
name|LittleEndian
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|poi
operator|.
name|util
operator|.
name|StringUtil
import|;
end_import

begin_comment
comment|/**  * Listener to read the content of PowerPoint file and transfere it to the  * passed<code>StringBuffer</code>.  *   * @author Stephan Strittmatter - http://www.sybit.de  *   * @version 1.0  *   */
end_comment

begin_class
class|class
name|ContentReaderListener
implements|implements
name|POIFSReaderListener
block|{
specifier|static
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getRootLogger
argument_list|()
decl_stmt|;
comment|/** Buffer holding the content of the file */
specifier|protected
specifier|final
specifier|transient
name|StringBuffer
name|buf
decl_stmt|;
comment|/**      * Constructs Listener to get content of PowerPoint file.      *       * @param content      *            StringBuffer refereing the content of the PowerPoint file.      */
specifier|public
name|ContentReaderListener
parameter_list|(
specifier|final
name|StringBuffer
name|content
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|=
name|content
expr_stmt|;
block|}
comment|/**      * Reads the internal PowerPoint document stream.      *       * @see org.apache.poi.poifs.eventfilesystem.POIFSReaderListener#processPOIFSReaderEvent(org.apache.poi.poifs.eventfilesystem.POIFSReaderEvent)      */
specifier|public
name|void
name|processPOIFSReaderEvent
parameter_list|(
specifier|final
name|POIFSReaderEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|==
literal|null
operator|||
name|event
operator|.
name|getName
argument_list|()
operator|==
literal|null
operator|||
operator|!
name|event
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|PPTConstants
operator|.
name|POWERPOINT_DOCUMENT
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Stream not processed. It is not a PowerPoint document: : "
operator|+
name|event
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
specifier|final
name|DocumentInputStream
name|dis
init|=
name|event
operator|.
name|getStream
argument_list|()
decl_stmt|;
specifier|final
name|byte
name|pptdata
index|[]
init|=
operator|new
name|byte
index|[
name|dis
operator|.
name|available
argument_list|()
index|]
decl_stmt|;
name|dis
operator|.
name|read
argument_list|(
name|pptdata
argument_list|,
literal|0
argument_list|,
name|dis
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|long
name|offsetPD
init|=
literal|0
decl_stmt|;
comment|/*              * Traverse Bytearray to get CurrentUserEditAtom Call to extract the              * Text in all PlaceHolders to hold PPTClientTextBox objects for              * mapping into Slide Objects              */
name|Hashtable
comment|/*<Long, TextBox> */
name|containerTextBox
init|=
operator|new
name|Hashtable
comment|/*                                                                              *<Long,                                                                              * TextBox>                                                                              */
argument_list|()
decl_stmt|;
comment|// Traverse ByteArray to identiy edit paths of ClientTextBoxes
name|long
name|n
init|=
name|pptdata
operator|.
name|length
operator|-
literal|20
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|type
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// final long size = LittleEndian.getUInt(pptdata, (int) i + 4);
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_USEREDIT
operator|==
name|type
condition|)
block|{
comment|/*                      * Checking the Record Header (UserEditAtom)                      */
comment|// final long lastSlideID = LittleEndian.getInt(pptdata,
comment|// (int) i + 8);
comment|// final long version = LittleEndian.getUInt(pptdata, (int)
comment|// i + 12);
name|offset
operator|=
operator|(
name|int
operator|)
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|16
argument_list|)
expr_stmt|;
name|offsetPD
operator|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|20
argument_list|)
expr_stmt|;
comment|/*                      * Call to extract ClientTextBox text in each UserEditAtom                      */
name|containerTextBox
operator|=
name|extractTextBoxes
argument_list|(
name|containerTextBox
argument_list|,
name|offset
argument_list|,
name|pptdata
argument_list|,
name|offsetPD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
operator|==
name|type
condition|)
block|{
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("PPT_DRAWINGGROUP_ATOM ignored: " + type);
comment|// }
block|}
elseif|else
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTBYTE
operator|==
name|type
condition|)
block|{
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("PPT_TEXTBYTE_ATOM ignored: " + type);
comment|// }
block|}
elseif|else
if|if
condition|(
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTCHAR
operator|==
name|type
condition|)
block|{
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("PPT_TEXTCHAR_ATOM ignored: " + type);
comment|// }
block|}
else|else
block|{
comment|// no action
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("type not handled: " + type);
comment|// }
block|}
block|}
specifier|final
name|List
comment|/*<PPTSlide> */
name|slides
init|=
name|extractSlides
argument_list|(
name|offset
argument_list|,
name|pptdata
argument_list|,
name|offsetPD
argument_list|)
decl_stmt|;
if|if
condition|(
name|slides
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No slides extracted!"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Slide
name|slide
init|=
operator|(
name|Slide
operator|)
name|slides
operator|.
name|get
argument_list|(
name|slides
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|Enumeration
name|enumeration
init|=
name|containerTextBox
operator|.
name|elements
argument_list|()
init|;
name|enumeration
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
specifier|final
name|TextBox
name|textBox
init|=
operator|(
name|TextBox
operator|)
name|enumeration
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|slide
operator|.
name|addContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*                  * Merging TextBox data with Slide Data Printing the text from                  * Slides vector object.                  */
name|List
name|scontent
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|slides
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|slide
operator|=
operator|(
name|Slide
operator|)
name|slides
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|scontent
operator|=
name|slide
operator|.
name|getContent
argument_list|()
expr_stmt|;
name|String
name|contentText
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|scontent
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|contentText
operator|=
name|scontent
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|buf
operator|.
name|append
argument_list|(
name|contentText
argument_list|)
expr_stmt|;
comment|// to avoid concatinated words we add a blank additional
if|if
condition|(
name|contentText
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
operator|!
operator|(
name|contentText
operator|.
name|endsWith
argument_list|(
literal|"\r"
argument_list|)
operator|||
name|contentText
operator|.
name|endsWith
argument_list|(
literal|"\n"
argument_list|)
operator|)
condition|)
block|{
name|this
operator|.
name|buf
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// because of not killing complete crawling all Throwables are
comment|// catched.
name|LOG
operator|.
name|error
argument_list|(
literal|"processPOIFSReaderEvent"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Extracts the client text boxes of a slide.      *       * @param containerTextBox      * @param offset      * @param pptdata      * @param offsetPD      * @return Hashtable      * @see TextBox      */
specifier|protected
name|Hashtable
comment|/*<Long, TextBox> */
name|extractTextBoxes
parameter_list|(
specifier|final
name|Hashtable
comment|/*<Long, TextBox> */
name|containerTextBox
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|byte
index|[]
name|pptdata
parameter_list|,
specifier|final
name|long
name|offsetPD
parameter_list|)
block|{
comment|// To hold temporary data
name|FilteredStringWriter
name|outStream
init|=
operator|new
name|FilteredStringWriter
argument_list|()
decl_stmt|;
name|TextBox
name|textBox
decl_stmt|;
comment|// Traversing the bytearray up to Presist directory position
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|offsetPD
operator|-
literal|20
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
comment|// Record info
comment|// final long rinfo = LittleEndian.getUShort(pptdata, (int) i);
comment|// Record Type
specifier|final
name|long
name|recordType
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// Record Size
specifier|final
name|long
name|recordSize
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
name|i
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|recordType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
condition|)
block|{
comment|/*                      * Record type is of Drawing Group                      */
comment|// Total number of objects
comment|// final long objectCount = LittleEndian.getUInt(pptdata,
comment|// (int) i +
comment|// 8);
comment|// currentID = Group ID+number of objects
name|long
name|currentID
init|=
name|LittleEndian
operator|.
name|getInt
argument_list|(
name|pptdata
argument_list|,
name|i
operator|+
literal|12
argument_list|)
decl_stmt|;
name|currentID
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|currentID
operator|/
literal|1024
argument_list|)
operator|)
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|currentID
operator|==
name|PPTConstants
operator|.
name|PPT_MASTERSLIDE
condition|)
block|{
comment|// Ignore Master Slide objects
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Ignore master slide."
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// Check for the ClientTextBox GroupID existence
if|if
condition|(
name|containerTextBox
operator|.
name|containsKey
argument_list|(
operator|new
name|Long
argument_list|(
name|currentID
argument_list|)
argument_list|)
condition|)
block|{
comment|// If exists get Client Textbox Group
name|textBox
operator|=
operator|(
name|TextBox
operator|)
name|containerTextBox
operator|.
name|get
argument_list|(
operator|new
name|Long
argument_list|(
name|currentID
argument_list|)
argument_list|)
expr_stmt|;
name|textBox
operator|.
name|setContent
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|textBox
operator|=
operator|new
name|TextBox
argument_list|(
name|currentID
argument_list|)
expr_stmt|;
name|containerTextBox
operator|.
name|put
argument_list|(
operator|new
name|Long
argument_list|(
name|currentID
argument_list|)
argument_list|,
name|textBox
argument_list|)
expr_stmt|;
block|}
comment|/*                      * Iterating the bytearray for TextCharAtoms and                      * TextBytesAtom                      */
if|if
condition|(
operator|(
name|offsetPD
operator|-
literal|20
operator|)
operator|!=
name|recordSize
condition|)
block|{
comment|// TODO something wrong? Probably an OLE-Object, which
comment|// we ignore.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"offsetPD - 20="
operator|+
operator|(
name|offsetPD
operator|-
literal|20
operator|)
operator|+
literal|" recordsize="
operator|+
name|recordSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|startPos
init|=
name|i
operator|+
literal|8
init|;
name|startPos
operator|<
name|offsetPD
operator|-
literal|20
operator|&&
name|startPos
operator|<
name|recordSize
condition|;
name|startPos
operator|++
control|)
block|{
comment|//&&
comment|// startPos
comment|//<
comment|// recordSize??
try|try
block|{
comment|// Record info
comment|// final long nrinfo =
comment|// LittleEndian.getUShort(pptdata, (int) j);
comment|// Record Type
specifier|final
name|long
name|ntype
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
name|startPos
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// Record size
comment|// Note that the size doesn't include the 8 byte
comment|// atom header
specifier|final
name|long
name|nsize
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
name|startPos
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|ntype
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
condition|)
block|{
comment|/*                                      * Break the loop if next GroupID found                                      */
name|i
operator|=
name|startPos
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ntype
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTBYTE
condition|)
block|{
comment|// TextByteAtom record
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
name|long
name|ii
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ii
operator|=
name|startPos
operator|+
literal|6
init|;
name|ii
operator|<=
name|startPos
operator|+
literal|6
operator|+
name|nsize
condition|;
name|ii
operator|++
control|)
block|{
comment|// For loop to changed to a function
comment|// if ((ii + 2)>= pptdata.length)
comment|// break; // FIXME
name|outStream
operator|.
name|write
argument_list|(
call|(
name|char
call|)
argument_list|(
name|pptdata
index|[
operator|(
name|int
operator|)
name|ii
operator|+
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Setting the identified text for Current
comment|// groupID
name|textBox
operator|.
name|setContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
operator|+
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ntype
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTCHAR
condition|)
block|{
comment|// TextCharAtom record
specifier|final
name|String
name|strTempContent
init|=
operator|new
name|String
argument_list|(
name|pptdata
argument_list|,
name|startPos
operator|+
literal|6
argument_list|,
call|(
name|int
call|)
argument_list|(
name|nsize
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|bytes
index|[]
init|=
name|strTempContent
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
literal|true
condition|)
block|{
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|bytes
operator|.
name|length
operator|-
literal|1
condition|;
name|ii
operator|+=
literal|2
control|)
block|{
comment|// For loop to changed to a function
name|outStream
operator|.
name|write
argument_list|(
call|(
name|char
call|)
argument_list|(
name|pptdata
index|[
name|ii
operator|+
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|textBox
operator|.
name|setContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
operator|+
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this version is used within POI
name|String
name|text
init|=
name|StringUtil
operator|.
name|getFromCompressedUnicode
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
decl_stmt|;
name|textBox
operator|.
name|setContent
argument_list|(
name|textBox
operator|.
name|getContent
argument_list|()
operator|+
name|text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// ignored
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("Ignored atom type: " + type);
comment|// }
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"extractTextBoxes"
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Record type is ignored
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("Ignored record type: " + type);
comment|// }
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ee
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"extractClientTextBoxes"
argument_list|,
name|ee
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|containerTextBox
return|;
block|}
comment|/**      * Returns the Powerpoint<code>Slide</code> s of document as vector.      *       * @param offset      * @param pptdata      * @param offsetPD      * @return Vector of the powerpoint slides. Contains      *<code>{@link Slide Slide}</code>      * @see Slide      */
specifier|protected
name|List
comment|/*<Slide> */
name|extractSlides
parameter_list|(
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|byte
index|[]
name|pptdata
parameter_list|,
specifier|final
name|long
name|offsetPD
parameter_list|)
block|{
name|int
name|sNum
init|=
literal|0
decl_stmt|;
comment|// List of all slides found
specifier|final
name|List
comment|/*<Slide> */
name|slides
init|=
operator|new
name|Vector
comment|/*<Slide> */
argument_list|()
decl_stmt|;
comment|// current slide data
name|Slide
name|currentSlide
init|=
literal|null
decl_stmt|;
comment|// To store data found in TextCharAtoms and TextBytesAtoms
name|FilteredStringWriter
name|outStream
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
name|offset
init|;
name|i
operator|<
name|pptdata
operator|.
name|length
operator|-
literal|20
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|recordInfo
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
decl_stmt|;
specifier|final
name|long
name|atomType
init|=
name|LittleEndian
operator|.
name|getUShort
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|long
name|atomSize
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTBYTE
condition|)
block|{
comment|/*                  * TextByteAtom record                  */
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
for|for
control|(
name|long
name|ii
init|=
name|i
operator|+
literal|6
init|;
operator|(
name|ii
operator|<=
name|i
operator|+
literal|6
operator|+
name|atomSize
operator|)
operator|&&
operator|(
name|ii
operator|+
literal|2
operator|<
name|pptdata
operator|.
name|length
operator|)
condition|;
name|ii
operator|++
control|)
block|{
try|try
block|{
comment|// if(ii+2>= pptdata.length) break; //FIXME
name|byte
name|value
init|=
name|pptdata
index|[
operator|(
name|int
operator|)
name|ii
operator|+
literal|2
index|]
decl_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"size="
operator|+
name|pptdata
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"extractSlides"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Setting the identified text for Current Slide
if|if
condition|(
name|currentSlide
operator|!=
literal|null
condition|)
block|{
name|currentSlide
operator|.
name|addContent
argument_list|(
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_TEXTCHAR
condition|)
block|{
comment|/*                  * TextCharAtom record                  */
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
specifier|final
name|String
name|strTempContent
init|=
operator|new
name|String
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|6
argument_list|,
call|(
name|int
call|)
argument_list|(
name|atomSize
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|byte
name|bytes
index|[]
init|=
name|strTempContent
operator|.
name|getBytes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|bytes
operator|.
name|length
operator|-
literal|1
condition|;
name|ii
operator|+=
literal|2
control|)
block|{
name|outStream
operator|.
name|write
argument_list|(
name|Utils
operator|.
name|getUnicodeCharacter
argument_list|(
name|bytes
argument_list|,
name|ii
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Setting the identified text for Current Slide
if|if
condition|(
name|currentSlide
operator|!=
literal|null
condition|)
block|{
name|currentSlide
operator|.
name|addContent
argument_list|(
name|outStream
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_SLIDEPERSISTANT
condition|)
block|{
comment|/*                  * SlidePresistAtom Record                  */
if|if
condition|(
name|sNum
operator|!=
literal|0
condition|)
block|{
name|outStream
operator|=
operator|new
name|FilteredStringWriter
argument_list|()
expr_stmt|;
specifier|final
name|long
name|slideID
init|=
name|LittleEndian
operator|.
name|getUInt
argument_list|(
name|pptdata
argument_list|,
operator|(
name|int
operator|)
name|i
operator|+
literal|20
argument_list|)
decl_stmt|;
name|currentSlide
operator|=
operator|new
name|Slide
argument_list|(
name|slideID
argument_list|)
expr_stmt|;
comment|// currentSlide.addContent(outStream.toString());
name|slides
operator|.
name|add
argument_list|(
name|currentSlide
argument_list|)
expr_stmt|;
block|}
name|sNum
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|atomType
operator|==
name|PPTConstants
operator|.
name|PPT_ATOM_DRAWINGGROUP
condition|)
block|{
comment|/*                  * Diagram records are ignored                  */
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Drawing Groups are ignored."
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
comment|// ignored
comment|// if (LOG.isTraceEnabled()) {
comment|// LOG.trace("Unhandled atomType: " + atomType);
comment|// }
block|}
block|}
return|return
name|slides
return|;
block|}
block|}
end_class

end_unit

