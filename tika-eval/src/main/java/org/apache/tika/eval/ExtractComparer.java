begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Types
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Option
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|batch
operator|.
name|FileResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|batch
operator|.
name|fs
operator|.
name|FSProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|config
operator|.
name|TikaConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|db
operator|.
name|ColInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|db
operator|.
name|Cols
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|db
operator|.
name|TableInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|io
operator|.
name|ExtractReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|io
operator|.
name|ExtractReaderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|io
operator|.
name|IDBWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|tokens
operator|.
name|ContrastStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|tokens
operator|.
name|TokenContraster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|eval
operator|.
name|tokens
operator|.
name|TokenIntPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|RecursiveParserWrapper
import|;
end_import

begin_class
specifier|public
class|class
name|ExtractComparer
extends|extends
name|AbstractProfiler
block|{
specifier|static
name|Options
name|OPTIONS
decl_stmt|;
static|static
block|{
name|Option
name|extractsA
init|=
operator|new
name|Option
argument_list|(
literal|"extractsA"
argument_list|,
literal|true
argument_list|,
literal|"directory for extractsA files"
argument_list|)
decl_stmt|;
name|extractsA
operator|.
name|setRequired
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Option
name|extractsB
init|=
operator|new
name|Option
argument_list|(
literal|"extractsB"
argument_list|,
literal|true
argument_list|,
literal|"directory for extractsB files"
argument_list|)
decl_stmt|;
name|extractsB
operator|.
name|setRequired
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Option
name|inputDir
init|=
operator|new
name|Option
argument_list|(
literal|"inputDir"
argument_list|,
literal|true
argument_list|,
literal|"optional: directory of original binary input files if it exists "
operator|+
literal|"or can be the same as -extractsA or -extractsB. If not specified, -inputDir=-extractsA"
argument_list|)
decl_stmt|;
name|OPTIONS
operator|=
operator|new
name|Options
argument_list|()
operator|.
name|addOption
argument_list|(
name|extractsA
argument_list|)
operator|.
name|addOption
argument_list|(
name|extractsB
argument_list|)
operator|.
name|addOption
argument_list|(
name|inputDir
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"bc"
argument_list|,
literal|"optional: tika-batch config file"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"numConsumers"
argument_list|,
literal|true
argument_list|,
literal|"optional: number of consumer threads"
argument_list|)
operator|.
name|addOption
argument_list|(
operator|new
name|Option
argument_list|(
literal|"alterExtract"
argument_list|,
literal|true
argument_list|,
literal|"for json-formatted extract files, "
operator|+
literal|"process full metadata list ('as_is'=default), "
operator|+
literal|"take just the first/container document ('first_only'), "
operator|+
literal|"concatenate all content into the first metadata item ('concatenate_content')"
argument_list|)
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"minExtractLength"
argument_list|,
literal|true
argument_list|,
literal|"minimum extract length to process (in bytes)"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"maxExtractLength"
argument_list|,
literal|true
argument_list|,
literal|"maximum extract length to process (in bytes)"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"db"
argument_list|,
literal|true
argument_list|,
literal|"db file to which to write results"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"jdbc"
argument_list|,
literal|true
argument_list|,
literal|"EXPERT: full jdbc connection string. Must specify this or -db<h2db>"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"jdbcDriver"
argument_list|,
literal|true
argument_list|,
literal|"EXPERT: jdbc driver, or specify via -Djdbc.driver"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"tablePrefixA"
argument_list|,
literal|true
argument_list|,
literal|"EXPERT: optional prefix for table names for A"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"tablePrefixB"
argument_list|,
literal|true
argument_list|,
literal|"EXPERT: optional prefix for table names for B"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"drop"
argument_list|,
literal|true
argument_list|,
literal|"drop tables if they exist"
argument_list|)
operator|.
name|addOption
argument_list|(
literal|"maxFilesToAdd"
argument_list|,
literal|true
argument_list|,
literal|"maximum number of files to add to the crawler"
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|USAGE
parameter_list|()
block|{
name|HelpFormatter
name|helpFormatter
init|=
operator|new
name|HelpFormatter
argument_list|()
decl_stmt|;
name|helpFormatter
operator|.
name|printHelp
argument_list|(
literal|80
argument_list|,
literal|"java -jar tika-eval-x.y.jar Compare -extractsA extractsA -extractsB extractsB -db mydb"
argument_list|,
literal|"Tool: Compare"
argument_list|,
name|ExtractComparer
operator|.
name|OPTIONS
argument_list|,
literal|"Note: for the default h2 db, do not include the .mv.db at the end of the db name."
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
specifier|static
name|String
name|FIELD_A
init|=
literal|"fa"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
name|FIELD_B
init|=
literal|"fb"
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|REF_PAIR_NAMES
init|=
operator|new
name|TableInfo
argument_list|(
literal|"pair_names"
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|DIR_NAME_A
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
literal|128
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|DIR_NAME_B
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
literal|128
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|COMPARISON_CONTAINERS
init|=
operator|new
name|TableInfo
argument_list|(
literal|"containers"
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|CONTAINER_ID
argument_list|,
name|Types
operator|.
name|INTEGER
argument_list|,
literal|"PRIMARY KEY"
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|FILE_PATH
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
name|FILE_PATH_MAX_LEN
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|FILE_EXTENSION
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
literal|12
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|LENGTH
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|EXTRACT_FILE_LENGTH_A
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|EXTRACT_FILE_LENGTH_B
argument_list|,
name|Types
operator|.
name|BIGINT
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|CONTENT_COMPARISONS
init|=
operator|new
name|TableInfo
argument_list|(
literal|"content_comparisons"
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|ID
argument_list|,
name|Types
operator|.
name|INTEGER
argument_list|,
literal|"PRIMARY KEY"
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|TOP_10_UNIQUE_TOKEN_DIFFS_A
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
literal|1024
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|TOP_10_UNIQUE_TOKEN_DIFFS_B
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
literal|1024
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|TOP_10_MORE_IN_A
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
literal|1024
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|TOP_10_MORE_IN_B
argument_list|,
name|Types
operator|.
name|VARCHAR
argument_list|,
literal|1024
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|DICE_COEFFICIENT
argument_list|,
name|Types
operator|.
name|FLOAT
argument_list|)
argument_list|,
operator|new
name|ColInfo
argument_list|(
name|Cols
operator|.
name|OVERLAP
argument_list|,
name|Types
operator|.
name|FLOAT
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|PROFILES_A
init|=
operator|new
name|TableInfo
argument_list|(
literal|"profiles_a"
argument_list|,
name|ExtractProfiler
operator|.
name|PROFILE_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|PROFILES_B
init|=
operator|new
name|TableInfo
argument_list|(
literal|"profiles_b"
argument_list|,
name|ExtractProfiler
operator|.
name|PROFILE_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|EMBEDDED_FILE_PATH_TABLE_A
init|=
operator|new
name|TableInfo
argument_list|(
literal|"emb_path_a"
argument_list|,
name|ExtractProfiler
operator|.
name|EMBEDDED_FILE_PATH_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|EMBEDDED_FILE_PATH_TABLE_B
init|=
operator|new
name|TableInfo
argument_list|(
literal|"emb_path_b"
argument_list|,
name|ExtractProfiler
operator|.
name|EMBEDDED_FILE_PATH_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|CONTENTS_TABLE_A
init|=
operator|new
name|TableInfo
argument_list|(
literal|"contents_a"
argument_list|,
name|ExtractProfiler
operator|.
name|CONTENTS_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|CONTENTS_TABLE_B
init|=
operator|new
name|TableInfo
argument_list|(
literal|"contents_b"
argument_list|,
name|ExtractProfiler
operator|.
name|CONTENTS_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|EXCEPTION_TABLE_A
init|=
operator|new
name|TableInfo
argument_list|(
literal|"exceptions_a"
argument_list|,
name|ExtractProfiler
operator|.
name|EXCEPTION_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|EXCEPTION_TABLE_B
init|=
operator|new
name|TableInfo
argument_list|(
literal|"exceptions_b"
argument_list|,
name|ExtractProfiler
operator|.
name|EXCEPTION_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|EXTRACT_EXCEPTION_TABLE_A
init|=
operator|new
name|TableInfo
argument_list|(
literal|"extract_exceptions_a"
argument_list|,
name|ExtractProfiler
operator|.
name|EXTRACT_EXCEPTION_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|TableInfo
name|EXTRACT_EXCEPTION_TABLE_B
init|=
operator|new
name|TableInfo
argument_list|(
literal|"extract_exceptions_b"
argument_list|,
name|ExtractProfiler
operator|.
name|EXTRACT_EXCEPTION_TABLE
operator|.
name|getColInfos
argument_list|()
argument_list|)
decl_stmt|;
comment|//need to parameterize?
specifier|private
specifier|final
name|TikaConfig
name|config
init|=
name|TikaConfig
operator|.
name|getDefaultConfig
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Path
name|inputDir
decl_stmt|;
specifier|private
specifier|final
name|Path
name|extractsA
decl_stmt|;
specifier|private
specifier|final
name|Path
name|extractsB
decl_stmt|;
specifier|private
specifier|final
name|TokenContraster
name|tokenContraster
init|=
operator|new
name|TokenContraster
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ExtractReader
name|extractReader
decl_stmt|;
specifier|public
name|ExtractComparer
parameter_list|(
name|ArrayBlockingQueue
argument_list|<
name|FileResource
argument_list|>
name|queue
parameter_list|,
name|Path
name|inputDir
parameter_list|,
name|Path
name|extractsA
parameter_list|,
name|Path
name|extractsB
parameter_list|,
name|ExtractReader
name|extractReader
parameter_list|,
name|IDBWriter
name|writer
parameter_list|)
block|{
name|super
argument_list|(
name|queue
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|this
operator|.
name|inputDir
operator|=
name|inputDir
expr_stmt|;
name|this
operator|.
name|extractsA
operator|=
name|extractsA
expr_stmt|;
name|this
operator|.
name|extractsB
operator|=
name|extractsB
expr_stmt|;
name|this
operator|.
name|extractReader
operator|=
name|extractReader
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|processFileResource
parameter_list|(
name|FileResource
name|fileResource
parameter_list|)
block|{
name|Metadata
name|metadata
init|=
name|fileResource
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|EvalFilePaths
name|fpsA
init|=
literal|null
decl_stmt|;
name|EvalFilePaths
name|fpsB
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|inputDir
operator|!=
literal|null
operator|&&
operator|(
name|inputDir
operator|.
name|equals
argument_list|(
name|extractsA
argument_list|)
operator|||
name|inputDir
operator|.
name|equals
argument_list|(
name|extractsB
argument_list|)
operator|)
condition|)
block|{
comment|//crawling an extract dir
name|fpsA
operator|=
name|getPathsFromExtractCrawl
argument_list|(
name|metadata
argument_list|,
name|extractsA
argument_list|)
expr_stmt|;
name|fpsB
operator|=
name|getPathsFromExtractCrawl
argument_list|(
name|metadata
argument_list|,
name|extractsB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fpsA
operator|=
name|getPathsFromSrcCrawl
argument_list|(
name|metadata
argument_list|,
name|inputDir
argument_list|,
name|extractsA
argument_list|)
expr_stmt|;
name|fpsB
operator|=
name|getPathsFromSrcCrawl
argument_list|(
name|metadata
argument_list|,
name|inputDir
argument_list|,
name|extractsB
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|compareFiles
argument_list|(
name|fpsA
argument_list|,
name|fpsB
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
comment|//this should be cataclysmic...
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Exception while working on: "
operator|+
name|metadata
operator|.
name|get
argument_list|(
name|FSProperties
operator|.
name|FS_REL_PATH
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|//protected for testing, should find better way so that this can be private!
specifier|protected
name|void
name|compareFiles
parameter_list|(
name|EvalFilePaths
name|fpsA
parameter_list|,
name|EvalFilePaths
name|fpsB
parameter_list|)
throws|throws
name|IOException
block|{
name|ExtractReaderException
operator|.
name|TYPE
name|extractExceptionA
init|=
literal|null
decl_stmt|;
name|ExtractReaderException
operator|.
name|TYPE
name|extractExceptionB
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Metadata
argument_list|>
name|metadataListA
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|extractExceptionA
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|metadataListA
operator|=
name|extractReader
operator|.
name|loadExtract
argument_list|(
name|fpsA
operator|.
name|getExtractFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExtractReaderException
name|e
parameter_list|)
block|{
name|extractExceptionA
operator|=
name|e
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Metadata
argument_list|>
name|metadataListB
init|=
literal|null
decl_stmt|;
try|try
block|{
name|metadataListB
operator|=
name|extractReader
operator|.
name|loadExtract
argument_list|(
name|fpsB
operator|.
name|getExtractFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExtractReaderException
name|e
parameter_list|)
block|{
name|extractExceptionB
operator|=
name|e
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
comment|//array indices for those metadata items handled in B
name|Set
argument_list|<
name|Integer
argument_list|>
name|handledB
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|containerID
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|ID
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
decl_stmt|;
comment|//container table
name|Map
argument_list|<
name|Cols
argument_list|,
name|String
argument_list|>
name|contData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|contData
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|CONTAINER_ID
argument_list|,
name|containerID
argument_list|)
expr_stmt|;
name|contData
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|FILE_PATH
argument_list|,
name|fpsA
operator|.
name|getRelativeSourceFilePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|srcFileLength
init|=
name|getSourceFileLength
argument_list|(
name|metadataListA
argument_list|,
name|metadataListB
argument_list|)
decl_stmt|;
name|contData
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|LENGTH
argument_list|,
name|srcFileLength
operator|>
name|NON_EXISTENT_FILE_LENGTH
condition|?
name|Long
operator|.
name|toString
argument_list|(
name|srcFileLength
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|contData
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|FILE_EXTENSION
argument_list|,
name|FilenameUtils
operator|.
name|getExtension
argument_list|(
name|fpsA
operator|.
name|getRelativeSourceFilePath
argument_list|()
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|extractFileLengthA
init|=
name|getFileLength
argument_list|(
name|fpsA
operator|.
name|getExtractFile
argument_list|()
argument_list|)
decl_stmt|;
name|contData
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|EXTRACT_FILE_LENGTH_A
argument_list|,
name|extractFileLengthA
operator|>
name|NON_EXISTENT_FILE_LENGTH
condition|?
name|Long
operator|.
name|toString
argument_list|(
name|extractFileLengthA
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|long
name|extractFileLengthB
init|=
name|getFileLength
argument_list|(
name|fpsB
operator|.
name|getExtractFile
argument_list|()
argument_list|)
decl_stmt|;
name|contData
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|EXTRACT_FILE_LENGTH_B
argument_list|,
name|extractFileLengthB
operator|>
name|NON_EXISTENT_FILE_LENGTH
condition|?
name|Long
operator|.
name|toString
argument_list|(
name|extractFileLengthB
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeRow
argument_list|(
name|COMPARISON_CONTAINERS
argument_list|,
name|contData
argument_list|)
expr_stmt|;
if|if
condition|(
name|extractExceptionA
operator|!=
literal|null
condition|)
block|{
name|writeExtractException
argument_list|(
name|EXTRACT_EXCEPTION_TABLE_A
argument_list|,
name|containerID
argument_list|,
name|fpsA
operator|.
name|getRelativeSourceFilePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|extractExceptionA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extractExceptionB
operator|!=
literal|null
condition|)
block|{
name|writeExtractException
argument_list|(
name|EXTRACT_EXCEPTION_TABLE_B
argument_list|,
name|containerID
argument_list|,
name|fpsB
operator|.
name|getRelativeSourceFilePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|extractExceptionB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metadataListA
operator|==
literal|null
operator|&&
name|metadataListB
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|numAttachmentsA
init|=
name|countAttachments
argument_list|(
name|metadataListA
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|numAttachmentsB
init|=
name|countAttachments
argument_list|(
name|metadataListB
argument_list|)
decl_stmt|;
comment|//now get that metadata
if|if
condition|(
name|metadataListA
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|metadataListA
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|//the first file should have the same id as the container id
name|String
name|fileId
init|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|containerID
else|:
name|Integer
operator|.
name|toString
argument_list|(
name|ID
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
decl_stmt|;
name|Metadata
name|metadataA
init|=
name|metadataListA
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Metadata
name|metadataB
init|=
literal|null
decl_stmt|;
comment|//TODO: shouldn't be fileA!!!!
name|writeProfileData
argument_list|(
name|fpsA
argument_list|,
name|i
argument_list|,
name|metadataA
argument_list|,
name|fileId
argument_list|,
name|containerID
argument_list|,
name|numAttachmentsA
argument_list|,
name|PROFILES_A
argument_list|)
expr_stmt|;
name|writeExceptionData
argument_list|(
name|fileId
argument_list|,
name|metadataA
argument_list|,
name|EXCEPTION_TABLE_A
argument_list|)
expr_stmt|;
name|int
name|matchIndex
init|=
name|getMatch
argument_list|(
name|i
argument_list|,
name|metadataListA
argument_list|,
name|metadataListB
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchIndex
operator|>
operator|-
literal|1
operator|&&
operator|!
name|handledB
operator|.
name|contains
argument_list|(
name|matchIndex
argument_list|)
condition|)
block|{
name|metadataB
operator|=
name|metadataListB
operator|.
name|get
argument_list|(
name|matchIndex
argument_list|)
expr_stmt|;
name|handledB
operator|.
name|add
argument_list|(
name|matchIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metadataB
operator|!=
literal|null
condition|)
block|{
name|writeProfileData
argument_list|(
name|fpsB
argument_list|,
name|i
argument_list|,
name|metadataB
argument_list|,
name|fileId
argument_list|,
name|containerID
argument_list|,
name|numAttachmentsB
argument_list|,
name|PROFILES_B
argument_list|)
expr_stmt|;
name|writeExceptionData
argument_list|(
name|fileId
argument_list|,
name|metadataB
argument_list|,
name|EXCEPTION_TABLE_B
argument_list|)
expr_stmt|;
block|}
name|writeEmbeddedFilePathData
argument_list|(
name|i
argument_list|,
name|fileId
argument_list|,
name|metadataA
argument_list|,
name|metadataB
argument_list|)
expr_stmt|;
comment|//prep the token counting
name|tokenCounter
operator|.
name|clear
argument_list|(
name|FIELD_A
argument_list|)
expr_stmt|;
name|tokenCounter
operator|.
name|clear
argument_list|(
name|FIELD_B
argument_list|)
expr_stmt|;
comment|//write content
try|try
block|{
name|writeContentData
argument_list|(
name|fileId
argument_list|,
name|metadataA
argument_list|,
name|FIELD_A
argument_list|,
name|CONTENTS_TABLE_A
argument_list|)
expr_stmt|;
name|writeContentData
argument_list|(
name|fileId
argument_list|,
name|metadataB
argument_list|,
name|FIELD_B
argument_list|,
name|CONTENTS_TABLE_B
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|//now run comparisons
if|if
condition|(
name|tokenCounter
operator|.
name|getTokenStatistics
argument_list|(
name|FIELD_A
argument_list|)
operator|.
name|getTotalTokens
argument_list|()
operator|>
literal|0
operator|&&
name|tokenCounter
operator|.
name|getTokenStatistics
argument_list|(
name|FIELD_B
argument_list|)
operator|.
name|getTotalTokens
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Map
argument_list|<
name|Cols
argument_list|,
name|String
argument_list|>
name|data
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|data
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|ID
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
name|ContrastStatistics
name|contrastStatistics
init|=
name|tokenContraster
operator|.
name|calculateContrastStatistics
argument_list|(
name|tokenCounter
operator|.
name|getTokens
argument_list|(
name|FIELD_A
argument_list|)
argument_list|,
name|tokenCounter
operator|.
name|getTokenStatistics
argument_list|(
name|FIELD_A
argument_list|)
argument_list|,
name|tokenCounter
operator|.
name|getTokens
argument_list|(
name|FIELD_B
argument_list|)
argument_list|,
name|tokenCounter
operator|.
name|getTokenStatistics
argument_list|(
name|FIELD_B
argument_list|)
argument_list|)
decl_stmt|;
name|writeContrasts
argument_list|(
name|data
argument_list|,
name|contrastStatistics
argument_list|)
expr_stmt|;
name|writer
operator|.
name|writeRow
argument_list|(
name|CONTENT_COMPARISONS
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//now try to get any Metadata objects in B
comment|//that haven't yet been handled.
if|if
condition|(
name|metadataListB
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|metadataListB
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|handledB
operator|.
name|contains
argument_list|(
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Metadata
name|metadataB
init|=
name|metadataListB
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//the first file should have the same id as the container id
name|String
name|fileId
init|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|containerID
else|:
name|Integer
operator|.
name|toString
argument_list|(
name|ID
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
decl_stmt|;
name|writeProfileData
argument_list|(
name|fpsB
argument_list|,
name|i
argument_list|,
name|metadataB
argument_list|,
name|fileId
argument_list|,
name|containerID
argument_list|,
name|numAttachmentsB
argument_list|,
name|PROFILES_B
argument_list|)
expr_stmt|;
name|writeEmbeddedFilePathData
argument_list|(
name|i
argument_list|,
name|fileId
argument_list|,
literal|null
argument_list|,
name|metadataB
argument_list|)
expr_stmt|;
name|writeExceptionData
argument_list|(
name|fileId
argument_list|,
name|metadataB
argument_list|,
name|EXCEPTION_TABLE_B
argument_list|)
expr_stmt|;
comment|//prep the token counting
name|tokenCounter
operator|.
name|clear
argument_list|(
name|FIELD_B
argument_list|)
expr_stmt|;
comment|//write content
try|try
block|{
name|writeContentData
argument_list|(
name|fileId
argument_list|,
name|metadataB
argument_list|,
name|FIELD_B
argument_list|,
name|CONTENTS_TABLE_B
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|writeEmbeddedFilePathData
parameter_list|(
name|int
name|i
parameter_list|,
name|String
name|fileId
parameter_list|,
name|Metadata
name|mA
parameter_list|,
name|Metadata
name|mB
parameter_list|)
block|{
comment|//container file, don't write anything
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|String
name|pathA
init|=
literal|null
decl_stmt|;
name|String
name|pathB
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|mA
operator|!=
literal|null
condition|)
block|{
name|pathA
operator|=
name|mA
operator|.
name|get
argument_list|(
name|RecursiveParserWrapper
operator|.
name|EMBEDDED_RESOURCE_PATH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mB
operator|!=
literal|null
condition|)
block|{
name|pathB
operator|=
name|mB
operator|.
name|get
argument_list|(
name|RecursiveParserWrapper
operator|.
name|EMBEDDED_RESOURCE_PATH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pathA
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|Cols
argument_list|,
name|String
argument_list|>
name|d
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|d
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|ID
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
name|d
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|EMBEDDED_FILE_PATH
argument_list|,
name|pathA
argument_list|)
expr_stmt|;
try|try
block|{
name|writer
operator|.
name|writeRow
argument_list|(
name|EMBEDDED_FILE_PATH_TABLE_A
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|pathB
operator|!=
literal|null
operator|&&
operator|(
name|pathA
operator|==
literal|null
operator|||
operator|!
name|pathA
operator|.
name|equals
argument_list|(
name|pathB
argument_list|)
operator|)
condition|)
block|{
name|Map
argument_list|<
name|Cols
argument_list|,
name|String
argument_list|>
name|d
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|d
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|ID
argument_list|,
name|fileId
argument_list|)
expr_stmt|;
name|d
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|EMBEDDED_FILE_PATH
argument_list|,
name|pathB
argument_list|)
expr_stmt|;
try|try
block|{
name|writer
operator|.
name|writeRow
argument_list|(
name|EMBEDDED_FILE_PATH_TABLE_B
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|long
name|getSourceFileLength
parameter_list|(
name|List
argument_list|<
name|Metadata
argument_list|>
name|metadataListA
parameter_list|,
name|List
argument_list|<
name|Metadata
argument_list|>
name|metadataListB
parameter_list|)
block|{
name|long
name|len
init|=
name|getSourceFileLength
argument_list|(
name|metadataListA
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|NON_EXISTENT_FILE_LENGTH
condition|)
block|{
return|return
name|len
return|;
block|}
return|return
name|getSourceFileLength
argument_list|(
name|metadataListB
argument_list|)
return|;
block|}
comment|/**      * Try to find the matching metadata based on the RecursiveParserWrapper.EMBEDDED_RESOURCE_PATH      * If you can't find it, return -1;      *      * @param i                index for match in metadataListA      * @param metadataListA      * @param metadataListB      * @return      */
specifier|private
name|int
name|getMatch
parameter_list|(
name|int
name|i
parameter_list|,
name|List
argument_list|<
name|Metadata
argument_list|>
name|metadataListA
parameter_list|,
name|List
argument_list|<
name|Metadata
argument_list|>
name|metadataListB
parameter_list|)
block|{
comment|//TODO: could make this more robust
if|if
condition|(
name|metadataListB
operator|==
literal|null
operator|||
name|metadataListB
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|metadataListA
operator|.
name|size
argument_list|()
operator|==
name|metadataListB
operator|.
name|size
argument_list|()
condition|)
block|{
comment|//assume no rearrangments if lists are the same size
return|return
name|i
return|;
block|}
name|Metadata
name|thisMetadata
init|=
name|metadataListA
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|embeddedPath
init|=
name|thisMetadata
operator|.
name|get
argument_list|(
name|RecursiveParserWrapper
operator|.
name|EMBEDDED_RESOURCE_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|embeddedPath
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|<
name|metadataListB
operator|.
name|size
argument_list|()
condition|)
block|{         }
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|metadataListB
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|String
name|thatEmbeddedPath
init|=
name|metadataListB
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|get
argument_list|(
name|RecursiveParserWrapper
operator|.
name|EMBEDDED_RESOURCE_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|embeddedPath
operator|.
name|equals
argument_list|(
name|thatEmbeddedPath
argument_list|)
condition|)
block|{
return|return
name|j
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|private
name|void
name|writeContrasts
parameter_list|(
name|Map
argument_list|<
name|Cols
argument_list|,
name|String
argument_list|>
name|data
parameter_list|,
name|ContrastStatistics
name|contrastStatistics
parameter_list|)
block|{
name|writeContrastString
argument_list|(
name|data
argument_list|,
name|Cols
operator|.
name|TOP_10_MORE_IN_A
argument_list|,
name|contrastStatistics
operator|.
name|getTopNMoreA
argument_list|()
argument_list|)
expr_stmt|;
name|writeContrastString
argument_list|(
name|data
argument_list|,
name|Cols
operator|.
name|TOP_10_MORE_IN_B
argument_list|,
name|contrastStatistics
operator|.
name|getTopNMoreB
argument_list|()
argument_list|)
expr_stmt|;
name|writeContrastString
argument_list|(
name|data
argument_list|,
name|Cols
operator|.
name|TOP_10_UNIQUE_TOKEN_DIFFS_A
argument_list|,
name|contrastStatistics
operator|.
name|getTopNUniqueA
argument_list|()
argument_list|)
expr_stmt|;
name|writeContrastString
argument_list|(
name|data
argument_list|,
name|Cols
operator|.
name|TOP_10_UNIQUE_TOKEN_DIFFS_B
argument_list|,
name|contrastStatistics
operator|.
name|getTopNUniqueB
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|OVERLAP
argument_list|,
name|Double
operator|.
name|toString
argument_list|(
name|contrastStatistics
operator|.
name|getOverlap
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|put
argument_list|(
name|Cols
operator|.
name|DICE_COEFFICIENT
argument_list|,
name|Double
operator|.
name|toString
argument_list|(
name|contrastStatistics
operator|.
name|getDiceCoefficient
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|writeContrastString
parameter_list|(
name|Map
argument_list|<
name|Cols
argument_list|,
name|String
argument_list|>
name|data
parameter_list|,
name|Cols
name|col
parameter_list|,
name|TokenIntPair
index|[]
name|tokenIntPairs
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|TokenIntPair
name|p
range|:
name|tokenIntPairs
control|)
block|{
if|if
condition|(
name|i
operator|++
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|p
operator|.
name|getToken
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
operator|.
name|append
argument_list|(
name|p
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|put
argument_list|(
name|col
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

